<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Functional programming with arrows</title>
    <link rel="stylesheet" href="../../css/reveal2.css">
    <link rel="stylesheet" href="../../css/theme2.css">
    <link rel="stylesheet" href="../../css/code2.css">
    <!--<link rel="stylesheet" href="../../css/print/paper.css"> -->
    <!--<link rel="stylesheet" href="../../css/print/pdf.css"> -->
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.ico" type="image/x-icon">
  </head>
<body>
  <div class="reveal">
    <div class="slides">

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <div style="height:600px;"><div style="padding:200px 0px 0px 0px;">
        <h2>Functional programming with arrows</h2>
        <h4>Scala Days, June 2015, Amsterdam</h4>
        <p>
          by&nbsp;
          <a href="http://linkedin.com/in/polyulya" class="roll"><span data-title="Yuriy Polyulya">Yuriy Polyulya</span></a>
          &nbsp;@
          <a href="http://workday.github.io/" class="roll"><span data-title="Workday">Workday</span></a>
        </p>
        </div></div>
      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Baseline & Goals:</h3>
        <section>
          <p style="font-size:50%;text-align:left;">The most imaportant ideas in modern functional programming are:</p>
          <ul style="list-style-type:decimal;font-size:150%;width:100%;padding-bottom:100px;">
            <li style="padding-top:50px;" data-fragment-index="0">
              It's all about data
              <p style="font-size:33%;text-align:left;margin-top:10px;">functional programming is all about putting data first.
              The first is defining what kinds of data we have in a problem domain, and what kinds of transformations we want on them.
              Then we are building up the data structures and the code to do the transformations.</p>
            </li>
            <li style="padding-top:50px;" data-fragment-index="1">
              Managing of side-effect
              <p style="font-size:33%;text-align:left;margin-top:10px;">functional programming is not about pure functions any more. Eventually, programs will produce side-effects and side-effect management is a puzzle with many parts.</p>
            </li>
          </ul>

        <aside class="notes">
          The motivation of this presentation is fairly simple, and is repelled by the two most important ideas in modern vision of FP:</br>
          first; all begins from data and then come relations between data-structure; and relation it is what program is</br>
          second; it is no program that can be defined in the form of "pure function", and this is why we allways should concern about the side effects;
        </aside>
        </section>

        <section>
          <div style="height:600px;"><div style="padding:200px 0px 0px 0px;">
          <p style="color:#703D5B;font-size:150%;font-family:'Lobster', sans-serif;">"to show one of techniques of managing your data &amp; control side-effect"</p>
          </div></div>

          <aside class="notes">
          The main purpose of this material is repelled by the motivation and this is “to show one of techniques of managing your data & control side-effect” 
          </aside>
        </section>

      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Function</h3>
        <section><div style="height:600px;"><div style="padding:0px 0px 0px 0px;">
          <div style="height:150px;">
            <div style="position:absolute;margin-left:50px;"><img src="assets/A1.png" alt="url" title=""></div>
            <div class="fragment" data-fragment-index="2" style="position:absolute;margin-left:50px;"><img src="assets/A2.png" alt="url" title=""></div>
            <div class="fragment" data-fragment-index="3" style="position:absolute;margin-left:50px;"><img src="assets/A3.png" alt="url" title=""></div>
            <div class="fragment" data-fragment-index="4" style="position:absolute;margin-left:50px;"><img src="assets/A4.png" alt="url" title=""></div>
          </div>

          <style>
            .nav li {display:inline;}
          </style>
          <div class="nav">
            <ul style="font-size:75%;font-weight:bold;">
              <li class="fragment roll-in" data-fragment-index="1">2 <mark class="green">Objects</mark> ("Hello" &amp; 5) </li>
              <li class="fragment roll-in" data-fragment-index="2"> with <mark class="green">Types</mark> (String &amp; Int)</li>
              <li class="fragment roll-in" data-fragment-index="3"> and <mark class="green">Relation</mark> (String => Int)</li>
            </ul>
          </div>
          </br>

          <div class="fragment" data-fragment-index="4">
          <p style="font-size:75%;text-align:left;font-family:'Lobster', sans-serif;">Abstraction:</p>
          <img src="assets/F1.png" alt="url" title="">
          </div>

          <div class="fragment" data-fragment-index="4">
          <p style="font-size:75%;text-align:left;font-family:'Lobster', sans-serif;">Code:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
val f: String => Int = str => str.length

f("Hello") shouldEqual 5
f("By!")   shouldEqual 3
          </code></pre>
          </div>

        </div>

          <aside class="notes">
            Few words about functions:</br>
            two objects; different types; has relations as a simple function; what looks like arrow from one to other object and define relation between this objects</br>
            In what follows I suggest to use block diagram for the function representation; it is for the convenience of the image but still refer to it as an arrow or function;</br>
            And a simple sample of functions in Scala on the bottom of slide
          </aside>
        </section>

        <section><div style="height:600px;"><div style="padding:0px 0px 0px 0px;">

          <p style="font-size:75%;text-align:left;font-family:'Lobster', sans-serif;">Definition:</p>
          <img src="assets/F2.png" alt="url" title="">

          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Code:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
val f: String => Int = str => str.length
val g: Int => Int    = i => i * 2

val h = g compose f  //  f >>> g

h("Hello")   shouldEqual 10
h("Workday") shouldEqual 14
          </code></pre>
          </div>

          <aside class="notes">
            Functions composition as a diagram. Blocks show that the functions composition should be considered as a function;<br>
            This is what we have in Scala FW out of the box; In other words Scala Predef provide few function conmbinators - high-order functions;</br>
            Would be reasonable to use higher-order functions features in full power
          </aside>
        </section>

      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Combinators</h3>

          <div style="height:400px;width:85%;"><div style="padding:150px 0px 0px 0px;">
              <p style="font-size:90%;">“a function which builds program fragments from program fragments; in a sense the programmer using combinators constructs much of the desired program automatically, rather than writing every detail by hand”</p>
          </div></div>
          <p style="font-size:50%;text-align:right;">- John Hughes Generalising Monads to Arrows</p>

          <aside class="notes">
            Combinators are well described in words of John Hughes in “Generalising Monads to Arrows” and I have nothing to add here;
          </aside>
      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Arrows with Product</h3>
        <p style="font-size:50%;text-align:left;">the structure of a product type is determined by the fixed order of the operands in the product.</br>
        The product of type<sub>1</sub>, ..., type<sub>n</sub> is written type<sub>1</sub> * ... * type<sub>n</sub> in ML and <b>(type<sub>1</sub>,...,type<sub>n</sub>)</b>.</p>

        <section>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Definition:</p>
           <div  style="padding-left:100px;">
             <div style="position:absolute;margin-left:50px;"><img src="assets/P12.png" alt="url" title=""></div>
             <div class="fragment" data-fragment-index="2" style="position:absolute;margin-left:50px;"><img src="assets/P11.png" alt="url" title=""></div>
           </div>

          <aside class="notes">
            As you remember, we began our conversation about data structures, so I would like to continue with them and let's look to some of the common data structures and their relationship to combinators;</br>
            And first will be Product Type.</br>
            I would like to note, in the FP world and in terms of category theory as universal modeling FW; it's more correct to describe any types by functions exposed by these type; in other word; by methods of interaction with these types. Back to the declared Product Type; it will be a right to say that it is a data-type for which the relation in diagram is correct; f == g >>> fst<br>
            In Scala this type represented as Tuple
          </aside>
        </section>

        <section>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Code:</p>

          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
// Tuple2[A, B] - scala implementation of product type
def fst[A,B]: ((A,B)) => A = prod => prod._1  // _1 - scala impl of fst
def snd[A,B]: ((A,B)) => B = prod => prod._2  // _2 - scala impl of snd

def delta[A, B, C]: (C => A) => (C => B) => (C => (A,B)) =
  f => g => x => (f(x), g(x))


val f: String => Int    = str => str.length
val g: String => String = str => str.toUpperCase
val h = delta(f)(g)

forAll { (any: String) =>
  (h andThen fst)(any) == f(any) &&
  (h andThen snd)(any) == g(any)
}
          </code></pre>

          <aside class="notes">
            Sample code which proves that my previous statement about Tuple is true
          </aside>
        </section>

      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Function and Combinators (Part 2)</h3>

        <section><div style="height:600px;">
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">View (split function):</p>
          <img src="assets/F3.png" alt="url" title="">

          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Code:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
val f: String => Int    = str => str.length
val g: String => String = str => str.toUpperCase

val h = f &&& g

h("Hello")   shouldEqual (5, "HELLO")
h("Workday") shouldEqual (7, "WORKDAY")
          </code></pre>

          <aside class="notes">
            As we define first common data-type and the next step it is use it for definition of few next combinators</br>
            And firts will be: “split” combinator what combine two functions so that a parameter of final combinator will be doubled (tupled) and applied for two functions f and g in paralle and result type is a product of functions results; in other worlds Tuple of f and g functions results.</br>
            And Scala sample below
          </aside>
        </section>

        <section>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">View (combine function):</p>
          <img src="assets/F4.png" alt="url" title="">

          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Code:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
val f: String => Int    = str => str.length
val g: String => String = str => str.toUpperCase

val h = f *** g

h("Hello", "Workday") shouldEqual (5, "WORKDAY")
          </code></pre>

          <aside class="notes">
            The next one is “combine” combinator and it's close to first one but combinator's argument is Tuple and result is Tuple too</br>
            Scala semple shows ways haw to use this combinator
          </aside>
        </section>

        <section><div style="height:600px;"><div style="padding:0px 0px 0px 0px;">
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Arrow Type-Class:</p>
          <p style="font-size:50%;text-align:left;">An arrow is the term used in category theory as an abstract notion of thing that behaves like a function.</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
trait Arrow[~>[-_, +_]] extends Category[~>] {

  def arr[B, C](f: B => C): B ~> C

  def first[B, C, D](f: B ~> C): (B, D) ~> (C, D)
  def second[A, B, C](f: A ~> B): (C, A) ~> (C, B)

  def &&&[B, C, C2](fbc: B ~> C, fbc2: B ~> C2): B ~> (C, C2)
  def ***[B, C, B2, C2](fbc: B ~> C, fbc2: B2 ~> C2): (B, B2) ~> (C, C2)
}
          </code></pre>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">And Category Type-Class:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
trait Category[~>[-_, +_]] {

  def id[A]: A ~> A
  def compose[A, B, C](f: B ~> C, g: A ~> B): A ~> C
}
          </code></pre>
        </div>

        <aside class="notes">
          This is a Scala implementation of Arrow type-class;</br>
          As you can see Arrow type-class is sub type of Category type-class because composition of function is a property of category from category theory point of view; we will back to category properties later
        </aside>
      </section>

      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Arrows with CoProduct</h3>
        <p style="font-size:50%;text-align:left;">very similar to the Either data type; the only difference is that it does not combine two base types, but two type constructors.</p>

        <section>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Definition:</p>

           <div style="padding-left:100px;">
             <div style="position:absolute;margin-left:50px;"><img src="assets/P22.png" alt="url" title=""></div>
             <div class="fragment" data-fragment-index="2" style="position:absolute;margin-left:50px;"><img src="assets/P21.png" alt="url" title=""></div>
           </div>

          <aside class="notes">
            Next base type which I want to consider it is Co-Product and if you remember the diagram for Product type then it's not hard to notice that the all arrows in diagram are reversed</br>
            And as before for a type definition I offer to define its ways of interacting; and namely the relations that describes this type;</br>
            And in this case type defined by equality f >>> left == g</br>
            In Scala this type represented as Either
          </aside>
        </section>

        <section>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Code:</p>

          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
// Either[A, B] - scala implementation of co-product type
def left[A,B]: A => Either[A,B]  = a => Left(a)
def right[A,B]: B => Either[A,B] = b => Right(b)

def delta[A, B, C]: (A => C) => (B => C) => (Either[A, B] => C) =
  f => g => x => x match {
    case Left(a)  => f(a)
    case Right(b) => g(b)
  }

val f: Int    => String = i   => i.toString
val g: String => String = str => str * 2
val h = delta(f)(g)

forAll { (anyStr: String, anyInt: Int) =>
  (left andThen h)(anyInt) == f(anyInt) &&
  (right andThen h)(anyStr) == g(anyStr)
}
          </code></pre>

          <aside class="notes">
            Sample code which provs that my previous statement about Either is true
          </aside>
        </section>
      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Function and Combinators (Part 3)</h3>

        <section><div style="height:600px;">
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">View (multiplex function):</p>
          <img src="assets/F5.png" alt="url" title="">

          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Code:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
val f: String => Int    = str => str.length
val g: Int    => String = n => "-" * n

val h = f +++ g

h apply Left[String, Int]("Hello")  shouldEqual L[Int, String](5)
h apply Right[String, Int](5) shouldEqual R[Int, String]("-----")
          </code></pre>

          <aside class="notes">
            As before made for Tuple type; and now for Either type we can define special combinators which will simplify using of fuctions with Either input or output.</br>
            Taking to account internal specific of Either type; let’s look to first combinator “multiplex”; it combines two functions: f and g with next application strategy: f will be applied for Left type of argument and g for Right type</br>
            And sample; how to use of multiplexer combinator for Left and Right values.
          </aside>
        </section>

        <section>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">View (merge function):</p>
          <img src="assets/F6.png" alt="url" title="">

          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Code:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
val f: String => Int    = str => str.length
val g: Int    => String = n => "-" * n

val h = f ||| g

h apply Left[String, Int]("Hello")  shouldEqual 5
h apply Right[String, Int](5) shouldEqual "-----"
          </code></pre>

          <aside class="notes">
            Next combinator is “merge”, and  essence of it is to combine two functions so that for Left and for Right will be applied accordingly f or g functions which has same result type; in other words it is a folding function which encapsulated left and right morphism</br>
            And as usual Scala sample below
          </aside>
        </section>

        <section><div style="height:600px;"><div style="padding:0px 0px 0px 0px;">
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">ArrowChoice Type-Class:</p>
          <p style="font-size:50%;text-align:left;">make a choice between two arrows on the basis of a previous result</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
trait ArrowChoice[~>[-_, +_]] extends Arrow[~>] {
  type E[A, B] = Either[A, B]

  def left[B, C, D](a: B ~> C): E[B, D] ~> E[C, D]
  def right[B, C, D](a: B ~> C): E[D, B] ~> E[D, C]

  def +++[B, C, B2, C2](a: B ~> C, b: B2 ~> C2): E[B, B2] ~> E[C, C2]
  def |||[B, C, D](a: B ~> D, b: C ~> D): E[B, C] ~> D
}
          </code></pre>
        </div>
        <aside class="notes">
          These combinators are part of ArrowChoise type-class;</br>
          Scala implementation of ArrowChoise type-class;</br>
          I do not consider the details of the scala syntax extension implementation; since extensions are rather templated and implementation is enough common
        </aside>
      </section>

    </section>


<!-- ------------------------------------------------------------------------------------- -->

<!--
      <section>
        <h3 style="text-align:left;">Function and Combinators (Part 4)</h3>

        <section><div style="height:600px;">
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Definition:</p>
          <img src="assets/F7.png" alt="url" title="">

          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">Code:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:90%;line-height:100%;">
val factorial: (Int, Int => Int) => (Int, Int => Int) = {
  case (initialValue, loopEntry) => (
    loopEntry(initialValue),    // entry point

    tail => {                   // loop body
      case 0 => 1
      case x => x * tail(x - 1)
    }
  )
}

arr.loop(f)(5) shouldEqual 120
          </code></pre>
        </section>

        <section><div style="height:600px;"><div style="padding:0px 0px 0px 0px;">
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">ArrowLoop Type-Class should look:</p>
          <p style="font-size:50%;text-align:left;">arrow class with a feedback combinator</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
trait ArrowLoop[~>[-_, +_]] extends Arrow[~>] {
  def loop[A, B, C](f: (A, C) ~> (B, C)): A ~> B
}
          </code></pre>

          <div class="fragment roll-in" data-fragment-index="1" style="font-size:50%;">
            <mark style="text-transform:uppercase;" class="red"><b>it does not work</b></mark>
            <p>no easy way to define lazy parameters in lambdas</p>
          </div>

          <div class="fragment roll-in" data-fragment-index="2">
          </br>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">ArrowLoop Type-Class worked implementation:</p>
          <p style="font-size:50%;text-align:left;">LazyTuple2 from Scalaz lib (:&amp;: - type notation)</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
trait ArrowLoop[~>[-_, +_]] extends Arrow[~>] {
  import scalaz._
  import scalaz.Scalaz._

  def loop[A, B, C](f: (A :&: C) ~> (B :&: C)): A ~> C =
    b => new { val ac: (A :&: C) = f(lazyTuple(a, ac._2)) }.ac._1
}
          </code></pre>
          </div>
        </div></section>

      </section>
-->

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Arrows</h3>

          <div style="height:600px;"><div style="padding:150px 0px 0px 0px;">
              <p style="font-size:100%;">Arrow is generalization of function, which provides more function combinators:</br>Like first/second/split/combine, ...</p>
          </div></div>

          <aside class="notes">
            And now it is time to summarize “what is arrow”
          </aside>
      </section>


<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Kleisli &amp; Co-Kleisli Arrow</h3>

        <section>
        <div style="position:absolute;width:100%;">
        <img style="width:initial;" src="assets/C1.png" alt="url" title="">
        <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
val f: String => Int = str => str.length

f("Hello")              shouldEqual 5
Option("Hello").map(f)  shouldEqual Option(5)
        </code></pre>
        </div>

        <div class="fragment" data-fragment-index="1" style="position:absolute;width:100%;">
        <img style="width:initial;" src="assets/C2.png" alt="url" title="">
        <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
val f: String => Option[Int] = str =>
  if(str.length <6) None
  else Option(str.length)

f("Hello")    shouldEqual None
f("Workday")  shouldEqual Option(7)
        </code></pre>
        </div>

        <div class="fragment" data-fragment-index="2" style="position:absolute;width:100%;">
        <img style="width:initial;" src="assets/C3.png" alt="url" title="">
        <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
val f: Option[String] => Int = str =>
  str.map(_.toUpperCase).getOrElse("")


f(Option("Hello"))  shouldEqual "HELLO"
f(None)             shouldEqual ""
        </code></pre>
        </div>

          <aside class="notes">
            Next kind of Arrows it’s Kleisli Arrow; And I would like to return briefly to categories and category properties; For any object type it should be possible to lift this type in category; for Option type it’s “apply” method in companion object; also it should be possible to lift relations between lifted types in our category; for Option type it’s “map” function;<br>
            And what is Kleisli Arrow; this is diagonal arrow which begins in the category of simple types with one type and finishes in monadic category with other type</br>
            For understanding Co-Kleisli Arrow, just enough to reverse this relation
          </aside>
        </section>

        <section>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">KleisliCategory Type-Class:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:90%;line-height:140%;">
type Kleisli[M[+_], -A, +B] = A => M[A]

trait KleisliCategory[M[+_]]
  extends Category[({type λ[-α, +β] = Kleisli[M, α, β]})#λ] {
  // ...
}
          </code></pre>

          </br>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">KleisliCategory Type-Class (with Kind Projector plugin):</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:90%;line-height:140%;">
trait KleisliCategory[M[+_]]
  extends Category[Kleisli[M, -?, +?]] {
  // ...
}
          </code></pre>

          <div style="font-size:60%;text-align:right;width:100%;max-width:100%;margin-top:100px;">
          <a href="https://github.com/non/kind-projector" class="roll"><span data-title="Erik Osheim, Kind Projector on GitHub">Erik Osheim, Kind Projector on GitHub</span></a>
          </div>

          <aside class="notes">
            Type-Class  for Kleisli Arrow can be implemented as follows;</br>
            I would like to digress for say thanks to Erik for Kind Projector plugin; that simplify any type lambas notation; You can see Kleisli type-class with Kind Projector and without it
          </aside>
        </section>

        <section>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">KleisliArrow Type-Class:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
type Kleisli[M[+_], -A, +B] = A => M[A]

trait KleisliCategory[M[+_]]
  extends Category[Kleisli[M, -?, +?]] {
// ...
}

trait KleisliArrow[M[+_]]
  extends Arrow[Kleisli[M, -?, +?]]
  with KleisliCategory[M] {

// ...
}
          </code></pre>

          <div>
            </br>
            <p style="font-size:100%;">But what is <b><mark class="green">M[_]</mark> (only Option)</b>?
          </p></div>

          <aside class="notes">
            Back to our Kleisli Arrow type-class and actually it type-parameters M[_]
          </aside>
        </section>

        <section>
          <ul style="font-size:66%;width:100%;line-height:1.2;">
            <li style="margin: 0 0 20px 0;">
              All functions have effects, the things the function does. The simplest effect is just accepting parameters and returning a single value as a result.
            </li>
            <li>
            Everything else we might conceive a function doing is a side-effect. By <mark class="green"><b>wrapping a value in a container</b></mark>, we can emulate all the various side-effects that are possible.
            </li>
          </ul>

          <div class="fragment" data-fragment-index="2">
            </br><p style="font-size:75%;text-align:left;font-family:'Lobster', sans-serif;">Examples:</p>

            <table cellspacing="0" cellpadding="0" style="width:100%;border:0px solid #F6921D;">
              <tr>
                <td width="30%" style="text-align:left;">
                  <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
A => List[B]
                  </code></pre>
                </td>
                <td width="70%" style="text-align:left;font-size:88%;">
have many results
                </td>
              </tr>
              <tr>
                <td width="30%" style="text-align:left;">
                  <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
A => Option[B]
                  </code></pre>
                </td>
                <td width="70%" style="text-align:left;font-size:88%;">
sometimes have no result
                </td>
              </tr>
              <tr>
                <td width="30%" style="text-align:left;">
                  <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
A => Future[B]
                  </code></pre>
                </td>
                <td width="70%" style="text-align:left;font-size:88%;">
postponed result or may be no result
                </td>
              </tr>
              <tr>
                <td width="30%" style="text-align:left;">
                  <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
A => (S, B)
                  </code></pre>
                </td>
                <td width="70%" style="text-align:left;font-size:88%;">
write to log
                </td>
              </tr>
              <tr>
                <td width="30%" style="text-align:left;">
                  <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
A => (Unit => E, B)
                  </code></pre>
                </td>
                <td width="70%" style="text-align:left;font-size:88%;">
read from environment
                </td>
              </tr>
            </table>
          </div>

          <aside class="notes">
            Any math function has one parameter and one result; Everything else is side-effect; And general idea it is wrap side-effect to container; In other words, localise it for generalising of way to process with side-effect wrapper</br>
            And namely what kind of side-effect and containers do we know:
          </aside>
        </section>

      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Arrows &amp; Monads</h3>

        <section>
          <h4 style="text-align:left;">Common data manipulation techniques for dealing with side-effecting containers:</h4>

          <p style="font-size:75%;text-align:left;font-family:'Lobster', sans-serif;">Functor &amp; Monad (essence):</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
Functor  :  A   =>   B                      =>   C[A]  =>  C[B]
Monad    :  A   => C[B]                     =>   C[A]  =>  C[B]
          </code></pre>

          </br>
          <p style="font-size:75%;text-align:left;font-family:'Lobster', sans-serif;">Arrow (essence):</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;">
Arrow   :  (A  =>   B ) >>> (B  =>   D )    =>   A  =>   D
Kleisli :  (A  => C[B]) >=> (B  => C[D])    =>   A  => C[D]
          </code></pre>

          </br>
          <ul style="font-size:60%;width:100%;line-height:2;">
            <li>Arrows build a container for the whole functions, where Monads just give a common structure for their outputs.</li>
            <li>Arrows can have more then one input.</li>
          </ul>

          <aside class="notes">
            Once we have started talking about the side-effect it would be good to decide on ways to work with containers with side-effect; Firs one it’s monadic-way; And its essence can be easily represented as the following two lines.</br>
            But this is not the only way, as you might guess; Kleisli arrows is second one; And one of advantages of Arrows, this is that arrow build a container for whole functions with side-effect
          </aside>
        </section>

        <section>
          <p style="font-size:100%;text-align:left;font-size:66%;font-family:'Lobster', sans-serif;">For:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:85%;line-height:140%;">
case class User(id: Int, name: String, password: String)

def getUserById: Int => Option[User] = ...
def updateDbUser: User => Option[Int] = ...

def updateName: String => User => Option[User] = ...
def updatePassword: String => User => Option[User] = ...
          </code></pre>

          </br>
          <p style="font-size:100%;text-align:left;font-size:66%;font-family:'Lobster', sans-serif;">Monad usege:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:85%;line-height:140%;">
def update(id: Int, updateUser: User => Option[User]) =
  getUserById(id).flatMap(updateUser).flatMap(updateDbUser)

update(10, (user: User) => updateName(name).flatMap(updatePassword(password)))
          </code></pre>

          </br>
          <p style="font-size:100%;text-align:left;font-size:66%;font-family:'Lobster', sans-serif;">Kleisli usege:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:85%;line-height:140%;">
def update(id: Int, updateUser: User => Option[User]) =
  Kleisli { getUserById(id) } >==> updateUser >==> updateDbUser

update(10, Kleisli { updateName(name) } >==> updatePassword(password))
          </code></pre>

          <aside class="notes">
            For example, let's  consider the following data types and functions</br>
            Monadic-way is well known and advantages of Arrow way is not so good visible at first sight;</br>
            But as you can see; In first implementation we should to wrap our monadic function; but in second implementation this is just a function composition
          </aside>
        </section>

        <section>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">KleisliArrow Type-Class (based on Monad):</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:90%;line-height:140%;">
case class Kleisli[M[+ _], -A, +B](run: A => M[B])

trait KleisliCategory[M[+_]] extends Category[(Kleisli[M, -?, +?]] {
  implicit def Monad: Monad[M]

  def id[A]: Kleisli[M, A, A] = Kleisli(a => Monad.point(a))

  def compose[A, B, C](bc: Kleisli[M, B, C], ab: Kleisli[M, A, B]): Kleisli[M, A, C] =
    bc.flatMap(run(ac), k.run(_: B)))
}

trait KleisliArrow[M[+_]] extends Arrow[Kleisli[M, -?, +?]] with KleisliCategory[M] {

  def arr[A, B](f: A => B): Kleisli[M, A, B] = Kleisli(a => Monad.point(f(a)))

  def first[A, B, C](f: Kleisli[M, A, B]): Kleisli[M, (A, C), (B, C)] =
    Kleisli[M, (A, C), (B, C)] { case (a, c) => Monad.map(f.run(a), (b: B) => (b, c)) }
}
          </code></pre>

          <aside class="notes">
            Time to define the implementation of Kleisli Arrow Type-Class;</br>
            And the simplest implementation Kleisli Arrow will be on the based on monad implementation. It means that if monad already implemented then Kleisli arrows no need additional efforts to implementation
          </aside>
        </section>

        <section>
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;margin: 0px;">And back to the Arrow</p>
          <p style="font-size:50%;text-align:left;">Motivation, is to find a generic interface for arrow wich cannot be based on monad.</p><br>

          <div class="fragment" data-fragment-index="1">
          <p style="font-size:100%;text-align:left;font-size:66%;font-family:'Lobster', sans-serif;margin: 0px;">ArrowMonad Type-Class:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:85%;line-height:130%;">
trait ArrowApply[~>[-_, +_]] extends Arrow[~>] {
  def app[A, B]: (A ~> B, A) ~> B
}

case class ArrowMonad[~>[-_, +_], +A](run: Unit ~> A)

implicit def _asMonad[~>[-_, +_]](implicit i: ArrowApply[~>]):
  Monad[ArrowMonad[~>, +?]] = new Monad[ArrowMonad[~>, +?]] {

    type M[+A] = ArrowMonad[~>, A]

    def point[A](x: => A): M[A] = ArrowMonad { i.arr(_ => x) }
    def flatMap[A, B](m: M[A], f: A => M[B]): M[B] =
      ArrowMonad[~>, B] { m.run >>> i.arr((x: A) => (f(x).run, ())) >>> i.app[Unit, B] }
  }

trait KleisliArrowApply[M[+ _]] extends ArrowApply[Kleisli[M, -?, +?]] {
  private type ~>[-A, +B] = Kleisli[M, A, B]
  def app[A, B]: (A ~> B, A) ~> B = Kleisli { case (f, a) => (f.run)(a) }
}
          </code></pre>
          </div>

          <aside class="notes">
            But I would like to go back to the arrow, and show that they are still self-sufficient; and show how to implement monads based on arrows;</br>
            Here was declared two additional classes ArrowApply and Arrow Monad</aside>
        </section>

        <section>
          <div style="height:600px;">
          <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">High order Arrow Definition (ArrowApply):</p>
          <img src="assets/F8.png" alt="url" title="">
          </br>
          <div>
            <p style="font-size:100%;text-align:left;font-family:'Lobster', sans-serif;">MonadArrow:</p>
            <img src="assets/F9.png" alt="url" title="">
          </div>
          </div>

          <aside class="notes">
            What is ArrowApply; by analogy of high-order function, this is high order arrow; Arrow where first argument is another arrow;</br>
            And ArrowMonad is arrow where firs argument is empty type;</br>
            As I have shown by this two arrow we can implement monad interface
          </aside>
        </section>

      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Kliesli Arrow type-constructor</h3>

        <table cellspacing="5" cellpadding="5" style="width:100%;border:0px solid #F6921D;padding: 50px 0px 0px 0px;">

          <tr style="font-size:65%;text-align:left;">
            <td width="20%"><b>Type-Class</b></td>
            <td width="20%"><b>Kind</b></td>
            <td width="35%"><b>Condition</b></td>
            <td width="20%"><b>Similar type</b></td>
          </tr>

          <tr style="font-size:65%;text-align:left;">
            <td style="background: #0E080D;"><pre><code data-trim class="scala" style="font-size:150%;">Kleisli[_[_], _, _]</code></pre></td>
            <td style="background: #0E080D;"><pre><code data-trim class="scala" style="font-size:150%;">(*->*)->*->*->*</code></pre></td>
            <td style="background: #0E080D;"></td>
            <td style="background: #0E080D;">(Kleisli Arrow)</td>
          </tr>


          <tr style="font-size:65%;text-align:left;">
            <td style="background: #0E080D;"><pre><code data-trim class="scala" style="font-size:150%;">Kleisli[M, _, _]</code></pre></td>
            <td style="background: #0E080D;"><pre><code data-trim class="scala" style="font-size:150%;">* -> * -> *</code></pre></td>
            <td style="background: #0E080D;">M[_] has Monad instance</td>
            <td style="background: #0E080D;">Arrow</td>
          </tr>

          <tr style="font-size:65%;text-align:left;">
            <td style="background: #0E080D;"><pre><code data-trim class="scala" style="font-size:150%;">Kleisli[F, A, _]</code></pre></td>
            <td style="background: #0E080D;"><pre><code data-trim class="scala" style="font-size:150%;">* -> *</code></pre></td>
            <td style="background: #0E080D;">F[_] has Functor instance for A</td>
            <td style="background: #0E080D;">Functor</td>
          </tr>

          <tr style="font-size:65%;text-align:left;">
            <td style="background: #0E080D;"><pre><code data-trim class="scala" style="font-size:150%;">Kleisli[F, A, B]</code></pre></td>
            <td style="background: #0E080D;"><pre><code data-trim class="scala" style="font-size:150%;">*</code></pre></td>
            <td style="background: #0E080D;">have Monoid instance for F[B]</td>
            <td style="background: #0E080D;">Monoid for any A</td>
          </tr>

        </table>

          <aside class="notes">
            Some properties of Kleisli Arrow Type-Class based on type-parameters properties
          </aside>
      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Arrows, Applicatives, Monads</h3>

        <section>
          <table  cellspacing="0" cellpadding="0" style="width:100%;border:0px solid #F6921D;">
            <tr>
              <td width="50%" style="text-align:center;">Arrow</td>
              <td width="50%" style="text-align:center;">Applicative</td>
            </tr>
            <tr>
              <td width="50%" >
              <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:70%;line-height:120%;">
trait Arrow[~>[-_, +_]] extends Category[~>] {
  // [Arrow] -> [Category]
  def id[A]: A ~> A
  def compose[A, B, C](f: B ~> C, g: A ~> B): A ~> C

  // [Arrow] Minimal complete definition
  def arr[B, C](f: B => C): B ~> C
  def first[B, C, D](f: B ~> C): (B, D) ~> (C, D)
}
              </code></pre>
              </td>
              <td width="50%" >
              <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:70%;line-height:120%;">
trait Applicative[M[+_]] extends Functor[M] {
  // [Functor]
  def map[A, B](m: M[A], f: A => B): M[B]

  // [Applicative]
  def point[A](a: => A): M[A]
  def ap[A,B](m: M[A], f: M[A => B]): M[B]
}
              </code></pre>
              </td>
            </tr>
            <tr>
              <td colspan="2" style="text-align:center;">Laws:</td>
            </tr>
            <tr>
              <td>
              <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:68%;line-height:120%;">
// Identity:
arr id                     == id

// Distribute over Composition:
arr(f >>> g)               == arr(f) >>> arr(g)
fst(f >>> g)               == fst(f) >>> fst(g)

// Order must be irrelevant when piping & lifting:
fst(arr(f))                == arr(fst(f))

// Piping function simplification must be equivalen:
fst(f) >>> arr(fst)        == arr(fst) >>> f

// Piped function must be commutative:
fst(f) >>> arr (id *** g)  == arr(id *** g) >>> fst(f)

// Stacked bypasses can be flattened
fst(first(f)) >>> arr assc == arr(assc) >>> fst(f)
// assc[A,B,C]((A,B),C) = (A,(B,C))
             </code></pre>
              </td>
              <td>
              <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:70%;line-height:120%;">
// Identity: fa: F[A]
fa <*> point(id)      == fa

// Composition:
u <*> v <*> w         == u <*> (v <*> w)

// Homomorphism: (a: A, f: A => B)
pount(f) <*> point(a) == point(f(x))

// Interchange: (a: A, fa: F[A => B])
point(a) <*> fa       == fa <*> point(f => f(a))

// As a consequence of these laws,
// the Functor instance for f will satisfy
fa.map(f)             == pure(f) <*> fa
              </code></pre>
              </td>
            </tr>
            <tr style="font-size:50%;">
              <td width="50%" style="text-align:center;"><mark class="green">&nbsp;4&nbsp;</mark> Functions <b>AND</b> <mark class="green">&nbsp;6&nbsp;</mark> Laws</td>
              <td width="50%" style="text-align:center;"><mark class="green">&nbsp;3&nbsp;</mark> Functions <b>AND</b> <mark class="green">&nbsp;4&nbsp;</mark> Laws</td>
            </tr>
          </table>

          <aside class="notes">
            I want to summarize all what I said before; And summarize efforts for implementing monads and arrow hierarchy;</br>
            And goals: to compare how many function should to be implemented and how many laws should to be satisfied</br>
            First will be Arrow and Applicative
          </aside>
        </section>

        <section>
          <table  cellspacing="0" cellpadding="0" style="width:100%;border:0px solid #F6921D;">
            <tr>
              <td width="50%" style="text-align:center;">Arrow</td>
              <td width="50%" style="text-align:center;">Monad</td>
            </tr>
            <tr>
              <td width="50%" >
              <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:70%;line-height:120%;">
trait Arrow[~>[-_, +_]] extends Category[~>] {
  // [Arrow] -> [Category]
  def id[A]: A ~> A
  def compose[A, B, C](f: B ~> C, g: A ~> B): A ~> C

  // [Arrow] Minimal complete definition
  def arr[B, C](f: B => C): B ~> C
  def first[B, C, D](f: B ~> C): (B, D) ~> (C, D)
}
              </code></pre>
              </td>
              <td width="50%" >
              <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:70%;line-height:120%;">
trait Monad[M[+_]] extends Applicative[M] {
  // [Monad] -> [Applicative]
  def point[A](a: => A): F[A]

  // [Monad]
  def flatMap[A, B](ma: M[A], f: A => M[B]): M[B]
}
              </code></pre>
              </td>
            </tr>
            <tr>
              <td colspan="2" style="text-align:center;">Laws:</td>
            </tr>
            <tr>
              <td>
              <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:68%;line-height:120%;">
// Identity:
arr id                     == id

// Distribute over Composition:
arr(f >>> g)               == arr(f) >>> arr(g)
fst(f >>> g)               == fst(f) >>> fst(g)

// Order must be irrelevant when piping & lifting:
fst(arr(f))                == arr(fst(f))

// Piping function simplification must be equivalen:
fst(f) >>> arr(fst)        == arr(fst) >>> f

// Piped function must be commutative:
fst(f) >>> arr (id *** g)  == arr(id *** g) >>> fst(f)

// Stacked bypasses can be flattened
fst(first(f)) >>> arr assc == arr(assc) >>> fst(f)
// assc[A,B,C]((A,B),C) = (A,(B,C))
              </code></pre>
              </td>
              <td>
              <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:70%;line-height:120%;">
// Right identity: (ma: M[A] f: A => M[B])
ma.flatMap(x => point(x)) == ma

// Left identity: (a: A f: A => M[B])
point(a).flatMap(f)       == f(a)

// Associativity:
// (ma: M[A] f: A => M[B], g: B => M[C])
ma.flatMap(f).flatMap(g)  ==
              ma.flatMap(a => f(a).flatMap(g))
              </code></pre>
              </td>
            </tr>
            <tr style="font-size:50%;">
              <td width="50%" style="text-align:center;"><mark class="green">&nbsp;4&nbsp;</mark> Functions <b>AND</b> <mark class="green">&nbsp;6&nbsp;</mark> Laws</td>
              <td width="50%" style="text-align:center;"><mark class="green">&nbsp;1&nbsp;</mark> Functions <b>AND</b> <mark class="green">&nbsp;3&nbsp;</mark> Laws</td>
            </tr>
          </table>

          <aside class="notes">
            Second is Arrow and Monad
          </aside>
        </section>

        <section>
          <table  cellspacing="0" cellpadding="0" style="width:100%;border:0px solid #F6921D;">
            <tr>
              <td colspan="2" style="text-align:left;">Functions:</td>
            </tr>
            <tr style="font-size:50%;">
              <td width="50%" style="text-align:right;padding-right:5%;">Category (id/compose - Predef) <mark class="green">&nbsp;0&nbsp;</mark></td><td width="50%" style="text-align:left;padding-left:5%;"><mark class="green">&nbsp;0&nbsp;</mark> (map - by Applicative &amp; Monad) Functor</td>
            </tr>
            <tr style="font-size:50%;">
              <td width="50%" style="text-align:right;padding-right:5%;">Arrow (arr/first) <mark class="green">&nbsp;2&nbsp;</mark></td><td width="50%" style="text-align:left;padding-left:5%;"><mark class="green">&nbsp;2&nbsp;</mark> (point/ap) Applicative</td>
            </tr>
            <tr style="font-size:50%;">
              <td width="50%" style="text-align:right;padding-right:5%;">Kleisli (flatMap) <mark class="green">&nbsp;1&nbsp;</mark></td><td width="50%" style="text-align:left;padding-left:5%;"><mark class="green">&nbsp;1&nbsp;</mark> (flatMap) Monad</td>
            </tr>
            <tr style="font-size:85%;">
              <td width="50%" style="text-align:right;padding-right:5%;"><mark class="green">&nbsp;3&nbsp;</mark></td><td width="50%" style="text-align:left;padding-left:5%;"><mark class="green">&nbsp;3&nbsp;</mark></td>
            </tr>
            <tr>
              <td colspan="2" style="text-align:left;">Laws:</td>
            </tr>
            <tr style="font-size:50%;">
              <td width="50%" style="text-align:right;padding-right:5%;">Category <mark class="green">&nbsp;3&nbsp;</mark></td><td width="50%" style="text-align:left;padding-left:5%;"><mark class="green">&nbsp;2&nbsp;</mark> Functor</td>
            </tr>
            <tr style="font-size:50%;">
              <td width="50%" style="text-align:right;padding-right:5%;">Arrow <mark class="green">&nbsp;6&nbsp;</mark></td><td width="50%" style="text-align:left;padding-left:5%;"><mark class="green">&nbsp;4&nbsp;</mark> Applicative</td>
            </tr>
            <tr style="font-size:50%;">
              <td width="50%" style="text-align:right;padding-right:5%;">Kleisli <mark class="green">&nbsp;-&nbsp;</mark></td><td width="50%" style="text-align:left;padding-left:5%;"><mark class="green">&nbsp;3&nbsp;</mark> Monad</td>
            </tr>
            <tr style="font-size:85%;">
              <td width="50%" style="text-align:right;padding-right:5%;"><mark class="green">&nbsp;9&nbsp;</mark></td><td width="50%" style="text-align:left;padding-left:5%;"><mark class="green">&nbsp;9&nbsp;</mark></td>
            </tr>
          </table>

          <aside class="notes">
            Final comparison table; Efforts are enough equal;</br>
            As I say; If you have implementation of monad you will get implementation of arrow with zero efforts and vice versa if you have implementation of Arrow you will get Monad for free.</br>
            And difference only in chosen basis: composition or application of function with side-effect; But in any case you should to implement only two natural transformations: etta and nyu for your monadic category
          </aside>
        </section>

      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Arrows, Applicatives, Monads Summary</h3>

        <div style="position:absolute;margin-left:50px;"><img src="assets/FP2.png" alt="url" title=""></div>
        <div class="fragment" data-fragment-index="1" style="position:absolute;margin-left:50px;"><img src="assets/FP4.png" alt="url" title=""></div>
        <div class="fragment" data-fragment-index="2" style="position:absolute;margin-left:50px;"><img src="assets/FP5.png" alt="url" title=""></div>

          <aside class="notes">
            If to put together hierarchy of Arrow and Monad;</br>
            You can see a lot of the functionality intersection, I mean that many structures can be used for the same purposes and the final choice should always be based on the goals and expressiveness of code; after all code should be concise and readable
          </aside>
      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">End user benefits:</h3>

        <section>
          <div class="fragment" data-fragment-index="2" style="height:300px;"><div style="padding:50px 0px 0px 0px;">
            <h1>Railway Oriented Programming</h1>
            <p style="font-size:50%;text-align:right;margin-top:10px;">- Scott Wlaschin (F# for fun and profit)</p>
          </div></div>

          <aside class="notes">
            And few arrows examples;</br>
            For all who has a dream to be a train dispatcher; At this moment you are in one step from your dream; since then we will talk about the  RAILWAY ORIENTED PROGRAMMING.</br>
            I like this metaphor and I first time met it in Scott Wlaschin blog; and it good reflects essence of this approach;
          </aside>
        </section>

        <section>
          <p style="font-size:100%;text-align:left;font-size:90%;font-family:'Lobster', sans-serif;margin: 0px;">Railway tracks:</p>
          <div style="height:250px;">
          <div style="position:absolute;"><img src="assets/R1.png" alt="url" title=""></div>
          <div class="fragment" data-fragment-index="2" style="position:absolute;"><img src="assets/R2.png" alt="url" title=""></div>
          <div class="fragment" data-fragment-index="3" style="position:absolute;"><img src="assets/R3.png" alt="url" title=""></div>
          <div class="fragment" data-fragment-index="4" style="position:absolute;"><img src="assets/R4.png" alt="url" title=""></div>
          </div>

          <p style="font-size:100%;text-align:left;font-size:90%;font-family:'Lobster', sans-serif;margin: 0px;">Arrow as Framework for:</p></br>
          <ul style="list-style-type:decimal;font-size:60%;width:100%;line-height:1.5;">
            <li class="fragment" data-fragment-index="2">Error handling</li>
            <li class="fragment" data-fragment-index="3">Single Track Function</li>
            <li class="fragment" data-fragment-index="4">Dead-end Function</li>
            <li class="fragment" data-fragment-index="5">Supervisory Function (handle "both track")</li>
          </ul>

          </br></br>
          <h3 class="fragment" data-fragment-index="6">Dataflow programming (programming paradigm)</h3>

          <aside class="notes">
            If we have a functions track like in diagram; We should to care about composition of steps what can rise errors; and single track function; or dead end functions; or handle both track</br>
            And adventages of Arrow FW that we already have set of combinators for most of our needs;</br>
            since it is fairly well-known programming paradigm - Dataflow Programm
          </aside>
        </section>

        <section>
          <p style="font-size:75%;text-align:left;font-family:'Lobster', sans-serif;margin-bottom:0px;">Initial:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:90%;line-height:120%;">
case class User(id: Int, name: String, psswd: String, email: String)
def getUserById: Int => Either[Err, User] = ???
def updateDbUser: User => Either[Err, Int] = ???
def updateName: String => User => User = ???
def sendEmail: User => Unit = ???

def id[T]: T => T = x => x
def leftId[E, T]: Err => Either[E, T] = x => Left { x }
def fst[A, B]: (A, B) => A = _._1
          </code></pre>

          <div class="fragment" style="margin-top:20px;">
          <p style="font-size:75%;text-align:left;font-family:'Lobster', sans-serif;margin-bottom:0px;">Track:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:90%;line-height:120%;">
val run =
  getUserById >>>
  updateName(name).right >>>
  ((id[User] &&& sendEmail) >>> fst).right >>>
  (leftId[Err, Int] ||| updateDbUser) // Either[Err, Int]
          </code></pre>
          </div>

          <div class="fragment" style="margin-top:20px;">
          <p style="font-size:75%;text-align:left;font-family:'Lobster', sans-serif;margin-bottom:0px;">Track with Kleisli:</p>
          <pre><code data-trim class="scala" style="max-height:100%;height:100%;font-size:90%;line-height:120%;">
val run = Kleisli[Either[Err, +?], Int, User] {
    getUserById >>>
    updateName(name).right >>>
    ((id[User] &&& sendEmail) >>> fst).right
  } >==> updateDbUser // Either[Err, Int]
          </code></pre>
        </div>

          <aside class="notes">
            And the same track in Scala;</br>
            First track is basen on Arrow Framework;<br>
            And second one if we have monadic implementation for Either type-class and can use Kleisli arrow
          </aside>
        </section>
      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <h3 style="text-align:left;">Used materials and References:</h3>
        <ul style="list-style-type:decimal;font-size:50%;width:100%;line-height:1.8;">
          <li>John Hughes. November 10, 1998, <b>Generalising Monads to Arrows.</b></li>
          <li>Chris Heunen and Bart Jacobs, <b>Arrows, like Monads, are Monoids.</b></li>
          <li>Ted Cooper (theod@pdx.edu), CS510 – Spring 2014, <b>Arrow Basics</b>.</li>
          <li>John Hughes, S-41296 Sweden, <b>Programming with Arrows.</b></li>
          <li>Robert Atkey, LFCS, 2008, <b>What is a Categorical Model of Arrows?</b></li>
          <li>Kazuyuki Asada, Kyoto 606-8502, Japan, <b>Arrows are Strong Monads.</b></li>
          <li>K. Asada and I. Hasuo, (CMCS 2010)., 2010, <b>Categorifying computations into components via arrows as profunctors.</b></li>
          <li>Thorsten Altenkirch, James Chapman, and Tarmo Uustalu, <b>Monads Need Not Be Endofunctors.</b></li>
          <li>Sam Lindley, Philip Wadler and Jeremy Yallop, 2008, <b>Idioms are oblivious, arrows are meticulous, monads are promiscuous</b></li>
        </ul>
        <h4 style="text-align:left;"></br>Blogs & Blogposts:</h4>
        <ul style="list-style-type:decimal;font-size:50%;width:100%;line-height:1.8;">
          <li>Ruminations of a Programmer, Debasish Ghosh</li>
          <li>F# for fun and profit, Scott Wlaschin</li>
          <li>Metaplasmus, Travis Brown</li>
          <li>Arrow's place in the Applicative/Monad hierarchy (Cactus) Dr. Gerg ˝o Érdi</li>
          <li>Nothing Personal Just ⊥, Patai Gergely</li>
          <li>Programming Cafe, Bartosz Milewski's</li>
          <li>λ Tony's blog λ, Tony Morris</li>
        </ul>
      </section>

<!-- ------------------------------------------------------------------------------------- -->
      <section>
        <div style="height:600px;"><div style="padding:200px 0px 0px 0px;">
        <ul style="width:100%;list-style-type:none;list-style:none;align:center;text-align:center;">
          <li data-fragment-index="0"><h2>Questions?</h2><br/></li>
          <li class="fragment roll-in" data-fragment-index="1"><h2>Remarks?</h2></li>
        </ul>
        </div></div>
      </section>

    </div>
  </div>

  <script src="../../js/reveal.min.js"></script>
  <script src="../../js/head.min.js"></script>
  <script>
    Reveal.initialize({
      controls: true,
      progress: true,
      rollingLinks: true,
      history: true,
      center: false,
      theme: Reveal.getQueryHash().theme,

      transition: 'linear',
      backgroundTransition: 'slide',

      dependencies: [
          { src: '../../js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../../js/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: '../../js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../../js/notes.js', async: true }
        ]
     });
  </script>
  <script type="text/javascript" src="../../js/highlight.js"></script>
  <script type="text/javascript" src="../../js/zoom.js"></script>
</body>
</html>
