<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="description" content="" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Open Graph -->
  <meta property="og:site_name" content="Midset Footprint" />
  <meta property="og:title" content="Architecting Real-Time Ads Platforms: A Distributed Systems Engineer&#x27;s Design Exercise - Midset Footprint" />
  <meta property="og:url" content="https:&#x2F;&#x2F;e-mindset.space&#x2F;blog&#x2F;architecting-real-time-ads-platforms-design-exercise&#x2F;" />
  <meta property="og:description" content="A design exploration of building real-time ads platforms serving 400M+ users with sub-100ms latency. Applying distributed systems principles to RTB protocols, ML inference pipelines, auction algorithms, and resilience patterns - a thought experiment in solving complex distributed systems challenges." />

  <title>Architecting Real-Time Ads Platforms: A Distributed Systems Engineer&#x27;s Design Exercise - Midset Footprint</title>

  <link rel="canonical" href="https:&#x2F;&#x2F;e-mindset.space&#x2F;blog&#x2F;architecting-real-time-ads-platforms-design-exercise&#x2F;" />
  <link rel="stylesheet" type="text/css" href="https://e-mindset.space/css/main.css" />
  <link rel="stylesheet" type="text/css" href="https://e-mindset.space/css/fonts.css" />
  <link rel="apple-touch-icon" sizes="180x180" href="https://e-mindset.space/icon/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="https://e-mindset.space/icon/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="https://e-mindset.space/icon/favicon-16x16.png" />
  <link rel="manifest" href="https://e-mindset.space/icon/site.webmanifest" />

  
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-X0M5X84BLR"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-X0M5X84BLR');
    </script>
  

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>

  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11.9.0/dist/mermaid.esm.min.mjs';

    function getCSSVariable(variable, fallback) {
      if (typeof window !== 'undefined' && typeof document !== 'undefined') {
        return getComputedStyle(document.documentElement).getPropertyValue(variable).trim() || fallback;
      }
      return fallback;
    };

    mermaid.initialize({
      startOnLoad: true, 
      theme: 'base',
      themeVariables: {
        primaryColor: getCSSVariable('--mermaid-primary-color', '#002528'),
        primaryTextColor: getCSSVariable('--mermaid-primary-text-color', '#fff'),
        primaryBorderColor: getCSSVariable('--mermaid-primary-border-color', '#7C0000'),
        lineColor: getCSSVariable('--mermaid-line-color', '#F8B229'),
        secondaryColor: getCSSVariable('--mermaid-secondary-color', '#006100'),
        tertiaryColor: getCSSVariable('--mermaid-tertiary-color', '#fff'),
        edgeLabelBackground: getCSSVariable('--mermaid-edge-label-background', '#fff'),
        edgeLabelColor: getCSSVariable('--mermaid-edge-label-color', '#000')
      }
    });
  </script>

</head>
<body>
  <header id="site-nav">
  <nav>
    <ul>
      
        <li>
          <a href="https://e-mindset.space/"><i data-feather="coffee" class="ico"></i>&nbsp;Blog</a>
        </li>
      
        <li>
          <a href="https://e-mindset.space/about"><i data-feather="user" class="ico"></i>&nbsp;About</a>
        </li>
      
    </ul>
  </nav>
</header>
<div id="main" class="container">
    
<h1>Architecting Real-Time Ads Platforms: A Distributed Systems Engineer&#x27;s Design Exercise</h1>
  <small>
    <time datetime=" 2025-10-15T00:00:00+00:00" pubdate>15 October 2025</time>
      <span>•</span>
      <span>Author: Yuriy Polyulya</span>
        <span>•</span>
        <ul class="tags">
            <li>
              <a class="tag" href="https://e-mindset.space/tags/distributed-systems/">#distributed-systems</a>
            </li>
            <li>
              <a class="tag" href="https://e-mindset.space/tags/system-design/">#system-design</a>
            </li>
        </ul>
  </small>

<hr/>






<h2 id="introduction-the-challenge-of-real-time-ad-serving-at-scale">Introduction: The Challenge of Real-Time Ad Serving at Scale</h2>
<p>Full disclosure: I’ve never built an ads platform before. But I’ve spent years working on distributed systems and mathematical optimization problems - from cost optimization in large-scale infrastructure to performance tuning under strict latency constraints. This design exercise is my way of keeping the brain engaged with complex systems thinking. Think of it as a more interesting alternative to sudoku, except instead of filling in numbers, I’m optimizing auction latencies and cache hit rates.</p>
<p>What makes this problem particularly compelling is the combination of technical complexity and clear economic traceability. Unlike many distributed systems where cost optimization happens in abstract infrastructure units, ad platforms offer direct financial transparency - every click has a measurable value, every millisecond of latency has quantifiable revenue impact, and you can trace the complete economic chain from CAPEX (infrastructure costs) through OPEX (operational overhead) to revenue per impression. A user opens an app, sees a relevant ad in under 100ms, clicks it, and the advertiser gets billed. Straightforward, right? But decompose the mechanics - coordinating real-time auctions across dozens of bidding partners, running ML predictions in &lt;40ms, maintaining budget consistency across regions, handling 1M+ queries per second - and it becomes a fascinating exercise in multi-dimensional optimization with hard constraints and measurable outcomes.</p>
<p>Here’s the scale I’m designing for in this thought experiment:</p>
<ul>
<li><strong>400M+ daily active users</strong> generating continuous ad requests</li>
<li><strong>1M+ queries per second</strong> during peak traffic</li>
<li><strong>Sub-100ms p95 latency</strong> for the entire request lifecycle</li>
<li><strong>Real-time ML inference</strong> for click-through rate prediction</li>
<li><strong>Distributed auction mechanisms</strong> coordinating with 50+ external bidding partners</li>
<li><strong>Multi-region deployment</strong> with eventual consistency challenges</li>
</ul>
<p>I’m treating this as a design exercise - exploring how I’d apply my distributed systems experience to this domain. I’ll walk through my thought process on:</p>
<ol>
<li><strong>Figuring out requirements</strong> and modeling performance constraints</li>
<li><strong>Designing the high-level architecture</strong> and breaking down latency budgets</li>
<li><strong>Real-Time Bidding (RTB) integration</strong> - OpenRTB is… interesting (and by interesting I mean “spec written in 2012 that everyone implements slightly differently”)</li>
<li><strong>ML inference pipelines</strong> that somehow need to finish in under 50ms</li>
<li><strong>Distributed caching strategies</strong> (because hitting the database for everything won’t scale)</li>
<li><strong>Auction mechanisms</strong> - there’s some cool game theory here</li>
<li><strong>Advanced topics</strong> like budget pacing, fraud detection, multi-region failover</li>
<li><strong>What breaks and why</strong> - because everything breaks eventually</li>
</ol>
<p>Fair warning: I’m going to dive pretty deep into the math and trade-offs. My goal is to show not just the “what” but the “why” behind design decisions.</p>
<p><strong>Acknowledgment - On learning time optimization:</strong> This design exercise involved diving deep into ad-tech domain knowledge I didn’t previously have (OpenRTB protocols, auction mechanisms, RTB latency constraints, etc.). I used AI assistants extensively as research tools - to surface relevant technical papers, summarize industry standards, point me to the right documentation, and validate technical assumptions. Think of it as optimizing yet another cost dimension: <strong>learning time</strong>. Instead of spending weeks manually hunting through scattered documentation and outdated blog posts, AI helped compress domain research from weeks to days.</p>
<p>This took about 3 weeks of learning, researching, and writing. Given the scope (3000+ lines covering distributed systems, ML pipelines, auction algorithms, financial compliance, and more), expect inconsistencies, calculation errors, and heavily opinionated architectural choices. Synthesizing knowledge across multiple domains while learning new material tends to produce those human artifacts.</p>
<p>Ironically, for a post about optimization, this one’s pretty unoptimized - verbose, repetitive, twice as long as it needs to be. That’s what happens when you learn while writing. Feedback and suggestions for cuts welcome.</p>
<p><strong>Note on costs:</strong> Throughout this post, I’ll discuss cost comparisons between different technologies. Please note that pricing varies significantly by cloud provider, region, contract negotiations, and changes over time. The cost figures I mention are rough approximations to illustrate relative differences, not exact pricing you should rely on. Always check current pricing from vendors and factor in your specific usage patterns and potential enterprise discounts.</p>
<hr />
<h2 id="part-1-requirements-and-constraints">Part 1: Requirements and Constraints</h2>
<div class="part-toc">
<div class="part-toc-header">
<div class="part-toc-title">In this part:</div>
</div>
<ul>
<li><a href="#functional-requirements">Functional Requirements</a>
<span class="part-toc-desc">Core capabilities: ad serving, targeting, bidding, billing</span></li>
<li><a href="#architectural-drivers-the-three-non-negotiables">Architectural Drivers: The Three Non-Negotiables</a>
<span class="part-toc-desc">Latency, scale, consistency requirements</span></li>
<li><a href="#non-functional-requirements-performance-modeling">Non-Functional Requirements: Performance Modeling</a>
<span class="part-toc-desc">Latency budgets, throughput targets, availability SLAs</span></li>
<li><a href="#scale-analysis">Scale Analysis</a>
<span class="part-toc-desc">Traffic patterns, storage calculations, bandwidth requirements</span></li>
</ul>

<div class="part-toc-nav">


    <a href="#part-2-high-level-architecture" class="next-part-link">Part 2: High-Level Architecture <i class="fa fa-angle-double-down"></i></a>

</div>

</div>
<h3 id="functional-requirements">Functional Requirements</h3>
<p>Okay, so first things first - what does this system actually need to do? I’ve broken it down into a few key areas:</p>
<p><strong>1. Multi-Format Ad Delivery</strong></p>
<p>You need to handle all the different ad types users expect these days - story ads, video ads, carousel ads, even AR-enabled ads if you’re feeling fancy. And of course, it all needs to work on iOS, Android, and web. The creative assets should come from a CDN (Content Delivery Network - obviously), aiming for sub-100ms first-byte time.</p>
<p><strong>2. Real-Time Bidding (RTB) Integration</strong></p>
<p>This is where things get interesting. You’re implementing OpenRTB 2.5+ (or whatever version is current), talking to 50+ demand-side platforms (DSPs - the external bidding partners who represent advertisers and bid on ad inventory) simultaneously. The IAB (Interactive Advertising Bureau) standards give you a hard 30ms timeout for the auction - which sounds generous until you realize you need to do 50+ network calls in parallel. And if you think that’s easy, wait until you discover that some DSPs are in Europe, some are in Asia, and suddenly you’re trying to do a 30ms global auction with 150ms round-trip times to some bidders.</p>
<p>Oh, and you also need to handle both programmatic and guaranteed inventory, which have completely different SLAs and business logic. Fun!</p>
<p><strong>3. ML-Powered Targeting and Optimization</strong></p>
<p>The ML stuff is critical for revenue:</p>
<ul>
<li>Real-time CTR (click-through rate) prediction (you can’t just serve random ads)</li>
<li>Conversion rate optimization</li>
<li>Dynamic creative optimization (showing different ad variants)</li>
<li>Budget pacing algorithms (so advertisers don’t blow their entire budget in the first hour)</li>
</ul>
<p><strong>4. Campaign Management</strong></p>
<p>Then there’s all the campaign management stuff - real-time performance metrics, A/B testing framework, frequency capping (nobody wants to see the same ad 50 times), quality scoring, policy compliance, etc.</p>
<h3 id="architectural-drivers-the-three-non-negotiables">Architectural Drivers: The Three Non-Negotiables</h3>
<p>Before diving into non-functional requirements, we need to establish the three <strong>immutable constraints</strong> that guide every design decision. Understanding these upfront helps explain the architectural choices throughout this post.</p>
<p><strong>Driver 1: Latency (Sub-100ms p95)</strong></p>
<p><strong>Why this matters:</strong> Mobile apps typically timeout after 150ms. Users expect ads to load instantly - if your ad is still loading when the page renders, you show a blank space and earn $0.</p>
<p>Amazon’s 2006 study found that every 100ms of added latency costs ~1% of sales. In advertising, this translates directly: slower ads = fewer impressions = less revenue.</p>
<p>At our target scale of 1M queries per second, breaching the 150ms timeout threshold means mobile apps give up waiting, resulting in blank ad slots and complete revenue loss on those requests.</p>
<p><strong>The constraint:</strong> Maintain sub-100ms p95 latency for the complete request lifecycle - from when the user opens the app to when the ad displays.</p>
<p><strong>Driver 2: Financial Accuracy (Zero Tolerance)</strong></p>
<p><strong>Why this matters:</strong> Advertising is a financial transaction. When an advertiser sets a $10,000 campaign budget, they expect to spend $10,000 - not $10,500 or $9,500.</p>
<p>Billing discrepancies above 2-5% trigger lawsuits and regulatory scrutiny. Even 1% errors generate complaints and credit demands. Beyond legal risk, billing errors destroy advertiser trust - your platform’s reputation depends on financial accuracy.</p>
<p>Regulatory frameworks (FTC in the US, Digital Services Act in EU) mandate accurate spend tracking and transparent billing.</p>
<p><strong>The constraint:</strong> Achieve ≤1% billing accuracy for all advertiser spend. Under-delivery (spending less than budget) costs revenue; over-delivery (spending more than budget) causes legal and trust issues.</p>
<p><strong>Driver 3: Availability (99.9%+ Uptime)</strong></p>
<p><strong>Why this matters:</strong> Unlike many services where downtime is annoying but tolerable, ad platforms lose revenue for every second they’re unavailable. No availability = no ads = no money.</p>
<p>A 99.9% uptime target means 43 minutes of allowed downtime per month. This error budget must cover all sources of unavailability. However, through zero-downtime deployment and migration practices (detailed in Part 10), we can eliminate <strong>planned</strong> downtime entirely, reserving the full 43 minutes for <strong>unplanned</strong> failures.</p>
<p><strong>The constraint:</strong> Maintain 99.9%+ availability with the system remaining operational even when individual components fail. All planned operations (deployments, schema changes, configuration updates) must be zero-downtime.</p>
<p><strong>When These Constraints Conflict:</strong></p>
<p>These three drivers sometimes conflict with each other. For example, ensuring financial accuracy may require additional verification steps that add latency. Maximizing availability might mean accepting some data staleness that could affect billing precision.</p>
<p>When trade-offs are necessary, we prioritize:</p>
<p><strong>Financial Accuracy &gt; Availability &gt; Latency</strong></p>
<p>Rationale: Legal and trust issues from billing errors have longer-lasting impact than temporary downtime; downtime has more severe consequences than slightly slower ad delivery. Throughout this post, when you see architectural decisions that seem to sacrifice latency or availability, they’re usually protecting financial accuracy.</p>
<h3 id="non-functional-requirements-performance-modeling">Non-Functional Requirements: Performance Modeling</h3>
<p>Formalizing the performance constraints:</p>
<p><strong>Latency Distribution Constraint:</strong>
$$P(\text{Latency} \leq 100\text{ms}) \geq 0.95$$</p>
<p>So this just means 95% of requests need to finish within 100ms. The tricky part is that total latency is the sum of all the services in the request path:</p>
<p>$$T_{total} = \sum_{i=1}^{n} T_i$$</p>
<p>where \(T_i\) is the latency of each service. If you have 5 services each taking 20ms, you’re already at 100ms with zero margin for error.</p>
<p>Strict latency budgets are critical: incremental service calls (“only 10ms each”) compound quickly, potentially doubling p99 latency from 100ms to 200ms.</p>
<p><strong>Throughput Requirements:</strong></p>
<p>Target peak load:
$$Q_{peak} \geq 1.5 \times 10^6 \text{ QPS}$$</p>
<p>Using Little’s Law to relate throughput, latency, and concurrency. With service time \(S\) and \(N\) servers:
$$N = \frac{Q_{peak} \times S}{U_{target}}$$</p>
<p>where \(U_{target}\) is target utilization. This fundamental queueing theory relationship helps us understand the capacity needed to handle peak traffic while maintaining acceptable response times.</p>
<p><strong>Availability Constraint:</strong></p>
<p>Target “five nines” (99.999% uptime):
$$A = \frac{\text{MTBF}}{\text{MTBF} + \text{MTTR}} \geq 0.99999$$</p>
<p>where MTBF = Mean Time Between Failures, MTTR = Mean Time To Recovery.</p>
<p>This translates to <strong>26 seconds</strong> of allowed downtime per month (0.43 minutes). A single bad deploy or infrastructure misconfiguration can exhaust this entire budget.</p>
<p><strong>Consistency Requirements:</strong></p>
<p>Different data types require different consistency guarantees. Treating everything as strongly consistent degrades performance, while treating everything as eventually consistent creates financial and correctness issues.</p>
<ul>
<li>
<p><strong>Financial data</strong> (ad spend, billing): Strong consistency required
$$\forall t_1 &lt; t_2: \text{Read}(t_2) \text{ observes } \text{Write}(t_1)$$</p>
<p>Billing accuracy is non-negotiable, but engineering trade-offs create acceptable bounds. The system must prevent unbounded over-delivery from race conditions. <strong>Bounded over-delivery ≤1% of budget</strong> is acceptable due to practical constraints like server failures and network partitions.</p>
<p>Under-delivery is worse (lost revenue + advertiser complaints), so slight over-delivery is the lesser evil. Legal precedent: lawsuits typically arise from systematic errors &gt;2-5%, not sub-1% technical variance.</p>
</li>
<li>
<p><strong>User preferences and profiles</strong>: Eventual consistency acceptable
$$\lim_{t \to \infty} P(\text{AllReplicas consistent}) = 1$$</p>
<p>If a user updates their interests and sees old targeting for a few seconds, it’s not critical.</p>
<p><strong>Practical example:</strong> User adds “fitness equipment” to their interests. If they see ads for electronics for the next 10-20 seconds while the update propagates across replicas, that’s acceptable. The user doesn’t even notice, and we haven’t lost revenue.</p>
</li>
<li>
<p><strong>Operational dashboards and reporting</strong>: Eventual consistency acceptable</p>
<p>Real-time dashboards showing “impressions served so far today” can tolerate 10-30 second staleness. Advertisers checking campaign progress don’t need millisecond-accurate counts.</p>
</li>
</ul>
<p><strong>Key insight:</strong> The challenge is reconciling strong consistency requirements for financial data with the latency constraints. Without proper atomic enforcement, race conditions could cause severe over-budget scenarios (e.g., multiple servers simultaneously allocating from the same budget). This is explored in detail in Part 7.</p>
<h3 id="scale-analysis">Scale Analysis</h3>
<p><strong>Data Volume Estimation:</strong></p>
<p>With 400M Daily Active Users (DAU), averaging 20 ad requests/user/day:</p>
<ul>
<li>Daily ad requests: <strong>8B requests/day</strong></li>
<li>Daily log volume (at 1KB per log): <strong>8TB/day</strong></li>
</ul>
<p><strong>Storage Requirements:</strong></p>
<ul>
<li>User profiles (10KB per user): <strong>4TB</strong></li>
<li>Historical ad performance (30 days retention, 100B per impression): <strong>~24TB</strong></li>
</ul>
<p><strong>Cache Requirements:</strong></p>
<p>To achieve acceptable response times, frequently accessed data needs to be cached. User access patterns follow a power law distribution where a small fraction of users generate the majority of traffic.</p>
<p>Estimated cache needs: <strong>~800GB</strong> of hot data to serve most requests from memory.</p>
<p><em>Note: See Part 5 (Distributed Caching Architecture) for detailed analysis of cache sizing, hit rate optimization, and distribution strategies.</em></p>
<hr />
<h2 id="part-2-high-level-architecture">Part 2: High-Level Architecture</h2>
<div class="part-toc">
<div class="part-toc-header">
<div class="part-toc-title">In this part:</div>
</div>
<ul>
<li><a href="#system-components-and-request-flow">System Components and Request Flow</a>
<span class="part-toc-desc">Service architecture, request pipeline, component interactions</span></li>
<li><a href="#latency-budget-decomposition">Latency Budget Decomposition</a>
<span class="part-toc-desc">Breaking down 100ms budget across services</span></li>
<li><a href="#rate-limiting-volume-based-traffic-control">Rate Limiting: Volume-Based Traffic Control</a>
<span class="part-toc-desc">Token bucket, QPS limits, backpressure</span></li>
<li><a href="#critical-path-analysis">Critical Path Analysis</a>
<span class="part-toc-desc">Identifying bottlenecks, optimization priorities</span></li>
<li><a href="#fault-tolerance-and-circuit-breaker-patterns">Fault Tolerance and Circuit Breaker Patterns</a>
<span class="part-toc-desc">Resilience patterns, failure handling</span></li>
<li><a href="#degradation-strategy-when-services-breach-latency-budgets">Degradation Strategy: When Services Breach Latency Budgets</a>
<span class="part-toc-desc">Graceful degradation, fallback mechanisms</span></li>
</ul>

<div class="part-toc-nav">

    <a href="#part-1-requirements-and-constraints" class="prev-part-link"><i class="fa fa-angle-double-up"></i> Part 1: Requirements and Constraints</a>


    <a href="#part-3-real-time-bidding-rtb-integration" class="next-part-link">Part 3: Real-Time Bidding (RTB) Integration <i class="fa fa-angle-double-down"></i></a>

</div>

</div>
<h3 id="system-components-and-request-flow">System Components and Request Flow</h3>
<pre class="mermaid">
    
    graph TB
    subgraph "Client Layer"
        CLIENT[Mobile/Web Client<br/>iOS, Android, Browser]
    end

    subgraph "Edge Layer"
        CDN[CDN<br/>CloudFront/Fastly<br/>Static assets]
        GLB[Global Load Balancer<br/>GeoDNS + Health Checks<br/>Route53]
    end

    subgraph "Regional Service Layer - Primary Region"
        GW[Envoy Gateway<br/>Rate Limiting: 1M QPS<br/>Auth: JWT/OAuth<br/>Istio Native]
        AS[Ad Server Orchestrator<br/>Stateless, Horizontally Scaled<br/>100ms latency budget]

        subgraph "Core Services"
            UP[User Profile Service<br/>Demographics, Interests<br/>Target: 10ms]
            AD_SEL[Ad Selection Service<br/>Candidate Retrieval<br/>Target: 15ms]
            ML[ML Inference Service<br/>CTR Prediction<br/>Target: 40ms]
            RTB[RTB Auction Service<br/>OpenRTB Protocol<br/>Target: 30ms]
            BUDGET[Budget Controller<br/>Pre-Allocation<br/>Strong Consistency]
        end

        subgraph "Data Layer"
            REDIS[(Redis Cluster<br/>Atomic Counters: DECRBY/INCRBY<br/>Budget Enforcement)]
            CRDB[(CockroachDB<br/>Billing Ledger + User Profiles<br/>HLC Timestamps<br/>Multi-Region ACID)]
            POSTGRES[(PostgreSQL<br/>Cold Archive<br/>7-year retention)]
            FEATURE[(Feature Store<br/>ML Features<br/>Sub-10ms p99)]
        end
    end

    subgraph "Data Processing Pipeline"
        KAFKA[Kafka<br/>Event Streaming<br/>100K events/sec]
        FLINK[Kafka Streams / Flink<br/>Stream Processing<br/>Real-time Aggregation]
        SPARK[Spark<br/>Batch Processing<br/>Feature Engineering]
        S3[(S3/HDFS<br/>Data Lake<br/>500TB+ daily)]
    end

    subgraph "ML Training Pipeline"
        AIRFLOW[Airflow<br/>Orchestration]
        TRAIN[Training Cluster<br/>Daily CTR Model<br/>Retraining]
        REGISTRY[Model Registry<br/>Versioning<br/>A/B Testing]
    end

    subgraph "Observability"
        PROM[Prometheus<br/>Metrics]
        JAEGER[Jaeger<br/>Distributed Tracing]
        GRAF[Grafana<br/>Dashboards]
    end

    CLIENT --> CDN
    CLIENT --> GLB
    GLB --> GW
    GW --> AS

    AS --> UP
    AS --> AD_SEL
    AS --> ML
    AS --> RTB
    AS --> BUDGET

    UP --> REDIS
    AD_SEL --> REDIS
    ML --> FEATURE
    RTB --> |OpenRTB 2.x| EXTERNAL[50+ DSP Partners]

    BUDGET --> |DECRBY/INCRBY| REDIS
    BUDGET --> |Audit Trail| POSTGRES

    UP --> CRDB
    AD_SEL --> CRDB

    AS --> KAFKA
    KAFKA --> FLINK
    FLINK --> REDIS
    FLINK --> S3
    SPARK --> S3
    SPARK --> FEATURE

    AIRFLOW --> TRAIN
    TRAIN --> REGISTRY
    REGISTRY --> ML

    AS -.-> PROM
    AS -.-> JAEGER
    PROM --> GRAF

    classDef client fill:#e1f5ff,stroke:#0066cc
    classDef edge fill:#fff4e1,stroke:#ff9900
    classDef service fill:#e8f5e9,stroke:#4caf50
    classDef data fill:#f3e5f5,stroke:#9c27b0
    classDef stream fill:#ffe0b2,stroke:#e65100

    class CLIENT client
    class CDN,GLB edge
    class GW,AS,UP,AD_SEL,ML,RTB,BUDGET service
    class REDIS,POSTGRES,CRDB,FEATURE,S3 data
    class KAFKA,FLINK,SPARK stream
</pre><h3 id="latency-budget-decomposition">Latency Budget Decomposition</h3>
<p>For a 100ms total latency budget, we decompose the request path:</p>
<p>$$T_{total} = T_{network} + T_{gateway} + T_{services} + T_{serialization}$$</p>
<p><strong>Network Overhead (Target: 10ms)</strong></p>
<ul>
<li>Client to edge: 5ms (CDN proximity)</li>
<li>Edge to service: 5ms (regional deployment)</li>
</ul>
<p><strong>API Gateway (Target: 5ms)</strong></p>
<ul>
<li>Authentication: 2ms</li>
<li>Rate limiting: 1ms</li>
<li>Request enrichment: 2ms</li>
</ul>
<p><strong>Technology Selection: API Gateway</strong></p>
<style>
#tbl_gtw + table th:first-of-type  { width: 10%; }
#tbl_gtw + table th:nth-of-type(2) { width: 10%; }
#tbl_gtw + table th:nth-of-type(3) { width: 15%; }
#tbl_gtw + table th:nth-of-type(4) { width: 15%; }
#tbl_gtw + table th:nth-of-type(5) { width: 15%; }
#tbl_gtw + table th:nth-of-type(6) { width: 15%; }
#tbl_gtw + table th:nth-of-type(7) { width: 15%; }
</style>
<div id="tbl_gtw"></div>
<table><thead><tr><th>Technology</th><th>Overhead</th><th>Throughput (RPS)</th><th>Rate Limiting</th><th>Auth Methods</th><th>Istio Integration</th><th>Ops Complexity</th></tr></thead><tbody>
<tr><td><strong>Envoy</br>Gateway</strong></td><td>2-4ms</td><td>150K</br>/node</td><td>Extension filters</td><td>JWT, OAuth2, External</td><td>Native</br>(same proxy)</td><td>Low</br>(unified)</td></tr>
<tr><td>Kong</td><td>3-5ms</td><td>100K</br>/node</td><td>Plugin-based</td><td>JWT, OAuth2, LDAP</td><td>External</br>(separate proxy)</td><td>Medium</br>(dual proxies)</td></tr>
<tr><td>AWS API</br>Gateway</td><td>5-10ms</td><td>10K</br>/endpoint</td><td>Built-in</td><td>IAM, Cognito, Lambda</td><td>No integration</td><td>Low</br>(managed)</td></tr>
<tr><td>NGINX Plus</td><td>1-3ms</td><td>200K</br>/node</td><td>Lua scripting</td><td>Custom modules</td><td>No integration</td><td>High</td></tr>
</tbody></table>
<p><strong>Decision: Envoy Gateway</strong></p>
<blockquote>
<p><strong>Architectural Driver: Latency</strong> - Envoy Gateway’s 2-4ms overhead fits within our 5ms gateway budget while unifying the proxy layer with our Istio service mesh, reducing operational complexity.</p>
</blockquote>
<p>Rationale:</p>
<ul>
<li><strong>Unified proxy technology:</strong> Same Envoy proxy for ingress + service mesh (Istio) - single control plane, unified observability</li>
<li><strong>Better latency:</strong> 2-4ms overhead vs Kong’s 3-5ms</li>
<li><strong>Higher throughput:</strong> 150K RPS/node vs Kong’s 100K RPS/node</li>
<li><strong>No dual-proxy complexity:</strong> Kong + Istio means two different proxies (NGINX/Lua + Envoy), different configs, different debugging tools</li>
<li><strong>Cost:</strong> Open-source (CNCF), no licensing vs Kong Enterprise</li>
<li><strong>Service mesh native:</strong> Istio Gateway API provides declarative routing with built-in mTLS</li>
</ul>
<p><strong>Kong consideration:</strong> More mature plugin ecosystem, but creates operational burden of running two proxy technologies (Kong for ingress, Envoy sidecars for service mesh). For auth + rate limiting + routing, Envoy Gateway’s extension model is sufficient.</p>
<p><strong>NGINX Plus consideration:</strong> Best-in-class latency (1-3ms), but no Istio integration and custom Lua development overhead.</p>
<p><strong>AWS API Gateway limitation:</strong> 5-10ms latency overhead plus per-request pricing at sustained high throughput makes it cost-prohibitive for this scale.</p>
<p><strong>Latency breakdown:</strong></p>
<ul>
<li>TLS termination: ~1ms</li>
<li>Authentication (JWT verify): ~2ms</li>
<li>Rate limiting (distributed filter): ~0.5ms</li>
<li>Request routing: ~0.5ms</li>
<li><strong>Total: 4ms</strong> - within budget, 1ms better than Kong</li>
</ul>
<h3 id="rate-limiting-volume-based-traffic-control">Rate Limiting: Volume-Based Traffic Control</h3>
<blockquote>
<p><strong>Architectural Driver: Availability + Financial Accuracy</strong> - Rate limiting protects infrastructure from overload, controls external API costs (DSP calls), and ensures fair resource allocation. This is <strong>volume-based control</strong> (you get N requests/second) complementing <strong>pattern-based fraud detection</strong> (your behavior looks suspicious) covered in Part 7.</p>
</blockquote>
<p><strong>What Rate Limiting Does (vs Fraud Detection):</strong></p>
<p>Rate limiting answers: “Are you requesting too much?”</p>
<ul>
<li>Legitimate advertiser making 10K QPS (vs 1K QPS limit) → throttled with 429</li>
<li>Protects infrastructure capacity and enforces SLA contracts</li>
</ul>
<p>Fraud detection answers: “Are you malicious?” (see Part 7: Fraud Detection)</p>
<ul>
<li>Bot farm clicking ads with suspicious patterns → permanently blocked</li>
<li>Protects advertiser budgets from wasted spend on fake traffic</li>
</ul>
<p><strong>Both work together</strong>: Rate limiting stops volume abuse, fraud detection stops sophisticated attacks.</p>
<p><strong>Why Rate Limiting is Critical:</strong></p>
<ol>
<li><strong>Infrastructure protection</strong>: Prevents single client from overwhelming 1.5M QPS capacity</li>
<li><strong>Cost control</strong>: Limits external DSP calls (50K QPS cap prevents runaway API costs)</li>
<li><strong>Fair allocation</strong>: Large advertisers (100K QPS tier) don’t starve small advertisers (1K QPS tier)</li>
<li><strong>SLA enforcement</strong>: API contracts specify request limits per advertiser tier</li>
</ol>
<p><strong>Multi-Tier Rate Limiting Architecture:</strong></p>
<table><thead><tr><th>Tier</th><th>Scope</th><th>Limit</th><th>Algorithm</th><th>Why This Tier</th></tr></thead><tbody>
<tr><td><strong>Global</strong></td><td>Entire platform</td><td>1.5M QPS</td><td>Token bucket</td><td>Protect infrastructure capacity</td></tr>
<tr><td><strong>Per-IP</strong></td><td>Client IP</td><td>10K QPS</td><td>Sliding window</td><td>Prevent single-source abuse</td></tr>
<tr><td><strong>Per-Advertiser</strong></td><td>API key</td><td>1K-100K QPS (tiered)</td><td>Token bucket with burst</td><td>SLA enforcement + fairness</td></tr>
<tr><td><strong>Per-Endpoint</strong></td><td><code>/bid</code>, <code>/report</code>, etc.</td><td>Varies</td><td>Leaky bucket</td><td>Prevent expensive ops abuse</td></tr>
<tr><td><strong>DSP outbound</strong></td><td>External calls</td><td>50K QPS total</td><td>Token bucket</td><td>Control external API costs</td></tr>
</tbody></table>
<p><strong>Distributed Rate Limiting Challenge:</strong></p>
<p>With 100+ gateway nodes, how do you enforce “1K QPS per advertiser” without centralizing every request?</p>
<p><strong>Naive approach (broken):</strong></p>
<ul>
<li>Each node allows 1K QPS locally → <strong>100 nodes × 1K = 100K QPS total</strong> (100× over budget!)</li>
</ul>
<p><strong>Correct approach (distributed counting with gossip):</strong></p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Per-node limit = Global Limit / N nodes
</span><span>With 20% headroom: Per-node = (1000 QPS / 100 nodes) × 1.2 = 12 QPS per node
</span></code></pre>
<p><strong>Problem</strong>: Uneven traffic distribution means some nodes hit limits while others idle.</p>
<p><strong>Solution: Redis-backed distributed token bucket</strong></p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Key: rate_limit:advertiser:{id}
</span><span>Algorithm:
</span><span>1. HINCRBY rate_limit:advertiser:123 tokens -1  (atomic)
</span><span>2. If result &lt; 0 → reject (429 Too Many Requests)
</span><span>3. Background refill: SET rate_limit:advertiser:123 1000 EX 1 (every second)
</span></code></pre>
<p><strong>Redis commands (atomic operations):</strong></p>
<pre data-lang="redis" style="background-color:#fafafa;color:#383a42;" class="language-redis "><code class="language-redis" data-lang="redis"><span>-- Token bucket refill (every second)
</span><span>EVAL &quot;redis.call(&#39;SET&#39;, KEYS[1], ARGV[1], &#39;EX&#39;, 1) return 1&quot; 1
</span><span>     rate_limit:adv:123 1000
</span><span>
</span><span>-- Consume token
</span><span>EVAL &quot;local tokens = redis.call(&#39;GET&#39;, KEYS[1]) or 0
</span><span>      if tonumber(tokens) &gt; 0 then
</span><span>        redis.call(&#39;DECR&#39;, KEYS[1])
</span><span>        return 1
</span><span>      else
</span><span>        return 0
</span><span>      end&quot; 1 rate_limit:adv:123
</span></code></pre>
<p><strong>Latency impact:</strong></p>
<ul>
<li>Redis local read: <strong>0.3ms</strong> (in-region)</li>
<li>Rate limit decision: <strong>0.5ms total</strong> (within our 1ms budget)</li>
</ul>
<p><strong>Optimization: Local cache with periodic sync</strong></p>
<p>To avoid Redis roundtrip on every request:</p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Algorithm (hybrid local + distributed):
</span><span>1. Each gateway node maintains local token bucket (1-second TTL)
</span><span>2. Allocate N tokens from Redis every second: GET_ALLOCATION(advertiser_id, 1000/100)
</span><span>3. Serve from local bucket (no Redis call, &lt;0.1ms)
</span><span>4. Refill local bucket every second from Redis allocation
</span></code></pre>
<p><strong>Trade-off:</strong></p>
<ul>
<li><strong>Advantage</strong>: 0.5ms → 0.1ms latency (5× faster), reduced Redis load (100× fewer calls)</li>
<li><strong>Disadvantage</strong>: Slightly looser enforcement (up to 2-second burst window if node crashes)</li>
<li><strong>Decision</strong>: Acceptable trade-off - 2s burst ≤0.2% of daily budget</li>
</ul>
<p><strong>Cost Impact of Rate Limiting:</strong></p>
<p><strong>Without rate limiting:</strong></p>
<ul>
<li>Malicious client sends 10M requests/day (vs normal 100K)</li>
<li>DSP calls: 10M wasted calls/month (~5% of infrastructure baseline cost)</li>
<li>Infrastructure: 100× normal load spikes require significant overprovisioning to handle</li>
</ul>
<p><strong>With rate limiting:</strong></p>
<ul>
<li>Redis cost: 20-node cluster (~4% of infrastructure baseline, already deployed for budget enforcement)</li>
<li>Gateway CPU overhead: 0.5ms × 1.5M QPS = <strong>0.75 vCPU overhead</strong> (negligible)</li>
<li><strong>Net savings: Avoids 20-30% infrastructure overprovisioning</strong> (depends on attack frequency and overprovision strategy)</li>
</ul>
<p><strong>Rate Limiting Response Headers (OpenAPI standard):</strong></p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>HTTP 429 Too Many Requests
</span><span>X-RateLimit-Limit: 1000
</span><span>X-RateLimit-Remaining: 0
</span><span>X-RateLimit-Reset: 1640000000
</span><span>Retry-After: 60
</span></code></pre>
<p><strong>Tiered Rate Limits by Advertiser Size:</strong></p>
<table><thead><tr><th>Tier</th><th>Monthly Spend</th><th>QPS Limit</th><th>Burst Allowance</th><th>Cost</th></tr></thead><tbody>
<tr><td><strong>Free</strong></td><td>$0</td><td>10 QPS</td><td>50 req/sec for 10s</td><td>$0</td></tr>
<tr><td><strong>Starter</strong></td><td>$1K-10K</td><td>100 QPS</td><td>500 req/sec for 10s</td><td>Included</td></tr>
<tr><td><strong>Growth</strong></td><td>$10K-100K</td><td>1K QPS</td><td>5K req/sec for 10s</td><td>Included</td></tr>
<tr><td><strong>Enterprise</strong></td><td>$100K+</td><td>10K-100K QPS</td><td>Custom burst</td><td>Negotiated</td></tr>
</tbody></table>
<p><strong>Burst handling via token bucket:</strong></p>
<p>$$\text{Bucket Size} = \text{Rate} \times \text{Burst Duration}$$</p>
<p><strong>Example</strong>: 1K QPS with 10s burst allowance = 10,000 token bucket</p>
<p>This allows clients to handle traffic spikes (e.g., Black Friday) without breaching limits during normal operation.</p>
<p><strong>Monitoring and Alerting:</strong></p>
<p>Track rate limit metrics:</p>
<ul>
<li><strong>Rejection rate</strong>: If &gt;5% → may need higher tier or optimization</li>
<li><strong>Top rejected advertisers</strong>: Alert if enterprise tier hitting limits (SLA breach)</li>
<li><strong>Cost</strong>: DSP call budget vs actual spend</li>
<li><strong>Attack detection</strong>: Sudden spike in rejections from single IP (DDoS)</li>
</ul>
<p><strong>Key Insight</strong>: Rate limiting is not just defensive - it’s a cost optimization mechanism. At scale, proper rate limiting can save 20-30% of infrastructure baseline by preventing abuse and avoiding worst-case overprovisioning.</p>
<p><strong>Service Layer (Target: 75ms)</strong></p>
<p>The Ad Server orchestrates calls to 4 services, but they cannot all run in parallel due to data dependencies:</p>
<p><strong>Sequential path (critical):</strong></p>
<ul>
<li>User Profile lookup: 10ms → provides user features (demographics, interests)</li>
<li>Ad Selection: 15ms → retrieves candidate ads (needs user interests for filtering)</li>
<li><strong>ML inference: 40ms</strong> → scores candidates (needs both user features AND ad features)</li>
</ul>
<p><strong>Parallel path:</strong></p>
<ul>
<li>RTB auction: 30ms → external DSPs bid (needs user context, runs while Ad Selection + ML execute)</li>
</ul>
<p>The critical path is <strong>User Profile (10ms) → Ad Selection (15ms) → ML Inference (40ms) = 65ms</strong>, not 40ms in isolation. RTB runs in parallel during the Ad Selection + ML phase.</p>
<p><strong>Complete Request Latency:</strong></p>
<ul>
<li>Network overhead + Gateway: 15ms</li>
<li>Critical service path: 65ms</li>
<li>Auction logic + Serialization: 10ms</li>
<li><strong>Total: 90ms</strong> (10ms variance buffer to stay under 100ms SLO)</li>
</ul>
<h3 id="critical-path-analysis">Critical Path Analysis</h3>
<p>The critical path through the system determines overall latency. ML Inference requires features from both User Profile and Ad Selection candidates, creating sequential dependencies:</p>
<pre class="mermaid">
    
    graph TB
    A[Request Arrives] -->|5ms| B[Gateway Auth]
    B --> C[User Profile<br/>10ms]

    C --> D[Ad Selection<br/>15ms]
    C --> F[RTB Auction<br/>30ms]

    D --> E[ML Inference<br/>40ms<br/>Needs: User + Ad Features]

    E --> G{Join Point}
    F --> G

    G -->|5ms| H[Auction Logic<br/>Combine Internal + RTB]
    H -->|5ms| I[Response]

    style E fill:#ffcccc
    style C fill:#ffe6e6
    style D fill:#ffe6e6
    style G fill:#ffffcc
</pre>
<p><strong>Critical Path (from diagram):</strong> Gateway (5ms) → User Profile (10ms) → Ad Selection (15ms) → ML Inference (40ms) → Join Point → Auction Logic (5ms) → Response (5ms) = <strong>80ms service layer</strong></p>
<p><strong>Parallel path:</strong> Gateway (5ms) → User Profile (10ms) → RTB Auction (30ms) → Join Point = <strong>45ms</strong></p>
<p><strong>Note:</strong> Diagram shows service layer only. Add 10ms network overhead at the start for <strong>90ms total request latency</strong> (10ms buffer to 100ms SLO).</p>
<p>The <strong>ML Inference Service</strong> (40ms) is still the single slowest component, but the true bottleneck is the <strong>sequential dependency chain</strong> (User Profile → Ad Selection → ML Inference = 65ms). Cannot parallelize because ML needs features from ad candidates.</p>
<h3 id="fault-tolerance-and-circuit-breaker-patterns">Fault Tolerance and Circuit Breaker Patterns</h3>
<blockquote>
<p><strong>Architectural Driver: Availability</strong> - Circuit breakers prevent cascading failures from killing the entire platform. If the ML service fails, we gracefully degrade rather than serving blank ads.</p>
</blockquote>
<p>To prevent cascading failures, implement <strong>circuit breakers</strong> for each downstream dependency. A circuit breaker monitors service health and automatically breaks the connection when failures exceed thresholds, preventing one failing service from bringing down the entire system.</p>
<p><strong>The three-state pattern:</strong></p>
<ul>
<li><strong>CLOSED</strong> (normal): All requests pass through. Monitor error rates and latency continuously.</li>
<li><strong>OPEN</strong> (failed): When failures exceed threshold, stop all requests. Return cached/fallback responses immediately. This prevents overwhelming a struggling service with additional load.</li>
<li><strong>HALF-OPEN</strong> (testing): After timeout period, send small test traffic (1-5% of requests). If tests succeed, transition back to CLOSED. If tests fail, return to OPEN with exponential backoff.</li>
</ul>
<p><strong>Example trigger</strong>: If error rate \(E(t) &gt; 10\%\) for 60 seconds, trip circuit to OPEN. After 30-second timeout, test recovery with 100 requests - if ≥90% succeed, restore to CLOSED.</p>
<p>This pattern applies to both error-based failures (service crashes, timeouts) and latency-based failures (service slow but functional). We’ll see the latency-specific implementation in the Degradation Strategy section below.</p>
<h3 id="degradation-strategy-when-services-breach-latency-budgets">Degradation Strategy: When Services Breach Latency Budgets</h3>
<p><strong>The Core Problem:</strong></p>
<p>You’ve allocated 40ms for ML inference, but what happens when GPU load spikes and p99 latency hits 80ms? Do you:</p>
<ul>
<li>Wait for the slow ML response and violate the 100ms total SLA (Service Level Agreement - the latency target we promised)? (Result: Mobile timeouts, blank ads, lost revenue)</li>
<li>Skip the request entirely? (Result: No ad served, 100% revenue loss on that request)</li>
<li><strong>Degrade gracefully with a fallback?</strong> (Result: Serve a less-optimal ad, ~10-20% revenue loss vs. perfect targeting)</li>
</ul>
<p>The answer is clear: <strong>graceful degradation</strong>. Better to serve a decent ad quickly than a perfect ad slowly (or no ad at all).</p>
<p><strong>Per-Service Degradation Hierarchy:</strong></p>
<p>Each critical-path service has a <strong>latency budget</strong> and a <strong>degradation ladder</strong> defining fallback behavior when budgets are exceeded. The table below shows all degradation levels across the three most critical services:</p>
<table><thead><tr><th>Level</th><th>ML Inference<br/>(40ms budget)</th><th>User Profile<br/>(10ms budget)</th><th>RTB Auction<br/>(30ms budget)</th></tr></thead><tbody>
<tr><td><strong>Level 0<br/>(Normal)</strong></td><td>GPU inference<br/>Latency: 30ms<br/>Revenue: 100%<br/><em>Trigger: p99 &lt; 40ms</em></td><td>CockroachDB + Redis<br/>Latency: 8ms<br/>Accuracy: 100%<br/><em>Trigger: p99 &lt; 10ms</em></td><td>Query all 50 DSPs<br/>Latency: 25ms<br/>Revenue: 100%<br/><em>Trigger: p95 &lt; 30ms</em></td></tr>
<tr><td><strong>Level 1<br/>(Light Degradation)</strong></td><td><strong>Cached predictions</strong><br/>Redis cached CTR<br/>Latency: 5ms<br/>Revenue: 92% (-8%)<br/><em>Trigger: p99 &gt; 40ms for 60s</em></td><td><strong>Stale cache</strong><br/>Extended TTL cache<br/>Latency: 2ms<br/>Accuracy: 95% (-5%)<br/><em>Trigger: p99 &gt; 10ms for 60s</em></td><td><strong>Top 20 DSPs only</strong><br/>Highest-value DSPs<br/>Latency: 18ms<br/>Revenue: 94% (-6%)<br/><em>Trigger: p95 &gt; 30ms for 60s</em></td></tr>
<tr><td><strong>Level 2<br/>(Moderate Degradation)</strong></td><td><strong>Heuristic model</strong><br/>Rule-based CTR<br/>Latency: 2ms<br/>Revenue: 85% (-15%)<br/><em>Trigger: Cache miss &gt; 30%</em></td><td><strong>Segment defaults</strong><br/>Demographic avg<br/>Latency: 1ms<br/>Accuracy: 70% (-30%)<br/><em>Trigger: DB unavailable</em></td><td><strong>Cached bids</strong><br/>Predicted bids<br/>Latency: 8ms<br/>Revenue: 88% (-12%)<br/><em>Trigger: p95 &gt; 25ms for 60s</em></td></tr>
<tr><td><strong>Level 3<br/>(Severe Degradation)</strong></td><td><strong>Global average</strong><br/>Category avg CTR<br/>Latency: 1ms<br/>Revenue: 75% (-25%)<br/><em>Trigger: Still breaching SLA</em></td><td>N/A</td><td><strong>Skip RTB entirely</strong><br/>Direct inventory only<br/>Latency: 0ms<br/>Revenue: 60% (-40%)<br/><em>Trigger: All DSPs timeout</em></td></tr>
</tbody></table>
<p><strong>Key observations:</strong></p>
<ul>
<li><strong>ML degradation is gradual</strong>: 4 levels allow fine-grained fallback (100% → 92% → 85% → 75%)</li>
<li><strong>User Profile degradation is binary</strong>: Either fresh data or stale/default (fewer intermediate states needed)</li>
<li><strong>RTB degradation is aggressive</strong>: Each level significantly reduces scope to meet latency budget</li>
<li><strong>Latency improvements are substantial</strong>: Level 1 degradations save 25-35ms, buying time for recovery</li>
</ul>
<p><strong>Mathematical Model of Degradation Impact:</strong></p>
<p>Total revenue under degradation:</p>
<p>$$R_{degraded} = R_{baseline} \times (1 - \alpha) \times (1 + \beta \times \Delta L)$$</p>
<p>where:</p>
<ul>
<li>\(\alpha\) = revenue loss from less accurate targeting (8% for Level 1, 15% for Level 2)</li>
<li>\(\beta\) = revenue gain from reduced latency (empirically ~0.0002 per ms saved, or 0.02% per ms)</li>
<li>\(\Delta L\) = latency improvement (e.g., 40ms → 5ms = 35ms saved)</li>
</ul>
<p><strong>Example:</strong> Level 1 degradation (cached predictions):</p>
<ul>
<li>Targeting accuracy loss: -8%</li>
<li>Latency improvement: 35ms × 0.0002/ms = +0.007 = +0.7% revenue gain (faster load = higher CTR)</li>
<li><strong>Net impact: -8% + 0.7% = -7.3% revenue</strong></li>
</ul>
<p>But compare to the alternative:</p>
<ul>
<li>Breaching 100ms SLA → 150ms total latency → mobile timeout → 100% revenue loss on timed-out requests</li>
</ul>
<p><strong>Circuit Breaker Implementation:</strong></p>
<p>Applying the circuit breaker pattern introduced earlier, we implement <strong>latency-based circuit breaking</strong> for each service. Instead of triggering on error rates, we trip the circuit when services exceed their latency budgets.</p>
<p><strong>State machine transitions:</strong></p>
<p><strong>CLOSED → OPEN</strong> (Trip when latency exceeds budget):</p>
<p>$$L_{p99}(t) &gt; L_{budget} + \delta \text{ for } \Delta t \geq 60s$$</p>
<p><strong>OPEN → HALF-OPEN</strong> (Test recovery after exponential backoff):</p>
<p>$$t - t_{trip} &gt; T_{backoff} \quad \text{where } T_{backoff} = 30s \times 2^{n}$$</p>
<p><strong>HALF-OPEN → CLOSED</strong> (Restore if tests succeed):</p>
<p>$$\frac{\text{successes}}{\text{attempts}} &gt; 0.90 \text{ over } N = 100 \text{ test requests}$$</p>
<p><strong>HALF-OPEN → OPEN</strong> (Abort recovery if tests fail):</p>
<p>$$\text{Any failure during test period} \rightarrow \text{return to OPEN, increment } n$$</p>
<p><strong>Where:</strong></p>
<ul>
<li>\(L_{p99}(t)\) = current p99 latency measured over 1-minute rolling window</li>
<li>\(L_{budget}\) = allocated latency budget per service</li>
<li>\(\delta\) = tolerance threshold (5ms grace period before tripping)</li>
<li>\(n\) = consecutive failure count (drives exponential backoff)</li>
<li>\(t_{trip}\) = timestamp when circuit last opened</li>
</ul>
<p><strong>Per-service circuit breaker thresholds:</strong></p>
<style>
#tbl_0 + table th:first-of-type  { width: 20%; }
#tbl_0 + table th:nth-of-type(2) { width: 15%; }
#tbl_0 + table th:nth-of-type(3) { width: 15%; }
#tbl_0 + table th:nth-of-type(4) { width: 35%; }
#tbl_0 + table th:nth-of-type(5) { width: 15%; }
</style>
<div id="tbl_0"></div>
<table><thead><tr><th>Service</th><th>Budget</th><th>Trip Threshold</th><th>Fallback</th><th>Revenue Impact</th></tr></thead><tbody>
<tr><td><strong>ML Inference</strong></td><td>40ms</td><td>p99 &gt; 45ms<br/>for 60s</td><td>Cached CTR predictions</td><td>-8%</td></tr>
<tr><td><strong>User Profile</strong></td><td>10ms</td><td>p99 &gt; 15ms<br/>for 60s</td><td>Stale cache (5min TTL)</td><td>-5%</td></tr>
<tr><td><strong>RTB Auction</strong></td><td>30ms</td><td>p95 &gt; 35ms<br/>for 60s</td><td>Top 20 DSPs only</td><td>-6%</td></tr>
<tr><td><strong>Ad Selection</strong></td><td>15ms</td><td>p99 &gt; 20ms<br/>for 60s</td><td>Skip personalization, use category matching</td><td>-12%</td></tr>
</tbody></table>
<p><strong>Composite Degradation Impact:</strong></p>
<p>If <strong>all services degrade simultaneously</strong> (worst case, e.g., during regional failover):</p>
<p>$$R_{total} = R_{baseline} \times (1 - 0.08) \times (1 - 0.05) \times (1 - 0.06) \times (1 - 0.12)$$
$$R_{total} \approx 0.92 \times 0.95 \times 0.94 \times 0.88 = 0.728 R_{baseline}$$</p>
<p><strong>Result:</strong> ~27% revenue loss under full degradation, but <strong>system stays online</strong>. Compare to outage scenario: 100% revenue loss.</p>
<p><strong>Recovery Strategy:</strong></p>
<p><strong>Hysteresis prevents flapping:</strong></p>
<p>$$
\begin{aligned}
\text{Degrade if: } &amp; L_{p99} &gt; L_{budget} + 5ms \text{ for } 60s \\
\text{Recover if: } &amp; L_{p99} &lt; L_{budget} - 5ms \text{ for } 300s
\end{aligned}
$$</p>
<p>Asymmetric thresholds (5ms tolerance vs 5ms buffer, 60s vs 300s duration) prevent oscillation between states. Example: GPU latency spike trips circuit at t=60s, switches to cached predictions; after 5min of healthy p99&lt;35ms latency, circuit closes and resumes GPU inference.</p>
<p><strong>Monitoring Degradation State:</strong></p>
<p>Track composite degradation score: \(\text{Score} = \sum_{i \in \text{services}} w_i \times \text{Level}_i\) where \(w_i\) reflects revenue impact (ML=0.4, RTB=0.3, Profile=0.2, AdSelection=0.1). Alert on: any service at Level 2+ for &gt;10min (P2), composite score &gt;4 (P1 - cascading failure risk), revenue &lt;85% forecast (P1), circuit flapping &gt;3 transitions/5min.</p>
<p><strong>Testing Degradation Strategy:</strong></p>
<p>Validate via chaos engineering: (1) Inject 50ms latency to 10% ML requests, verify circuit trips and -8% revenue impact matches prediction; (2) Terminate 50% GPU nodes, confirm graceful degradation within 60s; (3) Quarterly regional failover drills validating &lt;30% revenue loss and measuring recovery time.</p>
<p><strong>Trade-off Articulation:</strong></p>
<p><strong>Why degrade rather than scale?</strong></p>
<p>You might ask: “Why not just auto-scale GPU instances when latency spikes?”</p>
<p><strong>Problem:</strong> Provisioning new GPU instances takes <strong>90-120 seconds</strong> (instance boot + model loading into VRAM). During traffic spikes, you’ll breach SLAs for 90+ seconds before new capacity comes online.</p>
<p><strong>Note on 2025 optimizations:</strong> With modern tooling (NVIDIA Model Streamer, Alluxio caching, pre-warmed images), cold start can be reduced to <strong>30-40 seconds</strong>. However, this requires significant infrastructure investment. The 90-120s baseline represents standard deployments without specialized optimizations.</p>
<p><strong>Cost-benefit comparison:</strong></p>
<table><thead><tr><th>Strategy</th><th>Latency Impact</th><th>Revenue Impact</th><th>Cost</th></tr></thead><tbody>
<tr><td><strong>Wait for GPU</strong><br/>(no degradation)</td><td>150ms<br/>total → timeout</td><td>-100%<br/>on timed-out requests</td><td>$0</td></tr>
<tr><td><strong>Scale GPU instances</strong></td><td>90s of 80ms<br/>latency → partial timeouts</td><td>-40%<br/>during scale-up window</td><td>+30-50% GPU baseline for burst capacity</td></tr>
<tr><td><strong>Degrade to cached predictions</strong></td><td>5ms<br/>immediate</td><td>-8%<br/>targeting accuracy</td><td>$0</td></tr>
</tbody></table>
<p><strong>Decision:</strong> Degradation costs less (-8% vs -40%) and reacts faster (immediate vs 90s).</p>
<p><strong>But we still auto-scale!</strong> Degradation buys time for auto-scaling to provision capacity. Once new GPU instances are healthy (90s later), circuit closes and we return to normal operation.</p>
<p><strong>Degradation is a bridge, not a destination.</strong></p>
<hr />
<h2 id="part-3-real-time-bidding-rtb-integration">Part 3: Real-Time Bidding (RTB) Integration</h2>
<div class="part-toc">
<div class="part-toc-header">
<div class="part-toc-title">In this part:</div>
</div>
<ul>
<li><a href="#openrtb-protocol-deep-dive">OpenRTB Protocol Deep Dive</a>
<span class="part-toc-desc">Protocol specification, request/response format, bid construction</span></li>
<li><a href="#rtb-timeout-handling-and-partial-auctions">RTB Timeout Handling and Partial Auctions</a>
<span class="part-toc-desc">Timeout strategies, partial bid handling, latency tail management</span></li>
<li><a href="#connection-pooling-and-http-2-multiplexing">Connection Pooling and HTTP/2 Multiplexing</a>
<span class="part-toc-desc">Connection reuse, request multiplexing, performance optimization</span></li>
<li><a href="#geographic-distribution-and-edge-deployment">Geographic Distribution and Edge Deployment</a>
<span class="part-toc-desc">Regional presence, latency reduction, edge caching</span></li>
<li><a href="#the-30ms-rtb-timeout-challenge-why-it-s-impossible-to-meet-globally">The 30ms RTB Timeout Challenge</a>
<span class="part-toc-desc">Physics of latency, global constraints, architectural tradeoffs</span></li>
</ul>

<div class="part-toc-nav">

    <a href="#part-2-high-level-architecture" class="prev-part-link"><i class="fa fa-angle-double-up"></i> Part 2: High-Level Architecture</a>


    <a href="#part-4-ml-inference-pipeline" class="next-part-link">Part 4: ML Inference Pipeline <i class="fa fa-angle-double-down"></i></a>

</div>

</div>
<h3 id="openrtb-protocol-deep-dive">OpenRTB Protocol Deep Dive</h3>
<p>The OpenRTB 2.5 specification defines the standard protocol for programmatic advertising auctions. A typical RTB request-response cycle:</p>
<pre class="mermaid">
    
    sequenceDiagram
    participant AdServer as Ad Server
    participant DSP1 as DSP #1
    participant DSP2 as DSP #2-50
    participant Auction as Auction Logic

    Note over AdServer,Auction: 100ms Total Budget

    AdServer->>AdServer: Construct BidRequest<br/>OpenRTB 2.x format

    par Parallel DSP Calls (30ms timeout each)
        AdServer->>DSP1: HTTP POST /bid<br/>OpenRTB BidRequest
        activate DSP1
        DSP1-->>AdServer: BidResponse<br/>Price: $5.50
        deactivate DSP1
    and
        AdServer->>DSP2: Broadcast to 50 DSPs<br/>Parallel connections
        activate DSP2
        DSP2-->>AdServer: Multiple BidResponses<br/>[$3.20, $4.80, ...]
        deactivate DSP2
    end

    Note over AdServer: Timeout enforcement:<br/>Discard late responses

    AdServer->>Auction: Collected bids +<br/>ML CTR predictions
    Auction->>Auction: Run GSP Auction<br/>Compute winner
    Auction-->>AdServer: Winner + Price

    AdServer-->>DSP1: Win notification<br/>(async, best-effort)

    Note over AdServer,Auction: Total elapsed: ~35ms
</pre>
<p><strong>OpenRTB BidRequest Structure (Simplified):</strong></p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>{
</span><span>  &quot;id&quot;: &quot;req_12345&quot;,
</span><span>  &quot;imp&quot;: [{
</span><span>    &quot;id&quot;: &quot;1&quot;,
</span><span>    &quot;banner&quot;: {
</span><span>      &quot;w&quot;: 320,
</span><span>      &quot;h&quot;: 50
</span><span>    },
</span><span>    &quot;bidfloor&quot;: 2.50,
</span><span>    &quot;bidfloorcur&quot;: &quot;USD&quot;
</span><span>  }],
</span><span>  &quot;user&quot;: {
</span><span>    &quot;id&quot;: &quot;user_hashed_id&quot;,
</span><span>    &quot;geo&quot;: {
</span><span>      &quot;country&quot;: &quot;USA&quot;,
</span><span>      &quot;region&quot;: &quot;CA&quot;
</span><span>    }
</span><span>  },
</span><span>  &quot;device&quot;: {
</span><span>    &quot;ua&quot;: &quot;Mozilla/5.0...&quot;,
</span><span>    &quot;ip&quot;: &quot;192.0.2.1&quot;,
</span><span>    &quot;devicetype&quot;: 4
</span><span>  },
</span><span>  &quot;tmax&quot;: 30
</span><span>}
</span></code></pre>
<p><strong>Key Fields:</strong></p>
<ul>
<li><code>tmax</code>: Maximum time (ms) for DSP response (typically 30-50ms)</li>
<li><code>bidfloor</code>: Minimum acceptable bid price</li>
<li><code>imp</code>: Impression opportunities (can be multiple)</li>
</ul>
<p><strong>OpenRTB BidResponse Structure:</strong></p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>{
</span><span>  &quot;id&quot;: &quot;req_12345&quot;,
</span><span>  &quot;seatbid&quot;: [{
</span><span>    &quot;bid&quot;: [{
</span><span>      &quot;id&quot;: &quot;bid_1&quot;,
</span><span>      &quot;impid&quot;: &quot;1&quot;,
</span><span>      &quot;price&quot;: 5.50,
</span><span>      &quot;adm&quot;: &quot;&lt;ad markup&gt;&quot;,
</span><span>      &quot;crid&quot;: &quot;creative_123&quot;
</span><span>    }]
</span><span>  }],
</span><span>  &quot;cur&quot;: &quot;USD&quot;
</span><span>}
</span></code></pre>
<h3 id="rtb-timeout-handling-and-partial-auctions">RTB Timeout Handling and Partial Auctions</h3>
<p><strong>Problem:</strong> With 50 DSPs and 30ms timeout, some responses may arrive late. How do we handle partial auctions?</p>
<p><strong>Strategy 1: Hard Timeout</strong></p>
<ul>
<li>Discard all responses after 30ms</li>
<li>Run auction with collected bids only</li>
<li><strong>Trade-off:</strong> May miss highest bids, reduces revenue</li>
</ul>
<p><strong>Strategy 2: Adaptive Timeout</strong></p>
<p>Maintain per-DSP latency histograms \(H_{dsp}\). Set per-DSP timeout \(T_{dsp}\):</p>
<p>$$T_{dsp} = \text{min}\left(P_{95}(H_{dsp}), T_{global}\right)$$</p>
<p>where \(P_{95}(H_{dsp})\) is the 95th percentile latency for DSP, \(T_{global} = 30ms\).</p>
<p><strong>Strategy 3: Progressive Auction</strong></p>
<ul>
<li>Run preliminary auction at 20ms with available bids</li>
<li>Update with late arrivals up to 30ms if they beat current winner</li>
<li><strong>Advantage:</strong> Low latency for fast DSPs, opportunity for slow but high-value bids</li>
</ul>
<p><strong>Mathematical Model:</strong></p>
<p>Let \(B_i\) be the bid from DSP \(i\) with arrival time \(t_i\). The auction winner at time \(t\):</p>
<p>$$W(t) = \arg\max_{i: t_i \leq t} B_i \times \text{CTR}_i$$</p>
<p>Revenue optimization:
$$\mathbb{E}[\text{Revenue}] = \sum_{i=1}^{N} P(t_i \leq T) \times B_i \times \text{CTR}_i$$</p>
<p>This shows the expected revenue decreases as timeout \(T\) decreases (fewer DSPs respond).</p>
<h3 id="connection-pooling-and-http-2-multiplexing">Connection Pooling and HTTP/2 Multiplexing</h3>
<p>To minimize connection overhead for 50+ DSPs:</p>
<p><strong>HTTP/1.1 Connection Pooling:</strong></p>
<ul>
<li>Maintain persistent connections per DSP</li>
<li>Reuse connections across requests</li>
<li>Connection pool size: \(P = \frac{Q \times L}{N}\)
<ul>
<li>\(Q\) = QPS to DSP</li>
<li>\(L\) = Average latency (s)</li>
<li>\(N\) = Number of servers</li>
</ul>
</li>
</ul>
<p>Example: 1000 QPS, 30ms latency, 10 servers → <strong>3 connections per server</strong></p>
<p><strong>HTTP/2 Benefits:</strong></p>
<ul>
<li>Multiplexing: Single connection, multiple concurrent requests</li>
<li>Header compression: HPACK reduces overhead by ~70%</li>
<li>Server push: Pre-send creative assets (optional)</li>
</ul>
<p><strong>What about gRPC?</strong></p>
<p>gRPC (built on HTTP/2) would be excellent for internal service communication, but there’s a key constraint: <strong>OpenRTB is a standardized JSON/HTTP protocol</strong>. External DSPs expect HTTP REST endpoints with JSON payloads per the IAB spec.</p>
<p><strong>Trade-offs:</strong></p>
<ul>
<li><strong>External DSP communication</strong>: Must use HTTP/JSON (OpenRTB spec requirement)</li>
<li><strong>Internal services</strong> (ML inference, cache layer, auction engine): gRPC is a strong choice
<ul>
<li>Benefits: Protobuf serialization (~3x smaller than JSON), native streaming, strong typing</li>
<li>Latency: ~2-5ms faster than JSON REST for internal calls</li>
<li>Trade-off: Need to maintain .proto schemas, handle version compatibility</li>
</ul>
</li>
</ul>
<p><strong>Practical approach:</strong></p>
<ul>
<li>Use HTTP/JSON for DSP bidding (spec compliance)</li>
<li>Use gRPC for internal microservices (performance)</li>
<li>Bridge at the edge with a thin HTTP→gRPC adapter</li>
</ul>
<p><strong>Latency Improvement:</strong></p>
<p>Connection setup time \(T_{conn}\):</p>
<ul>
<li>HTTP/1.1: 50ms (TCP + TLS handshake per request)</li>
<li>HTTP/2 with pooling: 0ms (amortized)</li>
<li>gRPC (internal): 0ms amortized + faster serialization (~2-5ms savings)</li>
</ul>
<p><strong>Latency savings: ~50ms per cold start</strong> - critical for meeting 30ms RTB timeout.</p>
<h3 id="geographic-distribution-and-edge-deployment">Geographic Distribution and Edge Deployment</h3>
<p><strong>Latency Impact of Distance:</strong></p>
<p>Network latency is fundamentally bounded by the speed of light in fiber:</p>
<p>$$T_{propagation} \geq \frac{d}{c \times 0.67}$$</p>
<p>where \(d\) is distance, \(c\) is speed of light, 0.67 accounts for fiber optic refractive index.</p>
<p><strong>Example:</strong> New York to London (5,585 km):
$$T_{propagation} \geq \frac{5,585,000m}{3 \times 10^8 m/s \times 0.67} \approx 28ms$$</p>
<p><strong>Important:</strong> This 28ms is the <strong>theoretical minimum</strong> - the absolute best case if light could travel in a straight line through fiber with zero processing delays.</p>
<p><strong>Real-world latency is 2.5-3× higher due to:</strong></p>
<ul>
<li><strong>Router/switch processing</strong>: 15-20 network hops × 1-2ms per hop = 15-40ms</li>
<li><strong>Queuing delays</strong>: Network congestion, buffer waits = 5-15ms</li>
<li><strong>TCP/IP overhead</strong>: Connection establishment, windowing = 10-20ms</li>
<li><strong>Route inefficiency</strong>: Actual fiber paths aren’t straight lines (undersea cables, peering points) = +20-30% distance</li>
</ul>
<p><strong>Measured latency</strong> NY-London in practice: <strong>80-100ms round-trip</strong> (vs 28ms theoretical minimum).</p>
<p>This means the 30ms RTB budget is <strong>impossible even for regional connections</strong>, let alone global. Solution: deploy regionally to minimize distance.</p>
<p><strong>Optimal DSP Integration Points:</strong></p>
<p>Deploy RTB auction services in:</p>
<ol>
<li><strong>US East</strong> (Virginia): Proximity to major ad exchanges</li>
<li><strong>US West</strong> (California): West coast advertisers</li>
<li><strong>EU</strong> (Amsterdam/Frankfurt): GDPR-compliant EU auctions</li>
<li><strong>APAC</strong> (Singapore): Asia-Pacific market</li>
</ol>
<p><strong>Latency Reduction:</strong></p>
<p>With regional deployment, max distance reduced from 10,000km to ~1,000km:
$$T_{propagation} \approx \frac{1,000,000m}{3 \times 10^8 m/s \times 0.67} \approx 5ms$$</p>
<p>Again, this is theoretical minimum. <strong>Practical regional latency</strong> (within 1,000km): <strong>15-25ms round-trip</strong> including routing overhead.</p>
<p><strong>Savings:</strong> From 80-100ms (global) to 15-25ms (regional) = <strong>55-75ms reduction</strong>, enough to include 10+ additional regional DSPs within the 30ms RTB budget.</p>
<h3 id="the-30ms-rtb-timeout-challenge-why-it-s-impossible-to-meet-globally">The 30ms RTB Timeout Challenge: Why It’s Impossible to Meet Globally</h3>
<p><strong>Reality Check:</strong> For this architecture, we target an aggressive <strong>30ms timeout for DSP responses</strong> (tighter than typical industry timeouts of 100-250ms, but necessary for our 100ms total SLA). This sounds reasonable until you consider the physics of distributed systems across continents.</p>
<p><strong>Note:</strong> The IAB OpenRTB specification defines a <code>tmax</code> field (maximum time in milliseconds) but does not mandate a specific value - implementations vary widely (Google AdX uses 100ms, Magnite CTV uses 250ms). Our 30ms choice prioritizes mobile user experience over DSP participation breadth.</p>
<p><strong>The Fundamental Problem:</strong></p>
<p>Network latency is bounded by the speed of light. For global DSP communication (showing <strong>theoretical minimums</strong> - real-world latency is 2-3× higher):</p>
<style>
#tbl_1 + table th:first-of-type  { width: 25%; }
#tbl_1 + table th:nth-of-type(2) { width: 13%; }
#tbl_1 + table th:nth-of-type(3) { width: 13%; }
#tbl_1 + table th:nth-of-type(4) { width: 13%; }
#tbl_1 + table th:nth-of-type(5) { width: 15%; }
#tbl_1 + table th:nth-of-type(6) { width: 20%; }
</style>
<div id="tbl_1"></div>
<table><thead><tr><th>Route</th><th>Distance</th><th>Min Latency<br/>(one-way)</th><th>Round-trip<br/>(theoretical)</th><th>Practical Round-trip</th><th>Available time for DSP</th></tr></thead><tbody>
<tr><td><strong>US-East → US-West</strong></td><td>4,000 km</td><td>~13ms</td><td>~26ms</td><td>~60-80ms</td><td>-30 to -50ms<br/><strong>impossible!</strong></td></tr>
<tr><td><strong>US → Europe</strong></td><td>6,000 km</td><td>~20ms</td><td>~40ms</td><td>~100-120ms</td><td>-70 to -90ms<br/><strong>impossible!</strong></td></tr>
<tr><td><strong>US → Asia</strong></td><td>10,000 km</td><td>~33ms</td><td>~66ms</td><td>~150-200ms</td><td>-120 to -170ms<br/><strong>impossible!</strong></td></tr>
<tr><td><strong>Europe → Asia</strong></td><td>8,000 km</td><td>~27ms</td><td>~54ms</td><td>~120-150ms</td><td>-90 to -120ms<br/><strong>impossible!</strong></td></tr>
</tbody></table>
<p><strong>Mathematical reality:</strong></p>
<p>$$T_{RTB} = T_{\text{network to DSP}} + T_{\text{DSP processing}} + T_{\text{network from DSP}}$$</p>
<p>For a DSP in Singapore processing a request from New York (using <strong>practical</strong> latency measurements):</p>
<ul>
<li>Network to DSP: ~100ms (including routing, queuing, TCP overhead)</li>
<li>DSP processing: 10ms (auction logic, database lookup)</li>
<li>Network back: ~100ms</li>
<li><strong>Total: 210ms</strong> - more than <strong>7× the 30ms budget</strong></li>
</ul>
<p>Even the theoretical physics limit (66ms) exceeds the budget by 2×, but practical networking makes it far worse.</p>
<p><strong>Why we chose 30ms despite the challenges:</strong></p>
<p>Our 30ms timeout assumption works only for <strong>regional</strong> auctions where DSPs and SSPs are co-located within ~500km:</p>
<ul>
<li>Latency: ~5ms round-trip</li>
<li>DSP processing: 15ms</li>
<li>Response serialization: 5ms</li>
<li><strong>Total: 25ms</strong> - fits within budget with 5ms headroom</li>
</ul>
<p>But serving <strong>global</strong> traffic with a 30ms timeout is fundamentally incompatible with physics - which is why we architect regional sharding and selective DSP participation (solutions explored below).</p>
<p><strong>Why we can’t just increase the timeout:</strong></p>
<p>Remember our overall latency budget is 100ms for the entire ad request:</p>
<style>
#tbl_2 + table th:first-of-type  { width: 32%; }
#tbl_2 + table th:nth-of-type(2) { width: 12%; }
#tbl_2 + table th:nth-of-type(3) { width: 12%; }
#tbl_2 + table th:nth-of-type(4) { width: 12%; }
#tbl_2 + table th:nth-of-type(5) { width: 12%; }
</style>
<div id="tbl_2"></div>
<table><thead><tr><th>Component</th><th>Budget</th><th>% of Total</th><th>Cumulative</th><th>Critical Path</th></tr></thead><tbody>
<tr><td>Network overhead</td><td>10ms</td><td>10%</td><td>10ms</td><td>Yes</td></tr>
<tr><td>Gateway (Envoy)</td><td>5ms</td><td>5%</td><td>15ms</td><td>Yes</td></tr>
<tr><td><strong>Sequential Path (Critical):</strong></td><td></td><td></td><td></td><td></td></tr>
<tr><td>→ User profile</td><td>10ms</td><td>10%</td><td>25ms</td><td>Yes (needed by next)</td></tr>
<tr><td>→ Ad selection</td><td>15ms</td><td>15%</td><td>40ms</td><td>Yes (needed by ML)</td></tr>
<tr><td>→ <strong>ML inference</strong></td><td><strong>40ms</strong></td><td><strong>40%</strong></td><td><strong>80ms</strong></td><td><strong>Yes (needs ad candidates)</strong></td></tr>
<tr><td><strong>Parallel Path:</strong></td><td></td><td></td><td></td><td></td></tr>
<tr><td>→ RTB auction</td><td>30ms</td><td>30%</td><td>45ms</td><td>Runs parallel with Ad Selection + ML</td></tr>
<tr><td><strong>After join</strong></td><td>-</td><td>-</td><td><strong>80ms</strong></td><td>(limited by sequential path)</td></tr>
<tr><td>Auction logic</td><td>5ms</td><td>5%</td><td>85ms</td><td>Yes</td></tr>
<tr><td>Serialization</td><td>5ms</td><td>5%</td><td>90ms</td><td>Yes</td></tr>
<tr><td><strong>Buffer for variance</strong></td><td><strong>10ms</strong></td><td><strong>10%</strong></td><td><strong>100ms</strong></td><td>-</td></tr>
</tbody></table>
<p><strong>Key constraint:</strong> RTB auction gets 30ms budget and runs in parallel with Ad Selection + ML (which take 55ms combined). If we increased RTB timeout to 60ms, it would become the critical path (15 + 60 = 75ms from User Profile), pushing total latency to 100ms (10ms + 75ms + 10ms = 95ms) with no buffer for variance - violations inevitable.</p>
<p><strong>Critical insight:</strong> We can’t just “add more time” to RTB without it becoming the bottleneck - every service fights for milliseconds within a fixed 100ms envelope.</p>
<p><strong>Solution 1: Regional Sharding of DSPs</strong></p>
<p>Instead of broadcasting to all 50 global DSPs, <strong>partition DSPs by region</strong> and only query geographically-nearby partners:</p>
<pre class="mermaid">
    
    graph TB
    subgraph "User Request Flow"
        USER[User in New York]
    end

    subgraph "Regional DSP Sharding"
        ADV[Ad Server<br/>US-East-1]

        ADV -->|5ms RTT| US_DSPS[US DSP Pool<br/>25 partners<br/>Latency: 15ms avg]
        ADV -.->|40ms RTT| EU_DSPS[EU DSP Pool<br/>15 partners<br/>SKIPPED - too slow]
        ADV -.->|66ms RTT| ASIA_DSPS[Asia DSP Pool<br/>10 partners<br/>SKIPPED - too slow]

        US_DSPS -->|Response| ADV
    end

    subgraph "Smart DSP Selection"
        PROFILE[(DSP Performance Profile<br/>Cached in Redis)]

        PROFILE -->|Lookup| SELECTOR[DSP Selector Logic]
        SELECTOR --> DECISION{Distance vs<br/>Historical Bid Value}

        DECISION -->|High value,<br/>close proximity| INCLUDE[Include in auction]
        DECISION -->|Low value or<br/>distant| SKIP[Skip to meet latency]
    end

    USER --> ADV
    ADV --> PROFILE

    classDef active fill:#ccffcc,stroke:#00cc00,stroke-width:2px
    classDef inactive fill:#ffcccc,stroke:#cc0000,stroke-width:2px,stroke-dasharray: 5 5
    classDef logic fill:#e3f2fd,stroke:#1976d2,stroke-width:2px

    class US_DSPS,INCLUDE active
    class EU_DSPS,ASIA_DSPS,SKIP inactive
    class PROFILE,SELECTOR,DECISION logic
</pre>
<p><strong>Regional Sharding Strategy:</strong></p>
<p><strong>DSP Selection Algorithm:</strong></p>
<p>For each auction request, select DSPs based on multi-criteria optimization:</p>
<p><strong>DSP Selection Criteria</strong> (include if any condition is met):</p>
<ul>
<li>\(L_i &lt; 15\text{ms}\) — Always include (low latency)</li>
<li>\(L_i &lt; 25\text{ms} \land V_i &gt; V_{\text{threshold}}\) — Include if high-value</li>
<li>\(L_i &lt; 30\text{ms} \land P_i &gt; 0.80\) — Include if reliable</li>
</ul>
<p>where:</p>
<ul>
<li>\(L_i\) = estimated network latency (great circle distance ÷ speed of light × 0.67)</li>
<li>\(V_i\) = historical average bid value from DSP</li>
<li>\(P_i\) = participation rate (fraction of auctions where DSP responds)</li>
</ul>
<p><strong>Optimization objective:</strong></p>
<p>$$\max \sum_{i \in \text{Selected}} P_i \times V_i \quad \text{subject to } \max(L_i) \leq 30ms$$</p>
<p>Maximize expected revenue while respecting latency constraint.</p>
<p><strong>Impact of regional sharding:</strong></p>
<ul>
<li><strong>Before</strong>: Query 50 global DSPs, 20 timeout (40% response rate), avg latency 35ms</li>
<li><strong>After</strong>: Query 25 regional DSPs, 23 respond (92% response rate), avg latency 18ms</li>
</ul>
<p><strong>Revenue trade-off:</strong></p>
<ul>
<li>Lost access to 25 distant DSPs</li>
<li>But response rate improved 40% → 92%</li>
<li>Net effect: <strong>+15% effective bid volume</strong> (more bids received per auction)</li>
<li>Higher response rate → better price discovery → <strong>+8% revenue per impression</strong></li>
</ul>
<p><strong>Solution 2: Edge Bidding Caches</strong></p>
<p>For high-value DSPs that are geographically distant, <strong>cache recent bids at the edge</strong> and serve “predicted bids” when the DSP is too slow to respond. When a distant DSP (e.g., Asia-based) would exceed 30ms latency, the edge server queries a Redis cache for predicted bids based on similar historical contexts (user segment, time of day, ad category). A background GBDT model continuously updates predictions from historical bid logs. This allows including high-value distant DSPs without violating latency budgets.</p>
<p><strong>Bid Prediction Cache Architecture:</strong></p>
<p><strong>Cache key hierarchy</strong> (Redis):</p>
<p>$$\text{Key} = \langle \text{DSP}_id, \text{UserSegment}, \text{AdCategory}, \text{Hour} \rangle$$</p>
<p><strong>Lookup strategy with fallback cascade:</strong></p>
<ol>
<li><strong>Exact context match</strong>: \(O(1)\) lookup for specific (user_segment, ad_category, hour)</li>
<li><strong>Segment-level aggregation</strong>: If miss, lookup segment average (ignore hour/category)</li>
<li><strong>DSP global average</strong>: Fallback to historical mean bid for DSP</li>
</ol>
<p><strong>Prediction accuracy:</strong></p>
<p>$$\hat{b}_{dsp,context} = \mathbb{E}[\text{Bid} \mid \text{DSP}, \text{Context}]$$</p>
<p>Estimated from trailing 1-hour window of actual bids.</p>
<p><strong>Cache update policy:</strong></p>
<ul>
<li>TTL: 3600 seconds (1 hour)</li>
<li>Async update when DSP responds (even if late &gt;30ms)</li>
<li>Track prediction error: \(\epsilon = |\text{predicted} - \text{actual}|\)</li>
</ul>
<p><strong>When to use predicted bids:</strong></p>
<p>Not all DSPs should use predicted bids. Apply strategy selectively:</p>
<style>
#tbl_3 + table th:first-of-type  { width: 35%; }
#tbl_3 + table th:nth-of-type(2) { width: 25%; }
#tbl_3 + table th:nth-of-type(3) { width: 40%; }
</style>
<div id="tbl_3"></div>
<table><thead><tr><th>DSP Characteristics</th><th>Strategy</th><th>Reasoning</th></tr></thead><tbody>
<tr><td><strong>High-value, distant</strong><br>(avg bid &gt;$8, latency &gt;30ms)</td><td>Use predicted bid</td><td>Revenue loss from excluding them &gt; prediction error</td></tr>
<tr><td><strong>Low-value, distant</strong><br>(avg bid &lt;$3, latency &gt;30ms)</td><td>Skip entirely</td><td>Prediction error could make us lose money</td></tr>
<tr><td><strong>High-value, nearby</strong><br>(avg bid &gt;$8, latency &lt;20ms)</td><td>Always real-time</td><td>Best of both worlds</td></tr>
<tr><td><strong>Inconsistent bidders</strong><br>(bid rate &lt;30%)</td><td>Skip</td><td>Unreliable predictions</td></tr>
</tbody></table>
<p><strong>Mathematical justification:</strong></p>
<p>Expected revenue from high-value distant DSP:</p>
<p>$$E[\text{Revenue}] = P(\text{wins auction}) \times \text{Bid Value}$$</p>
<p><strong>With real-time bid</strong> (but 40% timeout rate):
$$E[\text{Revenue}] = 0.60 \times 0.15 \times \$8.00 = \$0.72$$</p>
<p><strong>With predicted bid</strong> (100% response rate, but ±15% prediction error):
$$E[\text{Revenue}] = 1.00 \times 0.13 \times \$7.50 = \$0.975$$</p>
<p>Predicted bids yield <strong>+35% revenue</strong> from this DSP despite prediction inaccuracy.</p>
<p><strong>Cache hit rate requirements:</strong></p>
<p>For predicted bids to work, cache hit rate must be high (&gt;80%). With Zipfian traffic distribution:</p>
<p>$$\text{Cache Size} = 0.2 \times \text{Total Contexts}$$</p>
<p>For 1M user segments × 50 ad categories × 24 hours = 1.2B possible contexts, cache 20% = <strong>240M entries</strong></p>
<p>At 50 bytes per entry (DSP ID + bid + metadata): <strong>12GB per edge location</strong></p>
<p><strong>Solution 3: Hybrid Approach (Recommended)</strong></p>
<p>The optimal strategy combines regional sharding with selective bid prediction: query nearby DSPs (&lt;15ms) in real-time (Tier 1), use predicted bids for high-value distant DSPs (Tier 2), and skip low-value or unreliable partners (Tier 3). This yields ~28 total bids per auction with 18ms average latency, 97% response rate, and +12% revenue versus naive global broadcast.</p>
<p><strong>Monitoring &amp; Validation:</strong></p>
<p>Monitor bid prediction error \(\mu(\epsilon) &lt; \$1.50\), DSP response rate \(P(\text{response} &lt; 30ms) &gt; 0.85\), revenue per auction (within 5% of baseline), and cache hit rate (&gt;80%). Automatically demote underperforming DSPs between tiers or disable predictions when thresholds are breached.</p>
<p><strong>Validation approach:</strong></p>
<p>$$\text{A/B Test: } \frac{Revenue_{regional}}{Revenue_{global}} &gt; 0.95$$</p>
<p>If regional sharding yields &lt;95% of global revenue, strategy fails economic viability test.</p>
<p><strong>Theoretical impact:</strong></p>
<p>Based on the physics constraints shown above, regional sharding should yield:</p>
<ul>
<li><strong>Latency reduction</strong>: From 5ms (regional) vs 28ms (transcontinental) — up to 5× improvement for distant DSPs</li>
<li><strong>Response rate</strong>: DSPs that previously timed out (&gt;30ms) can now respond within budget</li>
<li><strong>Revenue impact</strong>: More responsive DSPs → better price discovery (exact uplift depends on DSP mix)</li>
<li><strong>Timeout errors</strong>: Eliminated for DSPs within regional proximity (&lt;1000km)</li>
</ul>
<p><strong>Conclusion:</strong></p>
<p>The 30ms RTB timeout is a <strong>regional assumption</strong> that breaks at global scale. The solution isn’t to fight physics (you can’t make light travel faster), but to architect around it:</p>
<ol>
<li><strong>Regional sharding</strong>: Only query nearby DSPs</li>
<li><strong>Edge caching</strong>: Predict bids for high-value distant DSPs</li>
<li><strong>Selective participation</strong>: Skip low-value or unreliable DSPs</li>
</ol>
<blockquote>
<p><strong>Architectural Driver: Latency</strong> - Regional DSP sharding and edge caching are direct responses to the 30ms RTB budget constraint. Physics (speed of light) makes global auctions impossible within our 100ms total latency budget.</p>
</blockquote>
<p>This hybrid approach meets the 30ms budget <strong>without sacrificing revenue</strong> - and often improves it.</p>
<hr />
<h2 id="part-4-ml-inference-pipeline">Part 4: ML Inference Pipeline</h2>
<div class="part-toc">
<div class="part-toc-header">
<div class="part-toc-title">In this part:</div>
</div>
<ul>
<li><a href="#feature-engineering-architecture">Feature Engineering Architecture</a>
<span class="part-toc-desc">Feature pipeline design, real-time vs batch features, feature encoding</span></li>
<li><a href="#feature-vector-construction">Feature Vector Construction</a>
<span class="part-toc-desc">Embedding lookups, vector assembly, dimensionality considerations</span></li>
<li><a href="#model-architecture-gradient-boosted-trees-vs-neural-networks">Model Architecture: Gradient Boosted Trees vs. Neural Networks</a>
<span class="part-toc-desc">Model selection, latency tradeoffs, accuracy comparison</span></li>
<li><a href="#the-cold-start-problem-serving-ads-without-historical-data">The Cold Start Problem</a>
<span class="part-toc-desc">New advertiser handling, fallback strategies, bootstrapping approaches</span></li>
<li><a href="#model-serving-infrastructure">Model Serving Infrastructure</a>
<span class="part-toc-desc">Deployment architecture, version management, A/B testing</span></li>
<li><a href="#feature-store-tecton-architecture">Feature Store: Tecton Architecture</a>
<span class="part-toc-desc">Centralized feature management, consistency guarantees, online/offline serving</span></li>
</ul>

<div class="part-toc-nav">

    <a href="#part-3-real-time-bidding-rtb-integration" class="prev-part-link"><i class="fa fa-angle-double-up"></i> Part 3: Real-Time Bidding (RTB) Integration</a>


    <a href="#part-5-distributed-caching-architecture" class="next-part-link">Part 5: Distributed Caching Architecture <i class="fa fa-angle-double-down"></i></a>

</div>

</div>
<h3 id="feature-engineering-architecture">Feature Engineering Architecture</h3>
<p>Machine learning for CTR prediction requires real-time feature computation. Features fall into three categories:</p>
<ol>
<li><strong>Static features</strong> (pre-computed, stored in cache): User demographics, advertiser account info, historical campaign performance</li>
<li><strong>Real-time features</strong> (computed on request): Time of day, device type, current location, session context</li>
<li><strong>Aggregated features</strong> (streaming aggregations): User’s last 7-day engagement rate, advertiser’s hourly budget pace, category-level CTR trends</li>
</ol>
<p>The challenge is computing these features within our latency budget while maintaining consistency.</p>
<p><strong>Technology Selection: Event Streaming Platform</strong></p>
<p>Alright, before I even think about stream processing frameworks, I need to pick the event streaming backbone. This is one of those decisions where I went down a rabbit hole for days. Here’s what I looked at:</p>
<style>
#tbl_4 + table th:first-of-type  { width: 13%; }
#tbl_4 + table th:nth-of-type(2) { width: 15%; }
#tbl_4 + table th:nth-of-type(3) { width: 13%; }
#tbl_4 + table th:nth-of-type(4) { width: 17%; }
#tbl_4 + table th:nth-of-type(5) { width: 17%; }
#tbl_4 + table th:nth-of-type(6) { width: 25%; }
</style>
<div id="tbl_4"></div>
<table><thead><tr><th>Technology</th><th>Throughput/Partition</th><th>Latency (p99)</th><th>Durability</th><th>Ordering</th><th>Scalability</th></tr></thead><tbody>
<tr><td><strong>Kafka</strong></td><td>100MB/sec</td><td>5-15ms</td><td>Disk-based replication</td><td>Per-partition</td><td>Horizontal (add brokers/partitions)</td></tr>
<tr><td>Pulsar</td><td>80MB/sec</td><td>10-20ms</td><td>BookKeeper (distributed log)</td><td>Per-partition</td><td>Horizontal (separate compute/storage)</td></tr>
<tr><td>RabbitMQ</td><td>20MB/sec</td><td>5-10ms</td><td>Optional persistence</td><td>Per-queue</td><td>Vertical (limited)</td></tr>
<tr><td>AWS Kinesis</td><td>1MB/sec/shard</td><td>200-500ms</td><td>S3-backed</td><td>Per-shard</td><td>Manual shard management</td></tr>
</tbody></table>
<p><strong>Decision: Kafka</strong></p>
<p>Rationale:</p>
<ul>
<li><strong>Throughput:</strong> 100MB/sec per partition meets peak load (100K events/sec × 1KB/event)</li>
<li><strong>Latency:</strong> 5-15ms p99 fits within 100ms feature freshness budget</li>
<li><strong>Durability:</strong> Disk-based replication (RF=3) ensures data persistence across broker failures</li>
<li><strong>Ecosystem maturity:</strong> Kafka Connect, Flink, and Spark integrations well-established</li>
<li><strong>Ordering guarantees:</strong> Per-partition ordering preserves event causality (impressions before clicks)</li>
</ul>
<p>While Pulsar offers elegant storage/compute separation, Kafka’s ecosystem maturity and operational tooling provide better production support for this scale.</p>
<p><strong>Partitioning strategy:</strong></p>
<p>For 100K events/sec across 100 partitions, we get <strong>1,000 events/sec per partition</strong>.</p>
<p>Partition key: <code>user_id % 100</code> ensures:</p>
<ul>
<li>All events for a user go to same partition (maintains ordering)</li>
<li>Balanced distribution (assuming uniform user distribution)</li>
</ul>
<p><strong>Cost comparison:</strong> Self-hosted Kafka (~1-2% of infrastructure baseline at scale) is significantly cheaper than AWS Kinesis at high sustained throughput (20-50× cost difference at billions of events/month). Managed services trade cost for operational simplicity.</p>
<p><strong>Note:</strong> Kafka’s cost advantage scales with throughput volume - at lower volumes, managed streaming services may be more cost-effective when factoring in operational overhead.</p>
<p><strong>Technology Selection: Stream Processing</strong></p>
<p><strong>Stream Processing Frameworks:</strong></p>
<table><thead><tr><th>Technology</th><th>Latency</th><th>Throughput</th><th>State Management</th><th>Exactly-Once</th><th>Deployment Model</th><th>Ops Complexity</th></tr></thead><tbody>
<tr><td><strong>Kafka Streams</strong></td><td>&lt;50ms</td><td>800K events/sec</td><td>Local RocksDB</td><td>Yes (transactions)</td><td>Library (embedded)</td><td><strong>Low</strong></td></tr>
<tr><td>Flink</td><td>&lt;100ms</td><td>1M events/sec</td><td>Distributed snapshots</td><td>Yes (Chandy-Lamport)</td><td>Separate cluster</td><td>Medium</td></tr>
<tr><td>Spark Streaming</td><td>~500ms</td><td>500K events/sec</td><td>Micro-batching</td><td>Yes (WAL)</td><td>Separate cluster</td><td>Medium</td></tr>
<tr><td>Storm</td><td>&lt;10ms</td><td>300K events/sec</td><td>Manual</td><td>No (at-least-once)</td><td>Separate cluster</td><td>High</td></tr>
</tbody></table>
<p><strong>Decision: Kafka Streams</strong> (for simple aggregations) + <strong>Flink</strong> (for complex CEP)</p>
<p><strong>Initial recommendation: Kafka Streams for most use cases</strong></p>
<p>For this architecture’s primary use case - windowed aggregations for feature engineering - <strong>Kafka Streams is simpler</strong>:</p>
<ul>
<li><strong>No separate cluster:</strong> Kafka Streams runs as library in your application - just scale app instances</li>
<li><strong>Better latency:</strong> &lt;50ms vs Flink’s &lt;100ms</li>
<li><strong>Simpler ops:</strong> No JobManager, TaskManager, savepoint management</li>
<li><strong>Native Kafka integration:</strong> Uses consumer groups directly, no external connector needed</li>
<li><strong>Sufficient for:</strong>
<ul>
<li>Windowed aggregations (user CTR last 1 hour)</li>
<li>Joins (clicks ⋈ impressions)</li>
<li>Stateful transformations</li>
</ul>
</li>
</ul>
<p><strong>When to use Flink instead:</strong></p>
<ul>
<li><strong>Complex Event Processing (CEP)</strong>: Pattern matching across event sequences (e.g., detect fraud patterns)</li>
<li><strong>Multi-source joins</strong>: Joining streams from Kafka + database CDC + REST APIs</li>
<li><strong>SQL interface</strong>: Need Flink SQL for analyst-written streaming queries</li>
<li><strong>Large state (&gt;10GB per partition)</strong>: Flink’s distributed state management scales better</li>
</ul>
<p><strong>Mathematical justification:</strong></p>
<p>For windowed aggregation with window size \(W\) and event rate \(\lambda\):</p>
<p>$$state\_size = \lambda \times W \times event\_size$$</p>
<p>Example: 100K events/sec, 60s window, 1KB/event → <strong>~6GB state per operator</strong>.</p>
<p><strong>Kafka Streams</strong>: 6GB state stored locally in RocksDB per instance. With 10 app instances partitioning load, that’s 600MB per instance - easily manageable.</p>
<p><strong>Trade-off accepted:</strong> Start with Kafka Streams for operational simplicity. Migrate specific pipelines to Flink if/when complex CEP patterns needed (e.g., sophisticated fraud detection requiring temporal pattern matching).</p>
<p><strong>Batch Processing Framework:</strong></p>
<table><thead><tr><th>Technology</th><th>Processing Speed</th><th>Fault Tolerance</th><th>Memory Usage</th><th>Ecosystem</th></tr></thead><tbody>
<tr><td><strong>Spark</strong></td><td>Fast (in-memory)</td><td>Lineage-based</td><td>High (RAM-heavy)</td><td>Rich (MLlib, SQL)</td></tr>
<tr><td>MapReduce</td><td>Slow (disk I/O)</td><td>Task restart</td><td>Low</td><td>Legacy</td></tr>
<tr><td>Dask</td><td>Fast (lazy eval)</td><td>Task graph</td><td>Medium</td><td>Python-native</td></tr>
</tbody></table>
<p><strong>Decision: Spark</strong></p>
<ul>
<li><strong>Daily batch jobs:</strong> Not latency-sensitive (hours acceptable)</li>
<li><strong>Feature engineering:</strong> MLlib for statistical aggregations</li>
<li><strong>SQL interface:</strong> Data scientists can write feature queries</li>
<li><strong>Cost efficiency:</strong> In-memory caching for iterative computations</li>
</ul>
<p><strong>Feature Store Technology:</strong></p>
<table><thead><tr><th>Technology</th><th>Serving Latency</th><th>Feature Freshness</th><th>Online/Offline</th><th>Vendor</th></tr></thead><tbody>
<tr><td><strong>Tecton</strong></td><td>&lt;10ms (p99)</td><td>100ms</td><td>Both</td><td>SaaS</td></tr>
<tr><td>Feast</td><td>~15ms</td><td>~1s</td><td>Both</td><td>Open-source</td></tr>
<tr><td>Hopsworks</td><td>~20ms</td><td>~5s</td><td>Both</td><td>Open-source</td></tr>
<tr><td>Custom (Redis)</td><td>~5ms</td><td>Manual</td><td>Online only</td><td>Self-built</td></tr>
</tbody></table>
<p><strong>Decision: Tecton</strong> (with fallback to custom Redis)</p>
<ul>
<li><strong>Managed service:</strong> Reduces operational burden</li>
<li><strong>Sub-10ms SLA:</strong> Meets latency budget</li>
<li><strong>100ms freshness:</strong> Stream feature updates via Flink</li>
<li><strong>Trade-off:</strong> Vendor lock-in vs. engineering time saved</li>
</ul>
<p><strong>Cost analysis:</strong></p>
<p>Custom solution:</p>
<ul>
<li>2 Senior engineers × 6 months (1 FTE-year)</li>
<li>Engineering cost: 1 FTE-year fully-loaded (salary + benefits + overhead)</li>
<li>Infrastructure: ~2% of infrastructure baseline/year</li>
<li><strong>Total first year: 1 FTE-year + 2% infrastructure baseline</strong>, then 2% infrastructure baseline ongoing</li>
</ul>
<p>Managed feature store (Tecton/Databricks): SaaS fee ≈ 10-15% of one engineer FTE/year</p>
<p><strong>Decision</strong>: Managed feature store is <strong>5-8× cheaper</strong> in year one (avoids engineering cost), plus faster time-to-market (weeks vs months). Custom solution only makes sense at massive scale or with unique requirements managed solutions can’t support.</p>
<p><strong>1. Real-Time Features (computed per request):</strong></p>
<ul>
<li>User context: time of day, location, device type</li>
<li>Session features: current browsing session, last N actions</li>
<li>Cross features: user × ad interactions</li>
</ul>
<p><strong>2. Near-Real-Time Features (pre-computed, cache TTL ~10s):</strong></p>
<ul>
<li>User interests: aggregated from last 24h activity</li>
<li>Ad performance: click rates, conversion rates (last hour)</li>
</ul>
<p><strong>3. Batch Features (pre-computed daily):</strong></p>
<ul>
<li>User segments: demographic clusters, interest graphs</li>
<li>Long-term CTR: 30-day aggregated performance</li>
</ul>
<pre class="mermaid">
    
    graph TB
    subgraph "Real-Time Feature Pipeline"
        REQ[Ad Request] --> PARSE[Request Parser]
        PARSE --> CONTEXT[Context Features<br/>time, location, device<br/>Latency: 5ms]
        PARSE --> SESSION[Session Features<br/>user actions<br/>Latency: 10ms]
    end

    subgraph "Feature Store"
        CONTEXT --> MERGE[Feature Vector Assembly]
        SESSION --> MERGE

        REDIS_RT[(Redis<br/>Near-RT Features<br/>TTL: 10s)] --> MERGE
        REDIS_BATCH[(Redis<br/>Batch Features<br/>TTL: 24h)] --> MERGE
    end

    subgraph "Stream Processing"
        EVENTS[User Events<br/>clicks, views] --> KAFKA[Kafka]
        KAFKA --> FLINK[Kafka Streams<br/>Windowed Aggregation]
        FLINK --> REDIS_RT
    end

    subgraph "Batch Processing"
        S3[S3 Data Lake] --> SPARK[Spark Jobs<br/>Daily]
        SPARK --> FEATURE_GEN[Feature Generation]
        FEATURE_GEN --> REDIS_BATCH
    end

    MERGE --> INFERENCE[ML Inference<br/>TensorFlow Serving<br/>Latency: 40ms]
    INFERENCE --> PREDICTION[CTR Prediction<br/>0.0 - 1.0]

    classDef rt fill:#ffe0e0,stroke:#cc0000
    classDef batch fill:#e0e0ff,stroke:#0000cc
    classDef store fill:#e0ffe0,stroke:#00cc00

    class REQ,PARSE,CONTEXT,SESSION rt
    class S3,SPARK,FEATURE_GEN,REDIS_BATCH batch
    class REDIS_RT,MERGE,INFERENCE store
</pre><h3 id="feature-vector-construction">Feature Vector Construction</h3>
<p>For each ad impression, construct feature vector \(\mathbf{x} \in \mathbb{R}^n\):</p>
<p>$$x = [x_{user}, x_{ad}, x_{context}, x_{cross}]$$</p>
<p><strong>User Features</strong> \(\mathbf{x}_{user} \in \mathbb{R}^{50}\):</p>
<ul>
<li>Demographics: age, gender, location (one-hot encoded)</li>
<li>Interests: [gaming: 0.8, fashion: 0.6, sports: 0.3, …]</li>
<li>Historical CTR: average click rate on similar ads</li>
</ul>
<p><strong>Ad Features</strong> \(\mathbf{x}_{ad} \in \mathbb{R}^{30}\):</p>
<ul>
<li>Creative type: video, image, carousel (categorical)</li>
<li>Advertiser category: e-commerce, gaming, finance</li>
<li>Global CTR: performance across all users</li>
<li>Quality score: user feedback, policy compliance</li>
</ul>
<p><strong>Context Features</strong> \(\mathbf{x}_{context} \in \mathbb{R}^{20}\):</p>
<ul>
<li>Time: hour of day, day of week, is_weekend</li>
<li>Device: iOS/Android, screen size, connection type</li>
<li>Placement: story ad, feed ad, search ad</li>
</ul>
<p><strong>Cross Features</strong> \(\mathbf{x}_{cross} \in \mathbb{R}^{50}\):</p>
<ul>
<li>User-Ad interactions: has user clicked advertiser before?</li>
<li>Interest-Category alignment: user.interests · ad.category</li>
<li>Time-based: user active time × ad posting time</li>
</ul>
<p><strong>Total dimensionality:</strong> <strong>150 features</strong>.</p>
<h3 id="model-architecture-gradient-boosted-trees-vs-neural-networks">Model Architecture: Gradient Boosted Trees vs. Neural Networks</h3>
<p><strong>Technology Selection: ML Model Architecture</strong></p>
<p><strong>Comparative Analysis:</strong></p>
<table><thead><tr><th>Criterion</th><th>GBDT (LightGBM/XGBoost)</th><th>Deep Neural Network</th><th>Factorization Machines</th></tr></thead><tbody>
<tr><td><strong>Inference Latency</strong></td><td>5-10ms (CPU)</td><td>20-40ms (GPU required)</td><td>3-5ms (CPU)</td></tr>
<tr><td><strong>Training Time</strong></td><td>1-2 hours (daily)</td><td>6-12 hours (daily)</td><td>30min-1hour</td></tr>
<tr><td><strong>Data Efficiency</strong></td><td>Good (100K+ samples)</td><td>Requires 10M+ samples</td><td>Good (100K+ samples)</td></tr>
<tr><td><strong>Feature Engineering</strong></td><td>Manual required</td><td>Automatic interactions</td><td>Automatic 2nd-order</td></tr>
<tr><td><strong>Interpretability</strong></td><td>High (feature importance)</td><td>Low (black box)</td><td>Medium (learned weights)</td></tr>
<tr><td><strong>Memory Footprint</strong></td><td>100-500MB</td><td>1-5GB</td><td>50-200MB</td></tr>
<tr><td><strong>Categorical Features</strong></td><td>Native support</td><td>Embedding layers needed</td><td>Native support</td></tr>
</tbody></table>
<p><strong>Latency Budget Analysis:</strong></p>
<p>Recall: ML inference budget = 40ms (out of 100ms total)</p>
<p>$$T_{ml} = T_{feature} + T_{inference} + T_{overhead}$$</p>
<ul>
<li><strong>GBDT:</strong> \(T_{ml} = 10ms + 8ms + 2ms = 20ms\) ✓ Within budget</li>
<li><strong>DNN:</strong> \(T_{ml} = 10ms + 30ms + 5ms = 45ms\) ✗ Exceeds budget (requires GPU)</li>
<li><strong>FM:</strong> \(T_{ml} = 10ms + 4ms + 1ms = 15ms\) ✓ Best performance</li>
</ul>
<p><strong>Accuracy Comparison:</strong></p>
<p>CTR prediction is fundamentally constrained by signal sparsity - user click rates are typically 0.1-2% in ads, creating severe class imbalance. Model performance expectations:</p>
<ul>
<li><strong>GBDT</strong>: Target AUC 0.78-0.82 - Strong baseline for CTR tasks due to handling of feature interactions via tree splits. Performance ceiling exists because trees can’t learn arbitrary feature combinations beyond depth limit.</li>
<li><strong>DNN</strong>: Target AUC 0.80-0.84 - Higher theoretical ceiling from learned embeddings and non-linear interactions, but requires significantly more training data (millions of samples) and risks overfitting with sparse signals.</li>
<li><strong>FM</strong>: Target AUC 0.75-0.78 - Lower ceiling due to limitation to pairwise feature interactions, but more data-efficient and stable with limited training samples.</li>
</ul>
<p>AUC improvements translate directly to revenue: at 100M daily impressions with $2 CPM, a 1% AUC improvement (~0.5-1% CTR lift) = <strong>$60K monthly revenue gain</strong> (3B monthly impressions × $2 CPM × 1% = $60K).</p>
<p><strong>Decision Matrix (Infrastructure Costs Only):</strong></p>
<p>$$Value_{infra} = \alpha \times Accuracy - \beta \times Latency - \gamma_{infra} \times OpsCost$$</p>
<p>With \(\alpha = 100\) (revenue impact), \(\beta = 50\) (user experience), \(\gamma_{infra} = 10\) (infrastructure only):</p>
<ul>
<li><strong>GBDT:</strong> \(100 \times 0.80 - 50 \times 0.020 - 10 \times 5 = 29\)</li>
<li><strong>DNN:</strong> \(100 \times 0.82 - 50 \times 0.045 - 10 \times 20 = -120.25\) (GPU cost makes this unviable)</li>
<li><strong>FM:</strong> \(100 \times 0.76 - 50 \times 0.015 - 10 \times 3 = 45.25\) ← <strong>highest value</strong></li>
</ul>
<p><strong>If infrastructure cost were the only factor</strong>, FM would win. However, this matrix <strong>omits operational complexity</strong>.</p>
<p><strong>Production Decision: GBDT</strong></p>
<p>Adding operational complexity weight (\(\gamma_{ops}\)):</p>
<p>$$Value_{total} = \alpha \times Accuracy - \beta \times Latency - \gamma_{infra} \times InfraCost - \gamma_{ops} \times OpsBurden$$</p>
<p><strong>Operational factors favoring GBDT:</strong></p>
<ol>
<li><strong>Ecosystem maturity:</strong> LightGBM/XGBoost have 10× more production deployments than FM libraries - easier hiring, more Stack Overflow answers, better tooling</li>
<li><strong>Feature importance:</strong> SHAP values critical for debugging why CTR dropped 5% (was it ad creative quality? user segment shift? seasonal effect?) - FM provides limited interpretability</li>
<li><strong>Incremental learning:</strong> GBDT supports online learning with new data batches - FM requires full retraining</li>
<li><strong>Production risk:</strong> Deploying less-common FM technology (\(\gamma_{ops} \approx 40\)) outweighs 16-point mathematical advantage</li>
</ol>
<p>With \(\gamma_{ops} = 40\):</p>
<ul>
<li><strong>GBDT:</strong> \(29 - 40 \times 0.2 = 21\) (low ops burden)</li>
<li><strong>FM:</strong> \(45.25 - 40 \times 0.8 = 13.25\) (high ops burden from uncommon tech)</li>
</ul>
<p><strong>Trade-off:</strong> Accept 5ms extra latency and 2-3% AUC gap for operational simplicity and team velocity.</p>
<blockquote>
<p><strong>Architectural Driver: Latency</strong> - GBDT’s 20ms total inference time (including feature lookup) fits within our 40ms ML budget. We rejected DNNs despite their 2-3% accuracy advantage because their 45ms latency would violate our 100ms total budget.</p>
</blockquote>
<p><strong>Trade-off accepted:</strong> 5ms extra latency (GBDT vs FM) for operational benefits.</p>
<p><strong>Option 1: Gradient Boosted Decision Trees (GBDT)</strong></p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Fast inference: 5-10ms for 100 trees</li>
<li>Handles categorical features naturally</li>
<li>Interpretable feature importance</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Fixed feature interactions (up to tree depth)</li>
<li>Requires manual feature engineering</li>
<li>Model size grows with data complexity</li>
</ul>
<p><strong>Typical hyperparameters:</strong> 100 trees, depth 7, learning rate 0.05, with feature/data sampling for regularization. Inference latency scales linearly with tree count (~8ms for 100 trees).</p>
<p><strong>Option 2: Deep Neural Network (DNN)</strong></p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Learns feature interactions automatically</li>
<li>Scales with data (more data → better performance)</li>
<li>Supports embedding layers for high-cardinality categoricals</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Slower inference: 20-40ms depending on model size</li>
<li>Requires more training data (millions of samples)</li>
<li>Less interpretable</li>
</ul>
<p><strong>Typical architecture:</strong> Embedding layers for categoricals, followed by 3 dense layers (256→128→64 units with ReLU, 0.3 dropout), sigmoid output. Trained via binary cross-entropy with Adam optimizer. Inference latency ~20-40ms depending on batch size and hardware (GPU vs CPU).</p>
<h3 id="the-cold-start-problem-serving-ads-without-historical-data">The Cold Start Problem: Serving Ads Without Historical Data</h3>
<p><strong>The Challenge:</strong></p>
<p>Your CTR prediction models depend on historical user behavior, advertiser performance, and engagement patterns. But what happens when:</p>
<ul>
<li><strong>New user</strong> signs up - zero click history</li>
<li><strong>New advertiser</strong> launches first campaign - no performance data</li>
<li><strong>Platform launch</strong> (day 1) - entire system has no historical data</li>
</ul>
<p>Serving random ads would devastate revenue and user experience. You need a <strong>multi-tier fallback strategy</strong> that gracefully degrades from personalized to increasingly generic predictions.</p>
<p><strong>Multi-Tier Cold Start Strategy:</strong></p>
<p>The key architectural principle: <strong>graceful degradation from personalized to generic predictions</strong> as data availability decreases. Each tier represents a fallback when insufficient data exists for the previous tier.</p>
<p><strong>Quick Comparison:</strong></p>
<table><thead><tr><th>Tier</th><th>Data Threshold</th><th>Strategy</th><th>Relative Accuracy</th></tr></thead><tbody>
<tr><td><strong>1</strong></td><td>&gt;100 impressions</td><td>Personalized ML</td><td>Highest (baseline)</td></tr>
<tr><td><strong>2</strong></td><td>10-100 impressions</td><td>Cohort-based</td><td>-10-15% vs Tier 1</td></tr>
<tr><td><strong>3</strong></td><td>&lt;10 impressions</td><td>Demographic avg</td><td>-15-25% vs Tier 1</td></tr>
<tr><td><strong>4</strong></td><td>No data</td><td>Category priors</td><td>-20-30% vs Tier 1</td></tr>
</tbody></table>
<p><strong>Tier 1: Rich User History (&gt;100 impressions)</strong></p>
<ul>
<li><strong>Prediction source:</strong> User-specific GBDT model trained on individual engagement patterns</li>
<li><strong>When to use:</strong> Returning users with weeks of interaction history</li>
<li><strong>What you know:</strong> Which ad categories they click, preferred formats (video vs static), optimal times (morning commute vs evening browse), device preferences</li>
<li><strong>Example:</strong> User has clicked 15 gaming ads, 8 e-commerce ads, ignored 200+ finance ads → confidently predict gaming/shopping interests</li>
</ul>
<p><strong>Tier 2: User Cohort (10-100 impressions)</strong></p>
<ul>
<li><strong>Prediction source:</strong> Similar users’ aggregated CTR weighted by demographic/behavioral similarity</li>
<li><strong>When to use:</strong> New users (3-7 days old) with limited but non-zero history</li>
<li><strong>What you know:</strong> Basic demographics (age, location, device) plus a few app installs or early interactions</li>
<li><strong>Example:</strong> New user (age 25-34, NYC, iOS, installed 3 shopping apps) → match to cohort of “young urban professionals who shop on mobile” and use their average engagement rates</li>
</ul>
<p><strong>Tier 3: Broad Segment (&lt;10 impressions)</strong></p>
<ul>
<li><strong>Prediction source:</strong> Segment-level CTR averaged across thousands of users in similar demographic buckets</li>
<li><strong>When to use:</strong> Brand new users in first session, or privacy-focused users with minimal tracking</li>
<li><strong>What you know:</strong> Only coarse signals (country, platform, time of day)</li>
<li><strong>Example:</strong> Anonymous user, first visit, only know (country=US, platform=mobile, time=evening) → use “US mobile evening users” segment baseline CTR</li>
</ul>
<p><strong>Tier 4: Global Baseline (No user data)</strong></p>
<ul>
<li><strong>Prediction source:</strong> Historical CTR by ad category/format across all users (industry benchmarks or platform historical averages)</li>
<li><strong>When to use:</strong> Platform launch, complete data loss, or strict privacy mode</li>
<li><strong>What you know:</strong> Nothing about the user - only the ad itself</li>
<li><strong>Example:</strong> Platform day 1, no user data exists → fall back to category priors like “e-commerce ads: 1.8% CTR, gaming ads: 3.2% CTR, finance ads: 0.9% CTR” from industry reports</li>
</ul>
<p><strong>Accuracy Trade-off Pattern:</strong></p>
<p>Accuracy degrades as you move down tiers, but the <strong>relative pattern matters more than exact numbers</strong>:</p>
<p>$$Accuracy_{\text{(Tier N)}} &lt; Accuracy_{\text{(Tier N-1)}}$$</p>
<p><strong>Typical degradation observed in production CTR systems</strong> (based on industry reports from Meta, Google, Twitter ad platforms):</p>
<ul>
<li><strong>Tier 1 → Tier 2:</strong> 10-15% accuracy loss (personalized → cohort)</li>
<li><strong>Tier 2 → Tier 3:</strong> Additional 5-10% loss (cohort → segment)</li>
<li><strong>Tier 3 → Tier 4:</strong> Additional 5-8% loss (segment → global)</li>
</ul>
<p><strong>Total accuracy range:</strong> Tier 1 might achieve AUC 0.78-0.82, while Tier 4 drops to 0.60-0.68. Exact values depend heavily on:</p>
<ul>
<li>Signal strength (ad creative quality, user engagement patterns)</li>
<li>Feature richness (sparse vs dense user profiles)</li>
<li>Domain (gaming ads have higher baseline CTR than insurance ads)</li>
<li>Market maturity (established platform vs new market entry)</li>
</ul>
<p><strong>Key insight:</strong> Even degraded predictions (Tier 3-4) significantly outperform random serving (AUC 0.50), which would be catastrophic for revenue.</p>
<p><strong>Mathematical Model - ε-greedy Exploration:</strong></p>
<p>For new users, balance <strong>exploitation</strong> (show known high-CTR ads) vs <strong>exploration</strong> (gather data for future personalization):</p>
<p>$$a_t = \begin{cases}
\arg\max_a Q(a) &amp; \text{with probability } 1 - \epsilon \\
\text{random action} &amp; \text{with probability } \epsilon
\end{cases}$$</p>
<p>where:</p>
<ul>
<li>\(Q(a)\) = estimated CTR for ad \(a\) based on current data</li>
<li>\(\epsilon\) = exploration rate (typically 0.05-0.10 for new users)</li>
</ul>
<p><strong>Adaptive exploration rate:</strong></p>
<p>$$\epsilon(n) = \frac{\epsilon_0}{1 + \log(n + 1)}$$</p>
<p>where \(n\) is the number of impressions served to this user. New users get \(\epsilon = 0.10\) (10% random exploration), converging to \(\epsilon = 0.02\) after 1000 impressions.</p>
<p><strong>Advertiser Bootstrapping:</strong></p>
<p>New advertisers face similar challenges - their ads have no performance history. Strategy:</p>
<ol>
<li><strong>Minimum spend requirement</strong>: Require $500 minimum spend before enabling full optimization</li>
<li><strong>Broad targeting phase</strong>: First 10K impressions use broad targeting to gather signal across demographics</li>
<li><strong>Thompson Sampling</strong>: Bayesian approach for bid optimization during bootstrap phase</li>
</ol>
<p>$$P(\theta | D) \propto P(D | \theta) \times P(\theta)$$</p>
<p>where \(\theta\) = true CTR, \(D\) = observed clicks/impressions. Sample from posterior to balance exploration/exploitation.</p>
<p><strong>Platform Launch (Day 1) Scenario:</strong></p>
<p>When launching the entire platform with zero historical data:</p>
<ol>
<li><strong>Pre-seed with industry benchmarks</strong>: Use published CTR averages by vertical (e-commerce: 2%, finance: 0.5%, gaming: 5%)</li>
<li><strong>Synthetic data generation</strong>: Create simulated user profiles and engagement patterns for initial model training</li>
<li><strong>Rapid learning mode</strong>: First 48 hours run at \(\epsilon = 0.20\) (high exploration) to quickly gather training data</li>
<li><strong>Cohort velocity tracking</strong>: Monitor how quickly each cohort accumulates usable signal</li>
</ol>
<p>$$T_{bootstrap} = \frac{N_{min}}{R_{impressions} \times P_{engagement}}$$</p>
<p>where:</p>
<ul>
<li>\(N_{min}\) = minimum samples for reliable prediction (typically 100 clicks)</li>
<li>\(R_{impressions}\) = impression rate per user/day</li>
<li>\(P_{engagement}\) = estimated click rate</li>
</ul>
<p><strong>Example</strong>: To gather 100 clicks at 2% CTR with 10 impressions/day per user: \(T = \frac{100}{10 \times 0.02} = 500\) days per user. Solution: aggregate across cohorts to reach critical mass faster.</p>
<p><strong>Trade-off Analysis:</strong></p>
<p>Cold start strategy impacts revenue during bootstrap period:</p>
<ul>
<li><strong>Week 1</strong>: Operating at ~65% of optimal revenue (global averages only)</li>
<li><strong>Week 2-4</strong>: Ramp to ~75% (cohort data accumulating)</li>
<li><strong>Month 2+</strong>: Reach ~90%+ (sufficient user-level history)</li>
</ul>
<p>This is acceptable - <strong>better to launch with 65% revenue than wait 6 months</strong> for perfect data that won’t exist until you launch.</p>
<h3 id="model-serving-infrastructure">Model Serving Infrastructure</h3>
<p><strong>Technology Selection: Model Serving</strong></p>
<p><strong>Model Serving Platforms:</strong></p>
<table><thead><tr><th>Platform</th><th>Latency (p99)</th><th>Throughput</th><th>Batching</th><th>GPU Support</th><th>Ops Complexity</th></tr></thead><tbody>
<tr><td><strong>TensorFlow Serving</strong></td><td>30-40ms</td><td>1K req/sec</td><td>Auto</td><td>Excellent</td><td>Medium</td></tr>
<tr><td>TorchServe</td><td>35-45ms</td><td>800 req/sec</td><td>Auto</td><td>Good</td><td>Medium</td></tr>
<tr><td>NVIDIA Triton</td><td>25-35ms</td><td>1.5K req/sec</td><td>Auto</td><td>Excellent</td><td>High</td></tr>
<tr><td>Seldon Core</td><td>40-50ms</td><td>600 req/sec</td><td>Manual</td><td>Good</td><td>High (K8s)</td></tr>
<tr><td>Custom Flask/FastAPI</td><td>50-100ms</td><td>200 req/sec</td><td>Manual</td><td>Poor</td><td>Low</td></tr>
</tbody></table>
<p><strong>Decision: TensorFlow Serving</strong> (primary) with <strong>NVIDIA Triton</strong> (evaluation)</p>
<p><strong>Rationale:</strong></p>
<ul>
<li><strong>Mature ecosystem:</strong> Production-proven at Google scale</li>
<li><strong>Auto-batching:</strong> Automatically batches requests for GPU efficiency</li>
<li><strong>gRPC support:</strong> Lower serialization overhead than REST (15ms → 5ms)</li>
<li><strong>Model versioning:</strong> A/B testing without redeployment</li>
</ul>
<p><strong>NVIDIA Triton consideration:</strong> 20% lower latency, but requires heterogeneous model formats (TF, PyTorch, ONNX). Added complexity not justified unless multi-framework requirement emerges.</p>
<p><strong>Technology Selection: Container Orchestration</strong></p>
<p>Okay, container orchestration - this is where things get real. I need to pick something that’ll handle GPU scheduling for ML, scale properly, and not lock me into one cloud provider. Here’s what I compared:</p>
<table><thead><tr><th>Technology</th><th>Learning Curve</th><th>Ecosystem</th><th>Auto-scaling</th><th>Multi-cloud</th><th>Networking</th></tr></thead><tbody>
<tr><td><strong>Kubernetes</strong></td><td>Steep</td><td>Massive (CNCF)</td><td>HPA, VPA, Cluster Autoscaler</td><td>Yes (portable)</td><td>Advanced (CNI, Service Mesh)</td></tr>
<tr><td>AWS ECS</td><td>Medium</td><td>AWS-native</td><td>Target tracking, step scaling</td><td>No (AWS-only)</td><td>AWS VPC</td></tr>
<tr><td>Docker Swarm</td><td>Easy</td><td>Limited</td><td>Basic (replicas)</td><td>Yes (portable)</td><td>Overlay networking</td></tr>
<tr><td>Nomad</td><td>Medium</td><td>HashiCorp ecosystem</td><td>Auto-scaling plugins</td><td>Yes (portable)</td><td>Consul integration</td></tr>
</tbody></table>
<p><strong>Decision: Kubernetes</strong></p>
<blockquote>
<p><strong>Architectural Driver: Availability</strong> - Kubernetes auto-scaling (HPA) and self-healing prevent capacity exhaustion during traffic spikes. GPU node affinity ensures ML inference survives node failures by automatically rescheduling pods.</p>
</blockquote>
<p>Rationale:</p>
<ul>
<li><strong>GPU scheduling:</strong> Native support for GPU node affinity and resource limits, critical for ML workloads</li>
<li><strong>Custom metric scaling:</strong> HPA supports queue depth and latency-based scaling (CPU/memory insufficient for GPU-bound workloads)</li>
<li><strong>Ecosystem maturity:</strong> 78% industry adoption, extensive tooling, readily available expertise</li>
<li><strong>Service mesh integration:</strong> Native Istio/Linkerd support for circuit breaking and traffic management</li>
<li><strong>Multi-cloud portability:</strong> Deploy to AWS, GCP, Azure without architectural changes</li>
</ul>
<p>While Kubernetes introduces operational complexity, GPU orchestration and multi-cloud requirements justify the investment.</p>
<p><strong>Kubernetes-specific features critical for ads platform:</strong></p>
<ol>
<li>
<p><strong>Horizontal Pod Autoscaler (HPA) with Custom Metrics:</strong></p>
<p>CPU/memory metrics are lagging indicators for this workload - ML inference is GPU-bound (CPU at 20% while GPU saturated), and CPU spikes occur after queue buildup. Use workload-specific metrics instead:</p>
<p><strong>Scaling formula:</strong> \(\text{desired replicas} = \lceil \text{current replicas} \times \frac{\text{current metric}}{\text{target metric}} \rceil\)</p>
<p><strong>Custom metrics:</strong></p>
<ul>
<li><strong>Inference queue depth</strong>: Target 100 requests (current: 250 → scale 10 to 25 pods)</li>
<li><strong>Request latency p99</strong>: Target 80ms within 100ms budget</li>
<li><strong>Cache hit rate</strong>: Scale cache tier when &lt;85%</li>
</ul>
<p><strong>Accounting for provisioning delays:</strong></p>
<p>$$N_{buffer} = \frac{dQ}{dt} \times (T_{provision} + T_{warmup})$$</p>
<p>where \(\frac{dQ}{dt}\) = traffic growth rate, \(T_{provision}\) = node startup (90-120s for GPU instances), \(T_{warmup}\) = model loading (20-40s).</p>
<p><strong>Example:</strong> Traffic growing at 10K QPS/sec with 90s total startup requires scaling at \(90\% - \frac{900 \text{ pods}}{\text{capacity}}\) to avoid overload during provisioning. Trade-off: GPU node startup latency forces earlier scaling with higher idle capacity cost.</p>
</li>
<li>
<p><strong>GPU Node Affinity:</strong></p>
<ul>
<li>Schedule ML inference pods only on GPU nodes using node selectors</li>
<li>Prevents GPU resource waste by isolating GPU workloads</li>
</ul>
</li>
<li>
<p><strong>StatefulSets for Stateful Services:</strong></p>
<ul>
<li>Deploy CockroachDB, Redis clusters with stable network identities</li>
<li>Ordered pod creation/deletion (e.g., CockroachDB region placement first)</li>
</ul>
</li>
<li>
<p><strong>Istio Service Mesh:</strong></p>
<ul>
<li><strong>Traffic splitting:</strong> A/B test new model versions (90% traffic to v1, 10% to v2)</li>
<li><strong>Circuit breaking:</strong> Automatic failure detection, failover to backup services</li>
<li><strong>Observability:</strong> Automatic trace injection, latency histograms per service</li>
</ul>
</li>
</ol>
<p><strong>Why not AWS ECS?</strong></p>
<p>ECS advantages (managed, lower cost) offset by:</p>
<ul>
<li>Vendor lock-in - migration to GCP/Azure requires rewriting task definitions</li>
<li>Auto-scaling is limited to CPU/memory target tracking - no custom metrics</li>
<li>GPU support requires manual AMI management without node affinity</li>
<li>Insufficient for complex ML infrastructure</li>
</ul>
<p><strong>Why not Docker Swarm:</strong></p>
<ul>
<li>Minimal ecosystem adoption (~5% market share, stagnant development)</li>
<li>No GPU scheduling, limited auto-scaling, no service mesh</li>
<li>High operational risk due to limited engineer availability</li>
<li>Docker Inc. has de-prioritized in favor of Kubernetes</li>
</ul>
<p><strong>The cost trade-off (rough comparison for ~100 nodes):</strong></p>
<p>Kubernetes (managed service like EKS):</p>
<ul>
<li>Control plane fees (managed)</li>
<li>Worker node infrastructure costs</li>
<li>Operational overhead (engineering time for management)</li>
<li><strong>Rough total: Can vary widely</strong> depending on instance types and configuration</li>
</ul>
<p>AWS ECS (Fargate):</p>
<ul>
<li>Per-vCPU and per-GB-memory pricing</li>
<li>No control plane fees</li>
<li>Lower operational overhead (fully managed)</li>
<li><strong>Generally 10-20% cheaper</strong> than Kubernetes on EC2 instances for basic workloads</li>
</ul>
<p><strong>So why might I still choose Kubernetes despite slightly higher costs?</strong></p>
<p>The GPU support and multi-cloud portability matter for this use case. ECS Fargate has limited GPU support, and I prefer not being locked into AWS. The premium (perhaps 10-20% higher monthly costs) acts as insurance against vendor lock-in and provides proper GPU scheduling for ML workloads.</p>
<p>That said, your calculation might differ - ECS could make sense if you’re committed to AWS and don’t need GPU orchestration.</p>
<p><strong>Deployment Strategy Comparison:</strong></p>
<table><thead><tr><th>Strategy</th><th>Cold Start</th><th>Auto-scaling</th><th>Cost</th><th>Reliability</th></tr></thead><tbody>
<tr><td><strong>Dedicated instances</strong></td><td>0ms (always warm)</td><td>Manual</td><td>High (24/7)</td><td>High</td></tr>
<tr><td><strong>Kubernetes pods</strong></td><td>30-60s</td><td>Auto (HPA)</td><td>Medium</td><td>Medium</td></tr>
<tr><td>Serverless (Lambda)</td><td>5-10s</td><td>Instant</td><td>Low (pay-per-use)</td><td>Low (cold starts)</td></tr>
</tbody></table>
<p><strong>Decision: Dedicated GPU instances</strong> with <strong>Kubernetes orchestration</strong></p>
<p><strong>Cost-benefit calculation:</strong></p>
<p><strong>Option A: Dedicated T4 GPUs (always-on)</strong></p>
<ul>
<li>10 instances always running (GPU baseline cost)</li>
<li>Latency: 30ms (no cold start)</li>
<li>Availability: 99.9%</li>
</ul>
<p><strong>Option B: Kubernetes with auto-scaling (3 min, 10 max instances)</strong></p>
<ul>
<li>Average load: ~50% of dedicated GPU baseline</li>
<li>Burst capacity: Additional instances provision in 90s</li>
<li>Cost savings: <strong>50%</strong>, acceptable 90s warmup during spikes</li>
</ul>
<p><strong>Option C: AWS Lambda with GPU</strong></p>
<ul>
<li>Not viable: 5-10s cold start violates 100ms latency SLA</li>
</ul>
<p><strong>Winner: Option B (Kubernetes with auto-scaling)</strong> - balances cost and performance.</p>
<p>To meet sub-40ms latency requirements, use TensorFlow Serving with optimizations:</p>
<p><strong>1. Request Batching</strong></p>
<p>Accumulate requests for 5ms, batch inference.</p>
<p><strong>Example:</strong> Batch size 32, 25ms inference time → <strong>~1,280 predictions/second per GPU</strong>.</p>
<p><strong>2. Model Quantization</strong></p>
<p>Convert FP32 → INT8:</p>
<p><strong>Mathematical Transformation:</strong></p>
<p>For weight matrix \(W \in \mathbb{R}^{m \times n}\) with FP32 precision:</p>
<p>$$W_{int8}[i,j] = \text{round}\left(\frac{W[i,j] - W_{min}}{W_{max} - W_{min}} \times 255\right)$$</p>
<p>Inference:
$$y = W_{int8} \cdot x_{int8} \times scale + zero\_point$$</p>
<p><strong>Benefits:</strong></p>
<ul>
<li>4x memory reduction (32-bit → 8-bit)</li>
<li>2-4x inference speedup (INT8 ops faster)</li>
<li>Accuracy loss: typically &lt;1% AUC degradation</li>
</ul>
<p><strong>3. GPU Acceleration</strong></p>
<p>Deploy on NVIDIA T4 GPUs:</p>
<ul>
<li>FP32 throughput: 65 TFLOPS</li>
<li>INT8 throughput: 130 TOPS (2x faster)</li>
</ul>
<p><strong>Cost-Benefit Analysis:</strong></p>
<table><thead><tr><th>Compute Type</th><th>Throughput</th><th>Relative Cost</th><th>Latency</th></tr></thead><tbody>
<tr><td><strong>CPU inference</strong></td><td>100 req/sec per core</td><td>Baseline</td><td>100ms+ (violates SLA)</td></tr>
<tr><td><strong>GPU inference (T4)</strong></td><td>1,280 req/sec per GPU</td><td>Similar to CPU at scale</td><td>&lt;40ms (meets SLA)</td></tr>
</tbody></table>
<p><strong>Cost per 1M predictions:</strong></p>
<ul>
<li>CPU: Baseline cost per prediction</li>
<li>GPU: ~97% of CPU baseline (similar cost but 12.8× throughput, 2.5× better latency)</li>
</ul>
<p>GPU is cost-competitive at scale while <strong>significantly better latency</strong> (meets &lt;40ms requirement vs CPU’s 100ms+).</p>
<h3 id="feature-store-tecton-architecture">Feature Store: Tecton Architecture</h3>
<pre class="mermaid">
    
    graph TB
    subgraph "Feature Definition Layer"
        DEF[Feature Definitions<br/>Python/SQL DSL]
        DEF --> BATCH[Batch Feature Views]
        DEF --> STREAM[Stream Feature Views]
        DEF --> REALTIME[Real-Time Feature Views]
    end

    subgraph "Data Sources"
        S3_SOURCE[(S3/HDFS<br/>Historical Data)]
        KAFKA_SOURCE[Kafka Topics<br/>Event Stream]
        DB_SOURCE[(PostgreSQL<br/>Transactional Data)]
    end

    subgraph "Feature Computation"
        SPARK_BATCH[Spark Jobs<br/>Daily/Hourly]
        FLINK_STREAM[Flink Streaming<br/>Windowed Aggregations]
        API_RT[Real-Time API<br/>On-Demand Compute]
    end

    subgraph "Feature Storage"
        OFFLINE[(Offline Store<br/>S3 Parquet<br/>Historical Features)]
        ONLINE[(Online Store<br/>Redis/DynamoDB<br/>Low-latency Serving)]
    end

    subgraph "Serving Layer"
        REST[REST API<br/>HTTP/2]
        GRPC[gRPC API<br/>High Performance]
        SDK[Python/Java SDK]
    end

    S3_SOURCE --> SPARK_BATCH
    KAFKA_SOURCE --> FLINK_STREAM
    DB_SOURCE --> API_RT

    BATCH --> SPARK_BATCH
    STREAM --> FLINK_STREAM
    REALTIME --> API_RT

    SPARK_BATCH --> OFFLINE
    SPARK_BATCH --> ONLINE
    FLINK_STREAM --> ONLINE
    API_RT --> ONLINE

    ONLINE --> REST
    ONLINE --> GRPC
    ONLINE --> SDK

    REST --> INFERENCE[ML Inference Service]
    GRPC --> INFERENCE
    SDK --> INFERENCE

    classDef source fill:#e1f5fe,stroke:#01579b
    classDef compute fill:#f3e5f5,stroke:#4a148c
    classDef storage fill:#e8f5e9,stroke:#1b5e20
    classDef serving fill:#fff3e0,stroke:#e65100

    class S3_SOURCE,KAFKA_SOURCE,DB_SOURCE source
    class SPARK_BATCH,FLINK_STREAM,API_RT compute
    class OFFLINE,ONLINE storage
    class REST,GRPC,SDK,INFERENCE serving
</pre>
<p><strong>Feature Freshness Guarantees:</strong></p>
<ul>
<li><strong>Batch features:</strong> \(t_{fresh} \leq 24h\)</li>
<li><strong>Stream features:</strong> \(t_{fresh} \leq 100ms\)</li>
<li><strong>Real-time features:</strong> \(t_{fresh} = 0\) (computed per request)</li>
</ul>
<p><strong>Latency SLA:</strong>
$$P(\text{FeatureLookup} \leq 10ms) \geq 0.99$$</p>
<p>Achieved with:</p>
<ul>
<li>Redis p99 latency: 5ms</li>
<li>DynamoDB p99 latency: 8ms</li>
<li>Feature vector assembly: 2ms</li>
</ul>
<hr />
<h2 id="part-5-distributed-caching-architecture">Part 5: Distributed Caching Architecture</h2>
<div class="part-toc">
<div class="part-toc-header">
<div class="part-toc-title">In this part:</div>
</div>
<ul>
<li><a href="#multi-tier-cache-hierarchy">Multi-Tier Cache Hierarchy</a>
<span class="part-toc-desc">L1/L2/L3 architecture, cache selection, technology comparison</span></li>
<li><a href="#cache-performance-analysis">Cache Performance Analysis</a>
<span class="part-toc-desc">Hit rates, latency profiles, cost-benefit analysis</span></li>
<li><a href="#cache-cost-optimization-the-economic-tradeoff">Cache Cost Optimization: The Economic Tradeoff</a>
<span class="part-toc-desc">TCO calculations, cache sizing, budget allocation</span></li>
<li><a href="#redis-cluster-consistent-hashing-and-sharding">Redis Cluster: Consistent Hashing and Sharding</a>
<span class="part-toc-desc">Data distribution, rebalancing, cluster topology</span></li>
<li><a href="#hot-partition-problem-and-mitigation">Hot Partition Problem and Mitigation</a>
<span class="part-toc-desc">Load skew, replication strategies, request routing</span></li>
<li><a href="#workload-isolation-separating-batch-from-serving-traffic">Workload Isolation: Separating Batch from Serving Traffic</a>
<span class="part-toc-desc">Dedicated clusters, priority queues, QoS management</span></li>
<li><a href="#cache-invalidation-strategies">Cache Invalidation Strategies</a>
<span class="part-toc-desc">TTL policies, active invalidation, consistency patterns</span></li>
</ul>

<div class="part-toc-nav">

    <a href="#part-4-ml-inference-pipeline" class="prev-part-link"><i class="fa fa-angle-double-up"></i> Part 4: ML Inference Pipeline</a>


    <a href="#part-6-auction-mechanism-design" class="next-part-link">Part 6: Auction Mechanism Design <i class="fa fa-angle-double-down"></i></a>

</div>

</div>
<h3 id="multi-tier-cache-hierarchy">Multi-Tier Cache Hierarchy</h3>
<p>To achieve 95%+ cache hit rate with sub-10ms latency, implement three cache tiers:</p>
<p><strong>Technology Selection: Cache Tier Choices</strong></p>
<p><strong>L1 Cache Options:</strong></p>
<table><thead><tr><th>Technology</th><th>Latency</th><th>Throughput</th><th>Memory</th><th>Pros</th><th>Cons</th></tr></thead><tbody>
<tr><td><strong>Caffeine (JVM)</strong></td><td>~1μs</td><td>10M ops/sec</td><td>In-heap</td><td>Window TinyLFU eviction, lock-free reads</td><td>JVM-only, GC pressure</td></tr>
<tr><td>Guava Cache</td><td>~1.5μs</td><td>5M ops/sec</td><td>In-heap</td><td>Simple API, widely used</td><td>LRU only, lower hit rate</td></tr>
<tr><td>Ehcache</td><td>~1.5μs</td><td>8M ops/sec</td><td>In/off-heap</td><td>Off-heap option reduces GC</td><td>More complex configuration</td></tr>
</tbody></table>
<p><strong>Decision: Caffeine</strong> - Superior eviction algorithm (Window TinyLFU) yields 10-15% higher hit rates than LRU-based alternatives. Benchmarks show ~2x throughput vs. Guava.</p>
<p><strong>L2 Cache Options:</strong></p>
<table><thead><tr><th>Technology</th><th>Latency (p99)</th><th>Throughput</th><th>Clustering</th><th>Data Structures</th><th>Pros</th><th>Cons</th></tr></thead><tbody>
<tr><td><strong>Redis Cluster</strong></td><td>5ms</td><td>100K ops/sec/node</td><td>Native sharding</td><td>Rich (lists, sets, sorted sets)</td><td>Lua scripting, atomic ops</td><td>More memory than Memcached</td></tr>
<tr><td>Memcached</td><td>3ms</td><td>150K ops/sec/node</td><td>Client-side sharding</td><td>Key-value only</td><td>Lower memory, simpler</td><td>No atomic ops, no persistence</td></tr>
<tr><td>Hazelcast</td><td>8ms</td><td>50K ops/sec/node</td><td>Native clustering</td><td>Rich data structures</td><td>Java integration</td><td>Higher latency, less mature</td></tr>
</tbody></table>
<p><strong>Decision: Redis Cluster</strong></p>
<blockquote>
<p><strong>Architectural Driver: Financial Accuracy</strong> - Redis atomic operations (DECRBY/INCRBY) provide strong consistency for budget counters. Memcached lacks atomicity, which could cause budget race conditions and unbounded over-delivery (servers allocating from stale budget values).</p>
</blockquote>
<ul>
<li><strong>Need atomic operations</strong> for budget counters (DECRBY, INCRBY)</li>
<li><strong>Complex data structures</strong> for ad metadata (sorted sets for recency, hashes for attributes)</li>
<li><strong>Persistence</strong> for crash recovery (avoid cold cache startup)</li>
<li><strong>Trade-off accepted:</strong> 30% higher memory usage vs. Memcached for operational simplicity</li>
</ul>
<p><strong>Performance Analysis:</strong></p>
<p>Memcached typically costs <strong>~30% less</strong> than Redis for equivalent capacity, but Redis offers atomic operations and richer data structures that justify the premium for this use case.</p>
<p><strong>Valkey Alternative (Redis Fork):</strong></p>
<p>In 2024, Redis Labs changed licensing from BSD to dual-license (SSPL + proprietary), creating uncertainty for commercial users. The Linux Foundation forked Redis into <strong>Valkey</strong> with permissive BSD-3 license:</p>
<ul>
<li><strong>API-compatible:</strong> Drop-in replacement for Redis</li>
<li><strong>Clear licensing:</strong> BSD-3 (no SSPL restrictions)</li>
<li><strong>Industry backing:</strong> AWS, Google Cloud, Oracle backing Linux Foundation project</li>
<li><strong>Migration path:</strong> AWS ElastiCache transitioning to Valkey</li>
</ul>
<p><strong>Recommendation:</strong> Use Valkey for new deployments to avoid licensing ambiguity. Migration from Redis is trivial (same protocol, same commands, same performance).</p>
<p><strong>L3 Persistent Store Options:</strong></p>
<p><strong>Note:</strong> Write throughput numbers reflect <strong>cluster-level performance</strong> at production scale (20-80 nodes for distributed databases). Single-node performance is typically 5-20K writes/sec depending on hardware and workload characteristics.</p>
<table><thead><tr><th>Technology</th><th>Read Latency (p99)</th><th>Write Throughput<br/>(cluster-level)</th><th>Scalability</th><th>Consistency</th><th>HLC Built-in</th><th>Pros</th><th>Cons</th></tr></thead><tbody>
<tr><td><strong>CockroachDB</strong></td><td>10-15ms</td><td>400K writes/sec<br/>(60-80 nodes)</td><td>Horizontal (Raft)</td><td>Strong (ACID)</td><td>Yes</td><td>SQL, multi-region, built-in HLC</td><td>License (BSL → Apache 2.0)</td></tr>
<tr><td>YugabyteDB</td><td>10-15ms</td><td>400K writes/sec<br/>(60-80 nodes)</td><td>Horizontal (Raft)</td><td>Strong (ACID)</td><td>Yes</td><td>PostgreSQL-compatible</td><td>Smaller ecosystem</td></tr>
<tr><td>Cassandra</td><td>20ms</td><td>500K writes/sec<br/>(100+ nodes)</td><td>Linear (peer-to-peer)</td><td>Tunable (eventual)</td><td>No</td><td>Multi-DC, mature</td><td>No JOINs, eventual consistency</td></tr>
<tr><td>PostgreSQL</td><td>15ms</td><td>50K writes/sec<br/>(single node)</td><td>Vertical + sharding</td><td>ACID transactions</td><td>No</td><td>SQL, JOINs, strong consistency</td><td>Manual sharding complex</td></tr>
<tr><td>DynamoDB</td><td>10ms</td><td>1M writes/sec<br/>(auto-scaled)</td><td>Fully managed</td><td>Eventual/strong</td><td>No</td><td>Auto-scaling, no ops</td><td>Vendor lock-in, cost at scale</td></tr>
</tbody></table>
<p><strong>Decision: CockroachDB</strong></p>
<blockquote>
<p><strong>Architectural Driver: Financial Accuracy + Latency</strong> - CockroachDB provides strong ACID consistency with built-in Hybrid Logical Clocks (HLC), eliminating the need for custom clock synchronization implementation. 10-15ms reads (vs Cassandra’s 20ms) help meet latency budgets while ensuring billing accuracy.</p>
</blockquote>
<ul>
<li><strong>Scale requirement:</strong> 400M users → 4TB+ user profiles</li>
<li><strong>Strong consistency:</strong> ACID transactions align with financial accuracy requirements (no custom eventual→strong reconciliation logic needed)</li>
<li><strong>Built-in HLC:</strong> Native timestamp ordering across regions eliminates 150+ lines of custom NTP+HLC implementation</li>
<li><strong>Multi-region:</strong> Built-in geo-partitioning with CL=QUORUM for regional writes</li>
<li><strong>SQL compatibility:</strong> Full SQL + JOINs simplify application development vs CQL</li>
<li><strong>Better read latency:</strong> 10-15ms vs Cassandra’s 20ms</li>
</ul>
<p><strong>Cassandra consideration:</strong> Higher write throughput (500K vs 400K writes/sec), but eventual consistency creates complexity for financial data. Would require custom HLC implementation (lines 2234-2285) plus reconciliation logic.</p>
<p><strong>YugabyteDB alternative:</strong> Similar architecture to CockroachDB, PostgreSQL wire-compatible. Either choice is valid; CockroachDB chosen for slightly more mature multi-region deployment tooling.</p>
<p><strong>PostgreSQL limitation:</strong> Vertical scaling hits ceiling around 50-100TB. Sharding (e.g., Citus) adds operational complexity comparable to CockroachDB, but without native multi-region or HLC.</p>
<p><strong>Database cost comparison at 8B requests/day:</strong></p>
<table><thead><tr><th>Database</th><th>Relative Cost</th><th>Trade-offs</th></tr></thead><tbody>
<tr><td><strong>DynamoDB</strong></td><td>100% (managed baseline)</td><td>Fully managed, eventual consistency default, vendor lock-in</td></tr>
<tr><td><strong>CockroachDB</strong> (60-80 nodes, self-hosted)</td><td>10-15% of DynamoDB</td><td>Self-managed infrastructure, strong consistency, multi-region native, HLC built-in</td></tr>
<tr><td><strong>PostgreSQL</strong> (sharded, self-hosted)</td><td>8-12% of DynamoDB</td><td>Self-managed, no native multi-region, complex sharding</td></tr>
</tbody></table>
<p><strong>CockroachDB self-hosted at scale is 7-10× cheaper</strong> than DynamoDB at billions of requests/day, while providing strong consistency and native multi-region support.</p>
<p><strong>Note:</strong> Cost advantage primarily applies to self-hosted deployments at high volumes. CockroachDB Serverless vs DynamoDB has different economics - choose based on operational complexity tolerance and query patterns (read-heavy vs write-heavy workloads).</p>
<pre class="mermaid">
    
    graph TB
    subgraph "Request Flow"
        REQ[Cache Request<br/>user_id: 12345]
    end

    subgraph "L1: In-Process Cache"
        L1[Caffeine JVM Cache<br/>10-second TTL<br/>~1μs lookup<br/>100MB per server]
        L1_HIT{Hit?}
        L1_STATS[L1 Statistics<br/>Hit Rate: 60%<br/>Avg Latency: 1μs]
    end

    subgraph "L2: Distributed Cache"
        L2[Redis Cluster<br/>30-second TTL<br/>~5ms lookup<br/>1000 nodes × 16GB]
        L2_HIT{Hit?}
        L2_STATS[L2 Statistics<br/>Hit Rate: 35%<br/>Avg Latency: 5ms]
    end

    subgraph "L3: Persistent Store"
        L3[CockroachDB Cluster<br/>Multi-Region ACID<br/>~10-15ms read<br/>Strong Consistency]
        L3_STATS[L3 Statistics<br/>Hit Rate: 5%<br/>Avg Latency: 12ms]
    end

    subgraph "Hot Key Detection"
        MONITOR[Stream Processor<br/>Kafka Streams<br/>Count-Min Sketch]
        REPLICATE[Dynamic Replication<br/>3x copies for hot keys]
    end

    REQ --> L1
    L1 --> L1_HIT
    L1_HIT -->|60% Hit| RESP1[Response<br/>~1μs]
    L1_HIT -->|40% Miss| L2

    L2 --> L2_HIT
    L2_HIT -->|35% Hit| POPULATE_L1[Populate L1]
    POPULATE_L1 --> RESP2[Response<br/>~5ms]
    L2_HIT -->|5% Miss| L3

    L3 --> POPULATE_L2[Populate L2 + L1]
    POPULATE_L2 --> RESP3[Response<br/>~20ms]

    L2 -.->|0.1% sampling| MONITOR
    MONITOR -.->|Detect hot keys| REPLICATE
    REPLICATE -.->|Replicate to nodes| L2

    subgraph "Overall Performance"
        PERF[Total Hit Rate: 95%<br/>Average Latency: 2.75ms<br/>p99 Latency: 25ms]
    end

    classDef cache fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef source fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    classDef monitor fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px

    class L1,L2 cache
    class L3 source
    class MONITOR,REPLICATE monitor
</pre><h3 id="cache-performance-analysis">Cache Performance Analysis</h3>
<p><strong>Hit Rate Calculation:</strong></p>
<p>Let \(H_i\) be the hit rate of tier \(i\). Total hit rate:</p>
<p>$$H_{total} = H_1 + (1 - H_1) \times H_2 + (1 - H_1)(1 - H_2) \times H_3$$</p>
<p>With \(H_1 = 0.60\), \(H_2 = 0.35\), \(H_3 = 1.0\): <strong>Overall hit rate = 95%</strong></p>
<p><strong>Average Latency:</strong></p>
<p>$$\mathbb{E}[L] = H_1 L_1 + (1-H_1)H_2 L_2 + (1-H_1)(1-H_2) L_3$$</p>
<p>With L2 hit rate of 87.5% (conditional on L1 miss) and latencies \(L_1 = 0.001ms\), \(L_2 = 5ms\), \(L_3 = 20ms\): <strong>Expected latency = 2.75ms</strong></p>
<h3 id="cache-cost-optimization-the-economic-tradeoff">Cache Cost Optimization: The Economic Tradeoff</h3>
<blockquote>
<p><strong>Architectural Driver: Financial Accuracy + Latency</strong> - Cache sizing is not just a performance problem but an economic optimization. At scale, every GB of Redis costs money, every cache miss hits the database (cost + latency), and every millisecond of added latency costs revenue. The optimal cache size balances these three factors.</p>
</blockquote>
<p><strong>The Fundamental Tradeoff:</strong></p>
<p>At 1M QPS with 400M users, cache sizing decisions have massive financial impact:</p>
<ul>
<li><strong>Too small cache</strong>: High miss rate → database overload + latency spikes → revenue loss</li>
<li><strong>Too large cache</strong>: Paying for Redis memory that delivers diminishing returns</li>
<li><strong>Optimal size</strong>: Maximizes profit = revenue - (cache cost + database cost + latency cost)</li>
</ul>
<p><strong>Cost Model:</strong></p>
<p>The total cost function combines three components:</p>
<p>$$C_{total} = C_{cache}(S) + C_{db}(S) + C_{latency}(S)$$</p>
<p>where \(S\) = cache size (GB)</p>
<p><strong>Component 1: Cache Memory Cost</strong></p>
<p>$$C_{cache}(S) = S \times P_{memory} \times N_{nodes}$$</p>
<p>where:</p>
<ul>
<li>\(S\) = cache size per node (GB)</li>
<li>\(P_{memory}\) = cost per GB-month (baseline cache cost unit)</li>
<li>\(N_{nodes}\) = number of Redis nodes</li>
</ul>
<p><strong>Cache pricing note:</strong> Managed cache services (ElastiCache, Valkey) typically cost 10-12× per GB compared to raw compute instances. Self-hosted Redis on standard instances is cheaper but adds operational overhead.</p>
<p><strong>Example:</strong> 1000 nodes × 16GB/node × baseline GB-month rate = <strong>baseline cache cost</strong></p>
<p><strong>Component 2: Database Query Cost</strong></p>
<p>Cache misses hit CockroachDB, which costs both compute and I/O:</p>
<p>$$C_{db}(S) = Q_{total} \times (1 - H(S)) \times C_{query}$$</p>
<p>where:</p>
<ul>
<li>\(Q_{total}\) = total queries/month</li>
<li>\(H(S)\) = hit rate as function of cache size</li>
<li>\(C_{query}\) = cost per database query (baseline query cost unit)</li>
</ul>
<p><strong>Example:</strong> 2.6B queries/month × 5% miss rate × baseline query cost = <strong>query cost component</strong></p>
<p><strong>Component 3: Revenue Loss from Latency</strong></p>
<p>Every cache miss adds ~15ms latency (database read vs cache hit). Amazon’s study: 100ms latency = 1% revenue loss.</p>
<p>$$C_{latency}(S) = R_{monthly} \times (1 - H(S)) \times \frac{\Delta L}{100ms} \times 0.01$$</p>
<p>where:</p>
<ul>
<li>\(R_{monthly}\) = monthly revenue baseline</li>
<li>\(\Delta L\) = latency penalty per miss (15ms)</li>
<li>0.01 = 1% revenue loss per 100ms</li>
</ul>
<p><strong>Example:</strong> Revenue baseline × 5% miss rate × (15ms/100ms) × 1% = <strong>latency cost component</strong></p>
<p><strong>Modeling User Access Patterns: Why Zipfian Distribution?</strong></p>
<p>Real-world user access patterns in web systems follow a <strong>power law</strong> distribution, not a uniform distribution. A small fraction of users (or items) account for a disproportionately large fraction of traffic.</p>
<p><strong>Zipfian distribution</strong> (named after linguist George Zipf) models this phenomenon:</p>
<ul>
<li>The most popular item gets accessed \(\frac{1}{1}\) times as often as expected</li>
<li>The 2nd most popular item gets \(\frac{1}{2}\) times as often</li>
<li>The nth most popular item gets \(\frac{1}{n}\) times as often</li>
</ul>
<p><strong>Why Zipfian for ad platforms?</strong></p>
<ul>
<li><strong>Empirically validated</strong>: YouTube (2016): 10% of videos account for 80% of views. Facebook (2013): Top 1% of users generate 30% of content interactions.</li>
<li><strong>User behavior</strong>: Power users (daily active) access the platform far more frequently than casual users (weekly/monthly)</li>
<li><strong>Advertiser concentration</strong>: Large advertisers (Procter &amp; Gamble, Unilever) run continuous campaigns; small advertisers run sporadic 1-week campaigns</li>
</ul>
<p><strong>Alternative distributions considered:</strong></p>
<table><thead><tr><th>Distribution</th><th>Formula</th><th>Use Case</th><th>Why NOT Used Here</th></tr></thead><tbody>
<tr><td><strong>Uniform</strong></td><td>\(P(x) = \frac{1}{N}\)</td><td>All items equally likely</td><td>Unrealistic - not all users access platform equally</td></tr>
<tr><td><strong>Normal (Gaussian)</strong></td><td>\(P(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\)</td><td>Symmetric around mean</td><td>User access has long tail, not symmetric</td></tr>
<tr><td><strong>Exponential</strong></td><td>\(P(x) = \lambda e^{-\lambda x}\)</td><td>Time between events</td><td>Models timing, not popularity ranking</td></tr>
<tr><td><strong>Zipfian (power law)</strong></td><td>\(P(\text{rank } r) \propto \frac{1}{r^{\alpha}}\)</td><td>Popularity ranking</td><td><strong>Matches real-world access patterns</strong></td></tr>
</tbody></table>
<p><strong>Parameter choice:</strong> \(\alpha = 1.0\) (classic Zipf’s law) is standard for web caching literature. Higher \(\alpha\) (e.g., 1.5) means more concentration at the top; lower \(\alpha\) (e.g., 0.7) means flatter distribution.</p>
<p><strong>Hit Rate as Function of Cache Size (Zipfian Distribution):</strong></p>
<p>User access follows Zipfian distribution with \(\alpha = 1.0\) (power law):</p>
<p>$$P(\text{rank } r) = \frac{1/r}{\sum_{i=1}^{N} 1/i} \approx \frac{1}{r \times \ln(N)}$$</p>
<p><strong>Cache hit rate:</strong></p>
<p>$$H(S) = \frac{\text{\# of cached items}}{\text{Total items}} \times \text{Access weight}$$</p>
<p>For Zipfian(\(\alpha=1.0\)):</p>
<table><thead><tr><th>Cache Coverage</th><th>Hit Rate</th><th>Cache Size (% of total)</th></tr></thead><tbody>
<tr><td>Top 1% of users</td><td>45-50%</td><td>1% × 4TB = 40GB</td></tr>
<tr><td>Top 5% of users</td><td>70-75%</td><td>5% × 4TB = 200GB</td></tr>
<tr><td>Top 10% of users</td><td>80-85%</td><td>10% × 4TB = 400GB</td></tr>
<tr><td>Top 20% of users</td><td>90-95%</td><td>20% × 4TB = 800GB</td></tr>
<tr><td>Top 40% of users</td><td>96-98%</td><td>40% × 4TB = 1.6TB</td></tr>
</tbody></table>
<p><strong>Key insight:</strong> Zipfian distribution means <strong>diminishing returns</strong> after ~20% coverage.</p>
<p><strong>Marginal Cost Analysis:</strong></p>
<p>The optimal cache size occurs where marginal cost equals marginal benefit:</p>
<p>$$\frac{dC_{total}}{dS} = 0$$</p>
<p><strong>Marginal cost</strong> (adding 1 GB of cache):
$$MC_{cache} = 1GB \times P_{memory} \times N_{nodes}$$</p>
<p><strong>Marginal benefit</strong> (hit rate improvement):</p>
<p>For Zipfian distribution, adding cache beyond 20% coverage yields &lt;0.5% hit rate improvement:</p>
<p>$$MB = \Delta H \times (C_{db} + C_{latency})$$</p>
<p><strong>Example:</strong></p>
<ul>
<li>Going from 20% → 30% coverage: +0.5% hit rate</li>
<li>Benefit: 0.005 × (query cost + latency cost components) ≈ <strong>small benefit</strong></li>
<li>Cost: 10% × 4TB = 400GB additional cache × cluster size = <strong>very large cost</strong></li>
</ul>
<p><strong>Not worth it</strong> - marginal cost far exceeds marginal benefit beyond 20% coverage.</p>
<p><strong>Optimal Cache Size Calculation:</strong></p>
<p>Given our constraints:</p>
<ul>
<li>Total dataset: 4TB (400M users × 10KB/user)</li>
<li>Monthly revenue: baseline (illustrative example: $10M for 1M QPS platform)</li>
<li>Redis cost: baseline cache cost per GB-month</li>
<li>Database query cost: baseline query cost</li>
<li>Latency penalty: 1% revenue per 100ms</li>
</ul>
<p><strong>Optimize:</strong></p>
<p>$$\min_{S} \left[ C_{cache}(S) + C_{db}(S) + C_{latency}(S) \right]$$</p>
<p>Subject to:</p>
<ul>
<li>\(H(S) \geq 0.80\) (minimum acceptable hit rate)</li>
<li>\(L_{p99} \leq 10ms\) (latency SLA)</li>
</ul>
<p><strong>Solution (relative costs as % of total caching infrastructure):</strong></p>
<table><thead><tr><th>Cache Size</th><th>Hit Rate</th><th>Cost Breakdown (relative %)</th><th>Total Relative Cost</th><th>Analysis</th></tr></thead><tbody>
<tr><td><strong>5% (200GB)</strong></td><td>65-70%</td><td>Cache: 15%, DB: 54%, Latency: 31%</td><td><strong>100%</strong> (baseline)</td><td>High DB+latency penalties</td></tr>
<tr><td><strong>10% (400GB)</strong></td><td>75-80%</td><td>Cache: 37%, DB: 40%, Latency: 23%</td><td><strong>81%</strong></td><td>Better balance</td></tr>
<tr><td><strong>20% (800GB)</strong></td><td>85-90%</td><td>Cache: 74%, DB: 16%, Latency: 10%</td><td><strong>80%</strong> (optimal)</td><td>Best total cost</td></tr>
<tr><td><strong>40% (1.6TB)</strong></td><td>93-96%</td><td>Cache: 93%, DB: 5%, Latency: 2%</td><td><strong>128%</strong></td><td>Expensive for marginal gain</td></tr>
</tbody></table>
<p><strong>Optimal choice: 20% coverage (800GB cache)</strong></p>
<ul>
<li><strong>20% coverage is the clear winner</strong> at 80% of the 5%-coverage cost</li>
<li>Provides 85-90% hit rate following Zipfian power-law distribution (α≈1.0)</li>
<li>Best total cost optimization: Balances cache, database, and latency costs</li>
<li><strong>Note:</strong> Hit rates validated against web caching research showing 80-20 rule (20% of items serve 80% of traffic)</li>
</ul>
<p><strong>Trade-off accepted:</strong> We choose <strong>20% coverage (800GB distributed across cluster)</strong> because:</p>
<ol>
<li><strong>Lowest total cost</strong>: Optimal point on cost curve (80% of 5%-coverage baseline)</li>
<li>85-90% hit rate meets 80%+ requirement comfortably with safety margin</li>
<li>Latency cost minimized (reduces latency penalty 59% vs 10% coverage)</li>
<li>Worth paying higher cache cost to save significantly on database and latency costs</li>
</ol>
<p><strong>TTL Optimization: Freshness vs Hit Rate Tradeoff</strong></p>
<p>Time-to-live (TTL) settings create a second optimization problem:</p>
<ul>
<li><strong>Short TTL</strong> (10s): Fresh data, but more cache misses after expiration</li>
<li><strong>Long TTL</strong> (300s): High hit rate, but stale data</li>
</ul>
<p><strong>Staleness Cost Model:</strong></p>
<p>$$C_{staleness} = P(\text{stale}) \times C_{error}$$</p>
<p>For user profiles:</p>
<ul>
<li>1% of profiles update per hour</li>
<li>Average TTL/2 staleness window</li>
<li>Cost of stale ad: targeting quality degradation</li>
</ul>
<p><strong>Example: 30s TTL</strong></p>
<ul>
<li>Average staleness: 15s</li>
<li>Probability stale: 0.01 × (15/3600) = 0.0042%</li>
<li>Cost: Low staleness penalty (baseline)</li>
</ul>
<p><strong>Example: 300s TTL</strong></p>
<ul>
<li>Average staleness: 150s</li>
<li>Probability stale: 0.01 × (150/3600) = 0.042%</li>
<li>Cost: 10× higher staleness penalty</li>
</ul>
<p><strong>Optimal TTL: 30-60 seconds</strong></p>
<p>Balances freshness cost with reasonable hit rate. Longer TTLs increase staleness cost 10×.</p>
<p><strong>Multi-Tier Cost-Benefit Analysis</strong></p>
<p><strong>Question:</strong> Does adding L1 in-process cache (Caffeine) pay off?</p>
<p><strong>L1 Cache Costs:</strong></p>
<ul>
<li>Memory: 100MB per server × 100 servers = 10GB (negligible, in-heap)</li>
<li>CPU: ~2% overhead for cache management</li>
<li>Complexity: Additional code, monitoring</li>
</ul>
<p><strong>L1 Cache Benefits:</strong></p>
<p>From our architecture:</p>
<ul>
<li>L1 hit rate: 60% of all requests</li>
<li>Latency improvement: 5ms (Redis) → 0.001ms (in-process) = <strong>~5ms saved</strong></li>
<li>Revenue impact: 60% of queries save ~5ms ≈ 3ms average improvement</li>
</ul>
<p>$$\text{Revenue gain} = 0.60 \times Q_{total} \times \frac{3ms}{100ms} \times 0.01 \times R_{monthly}$$</p>
<p><strong>Not a clear win</strong> - marginal revenue benefits compared to operational complexity.</p>
<p><strong>However:</strong> L1 cache provides <strong>resilience</strong> during Redis outages:</p>
<ul>
<li>Without L1: Redis down → 100% cache miss → database overload</li>
<li>With L1: Redis down → 60% hit rate → database load manageable</li>
</ul>
<p><strong>Decision:</strong> Keep L1 for <strong>resilience</strong>, not economics.</p>
<p><strong>Cost Summary (relative to total caching infrastructure):</strong></p>
<table><thead><tr><th>Component</th><th>Relative Cost</th><th>Notes</th></tr></thead><tbody>
<tr><td>L1 Cache (Caffeine)</td><td>~0%</td><td>In-process, negligible memory</td></tr>
<tr><td>L2 Cache (Redis/Valkey)</td><td>58%</td><td>800GB at 20% coverage, 85-90% hit rate</td></tr>
<tr><td>L3 Database infrastructure (CockroachDB)</td><td>22-29%</td><td>60-80 nodes baseline</td></tr>
<tr><td>Database query cost (cache misses)</td><td>13%</td><td>10-15% miss rate × query volume</td></tr>
<tr><td>Cache miss latency cost</td><td>8%</td><td>Revenue loss from slow queries</td></tr>
<tr><td><strong>Total caching infrastructure</strong></td><td><strong>100%</strong></td><td>Optimized for 85-90% hit rate at 20% coverage</td></tr>
</tbody></table>
<p><strong>Alternative (no caching):</strong></p>
<ul>
<li>Database infrastructure: 23-28% (more nodes for load)</li>
<li>Database query cost: 49% (all queries hit database)</li>
<li>Latency cost: 28% (all queries at 15ms latency penalty)</li>
<li><strong>Total: 380-400% of optimized caching cost</strong> + poor user experience</li>
</ul>
<p><strong>Savings from caching: 73-75% cost reduction</strong> vs no-cache alternative</p>
<h3 id="redis-cluster-consistent-hashing-and-sharding">Redis Cluster: Consistent Hashing and Sharding</h3>
<p><strong>Cluster Configuration:</strong></p>
<ul>
<li>1000 Redis nodes</li>
<li>16,384 hash slots (Redis default)</li>
<li>Consistent hashing with virtual nodes</li>
</ul>
<p><strong>Hash Slot Assignment:</strong></p>
<p>For key \(k\), compute hash:
$$\text{slot}(k) = \text{CRC16}(k) \mod 16384$$</p>
<p>Slot-to-node mapping maintained in cluster state.</p>
<p><strong>Virtual Nodes:</strong></p>
<p>Each physical node handles \(\frac{16384}{1000} \approx 16\) hash slots.</p>
<p><strong>Load Distribution:</strong></p>
<p>With uniform hash function, load variance:
$$\text{Var}[\text{load}] = \frac{\mu}{n \times v}$$</p>
<p>where:</p>
<ul>
<li>\(\mu\) = average load per node</li>
<li>\(n\) = number of physical nodes</li>
<li>\(v\) = number of virtual nodes per physical node</li>
</ul>
<p><strong>Example:</strong> 1000 QPS across 1000 nodes with 16 virtual nodes each → <strong>standard deviation ≈ 25% of mean load</strong>.</p>
<h3 id="hot-partition-problem-and-mitigation">Hot Partition Problem and Mitigation</h3>
<p><strong>Problem Definition:</strong></p>
<p>A “celebrity user” generates 100x normal traffic:</p>
<ul>
<li>Normal user: 10 requests/second</li>
<li>Celebrity user: 1,000 requests/second</li>
</ul>
<p>Single Redis node cannot handle spike → becomes bottleneck.</p>
<p><strong>Detection: Count-Min Sketch</strong></p>
<p>Count-Min Sketch is a probabilistic data structure that tracks key frequencies in constant memory (~5KB for millions of keys) with O(1) operations. It provides conservative frequency estimates (never under-counts, may over-estimate), making it ideal for detecting hot keys without storing exact counters. Trade-off: tunable accuracy vs memory footprint.</p>
<p><strong>Dynamic Hot Key Replication:</strong></p>
<p>When Count-Min Sketch detects key with frequency &gt; threshold (e.g., 100 req/sec):</p>
<ol>
<li><strong>Replicate key</strong> to \(R\) Redis nodes (e.g., \(R = 3\))</li>
<li><strong>Update routing table</strong>: advertise replicas to all servers</li>
<li><strong>Client-side load balancing</strong>: randomly select replica for reads</li>
</ol>
<p><strong>Mathematical Analysis:</strong></p>
<p>Let \(\lambda\) be the request rate for a hot key, \(R\) be the number of replicas.</p>
<p>Per-replica load:
$$\lambda_{replica} = \frac{\lambda}{R}$$</p>
<p><strong>Example:</strong> 1000 req/sec with replication factor 3 → <strong>~333 req/sec per replica</strong> (within single-node capacity).</p>
<h3 id="workload-isolation-separating-batch-from-serving-traffic">Workload Isolation: Separating Batch from Serving Traffic</h3>
<p>One critical lesson from large-scale systems: <strong>never let batch workloads interfere with serving traffic</strong>.</p>
<p><strong>The Problem:</strong></p>
<p>Hourly batch jobs updating user profiles in CockroachDB (millions of writes/hour) can interfere with serving layer reads for ad personalization. Without isolation, batch writes can:</p>
<ul>
<li>Saturate disk I/O (batch writes compete with serving reads)</li>
<li>Fill up queues and increase latency (p99 latency spikes from 20ms to 200ms)</li>
<li>Trigger compactions that block reads</li>
</ul>
<p><strong>Solution: Read/Write Replica Separation</strong></p>
<p>Pin batch workloads to dedicated replicas:</p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>User Profile Table (RF=3):
</span><span>- Replica A (US-East): Serving traffic only
</span><span>- Replica B (US-West): Serving traffic only
</span><span>- Replica C (EU-Central): Batch writes pinned here
</span></code></pre>
<p><strong>Implementation Pattern:</strong></p>
<p>Use CockroachDB’s geo-partitioning with follower reads - partition user profiles by region and pin batch writes to a dedicated region. Configure replication with 3× factor across regions (us-east, us-west, eu-central), then direct batch workloads to eu-central nodes only using range-specific leases.</p>
<p>Serving traffic uses <code>FOLLOWER_READ_TIMESTAMP()</code> for local reads (eventual consistency with &lt;1s staleness acceptable for user profiles), while batch writes use standard SERIALIZABLE writes to eu-central ranges. This separates I/O paths - batch writes don’t contend with serving reads.</p>
<p><strong>Why this works:</strong></p>
<p>CockroachDB’s Raft consensus ensures consistent replication, but follower reads allow serving traffic to read from local replicas without hitting the leaseholder (which may be absorbing batch writes). Batch write load concentrates on eu-central ranges, while serving traffic reads locally from us-east/us-west followers.</p>
<p><strong>Cost of isolation:</strong></p>
<p>Similar resource allocation - dedicated ranges for batch writes occupy ~33% of cluster capacity. For a 60-node cluster: 40 nodes serve traffic, 20 nodes handle batch writes. Trade-off: Strong consistency for financial data while isolating operational workloads.</p>
<p><strong>Monitoring the gap:</strong></p>
<p>Track replication lag between batch and serving replicas:</p>
<p>$$\text{Replication lag} = Timestamp_{\text{serving replica}} - Timestamp_{\text{batch replica}}$$</p>
<p>If lag exceeds 5 minutes, you might have a problem. Scale the batch replica or throttle batch writes.</p>
<h3 id="cache-invalidation-strategies">Cache Invalidation Strategies</h3>
<p><strong>Problem:</strong> When user data updates (e.g., profile change), how to invalidate stale cache?</p>
<p><strong>Strategy 1: TTL-Based (Passive)</strong></p>
<p>Set time-to-live on cache entries:
$$\text{Staleness} \leq \text{TTL}$$</p>
<p><strong>Pros:</strong></p>
<ul>
<li>Simple implementation</li>
<li>No coordination required</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Guaranteed staleness up to TTL</li>
<li>Unnecessary cache misses after TTL</li>
</ul>
<p><strong>Strategy 2: Active Invalidation (Event-Driven)</strong></p>
<p>On data update:</p>
<ol>
<li>Publish invalidation event to Kafka topic</li>
<li>All cache servers subscribe and evict key from L1/L2</li>
</ol>
<p><strong>Latency:</strong></p>
<p>Kafka publish latency: ~5ms
Consumer processing: ~10ms
Total invalidation propagation: <strong>~15ms</strong></p>
<p><strong>Pros:</strong></p>
<ul>
<li>Low staleness (&lt; 100ms)</li>
<li>No unnecessary evictions</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Requires event streaming infrastructure</li>
<li>Network overhead for invalidation messages</li>
</ul>
<p><strong>Strategy 3: Versioned Caching</strong></p>
<p>Include version in cache key:
<code>cache_key = user_id + ":" + version</code></p>
<p>On update:</p>
<ol>
<li>Increment version in metadata store</li>
<li>New requests fetch new version</li>
<li>Old version expires naturally via TTL</li>
</ol>
<p><strong>Pros:</strong></p>
<ul>
<li>No explicit invalidation needed</li>
<li>Multiple versions coexist temporarily</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Metadata store becomes critical path</li>
<li>Higher cache memory usage (duplicate versions)</li>
</ul>
<p><strong>Hybrid Approach (Recommended):</strong></p>
<blockquote>
<p><strong>Architectural Drivers: Latency vs Financial Accuracy</strong> - We use eventual consistency (30s TTL) for user preferences to meet latency targets, but strong consistency (active invalidation) for GDPR opt-outs where legal compliance is non-negotiable.</p>
</blockquote>
<ul>
<li><strong>Normal updates:</strong> TTL = 30s (passive invalidation)</li>
<li><strong>Critical updates</strong> (e.g., GDPR opt-out): Active invalidation via Kafka</li>
<li><strong>Version metadata</strong> for tracking update history</li>
</ul>
<hr />
<h2 id="part-6-auction-mechanism-design">Part 6: Auction Mechanism Design</h2>
<div class="part-toc">
<div class="part-toc-header">
<div class="part-toc-title">In this part:</div>
</div>
<ul>
<li><a href="#generalized-second-price-gsp-auction">Generalized Second-Price (GSP) Auction</a>
<span class="part-toc-desc">Single-slot auction basics, eCPM calculation, second-price mechanism</span></li>
<li><a href="#multi-slot-gsp-position-dependent-auctions">Multi-Slot GSP: Position-Dependent Auctions</a>
<span class="part-toc-desc">Position effects, cascade model, multi-slot pricing</span></li>
<li><a href="#vcg-vickrey-clarke-groves-auction">VCG (Vickrey-Clarke-Groves) Auction</a>
<span class="part-toc-desc">Truthful mechanism, externality pricing, VCG vs GSP comparison</span></li>
<li><a href="#game-theoretic-properties">Game-Theoretic Properties</a>
<span class="part-toc-desc">Truthfulness, Nash equilibrium, LEFE, why GSP dominates in practice</span></li>
<li><a href="#quality-score-and-ad-rank-industry-practice">Quality Score and Ad Rank</a>
<span class="part-toc-desc">Google's quality factors, ML-based scoring, system architecture</span></li>
<li><a href="#computational-complexity">Computational Complexity</a>
<span class="part-toc-desc">Performance comparison: GSP O(N log N) vs VCG O(N² log N)</span></li>
<li><a href="#reserve-prices-and-floor-prices">Reserve Prices and Floor Prices</a>
<span class="part-toc-desc">Revenue optimization, dynamic pricing, multi-dimensional reserves</span></li>
<li><a href="#industry-evolution-first-price-auctions">Industry Evolution: First-Price Auctions</a>
<span class="part-toc-desc">Header bidding, bid shading, modern auction landscape</span></li>
</ul>

<div class="part-toc-nav">

    <a href="#part-5-distributed-caching-architecture" class="prev-part-link"><i class="fa fa-angle-double-up"></i> Part 5: Distributed Caching Architecture</a>


    <a href="#part-7-advanced-topics" class="next-part-link">Part 7: Advanced Topics <i class="fa fa-angle-double-down"></i></a>

</div>

</div>
<h3 id="generalized-second-price-gsp-auction">Generalized Second-Price (GSP) Auction</h3>
<p>The standard auction mechanism for ads platforms is the Generalized Second-Price (GSP) auction, a variant of the Vickrey-Clarke-Groves (VCG) mechanism.</p>
<p><strong>Auction Setup:</strong></p>
<ul>
<li>\(N\) advertisers submit bids \(b_1, b_2, \ldots, b_N\)</li>
<li>Each ad has predicted <strong>CTR</strong> (Click-Through Rate): \(\text{CTR}_1, \text{CTR}_2, \ldots, \text{CTR}_N\) - the probability a user clicks the ad when shown</li>
<li>Single ad slot to allocate</li>
</ul>
<p><strong>Effective Bid (eCPM - effective Cost Per Mille):</strong></p>
<p>Advertisers use different pricing models - some pay per impression (CPM), others per click (CPC), others per conversion (CPA). To compare apples-to-apples, we convert all bids to <strong>eCPM</strong>: expected revenue per 1000 impressions.</p>
<p>For a CPC bid (cost-per-click), the platform only earns revenue when users click. If an advertiser bids $4.00 per click, but their ad has 15% CTR (150 clicks per 1000 impressions):</p>
<p>$$\text{eCPM}_i = b_i \times \text{CTR}_i \times 1000 = \$4.00 \times 0.15 \times 1000 = \$600$$</p>
<p>This normalizes bids across pricing models: eCPM represents expected revenue per 1000 impressions, accounting for how likely users are to click.</p>
<p><strong>Why this matters</strong>: A $6.00 CPC bid with 5% CTR (eCPM = $300) earns less than a $4.00 CPC bid with 15% CTR (eCPM = $600). The platform maximizes revenue by selecting the highest eCPM, not highest raw bid.</p>
<p><strong>Winner Selection:</strong></p>
<p>$$w = \arg\max_{i \in [1,N]} \text{eCPM}_i$$</p>
<p><strong>Price Determination (Second-Price):</strong></p>
<p>The winner pays the minimum bid needed to beat the second-highest bidder:</p>
<p>$$p_w = \frac{\text{eCPM}_{2nd}}{\text{CTR}_w \times 1000} + \epsilon$$</p>
<p>where \(\epsilon\) is a small increment (e.g., $0.01).</p>
<p><strong>Example:</strong></p>
<style>
#tbl_5 + table th:first-of-type  { width: 15%; }
#tbl_5 + table th:nth-of-type(2) { width: 15%; }
#tbl_5 + table th:nth-of-type(3) { width: 15%; }
#tbl_5 + table th:nth-of-type(4) { width: 45%; }
#tbl_5 + table th:nth-of-type(5) { width: 10%; }
</style>
<div id="tbl_5"></div>
<table><thead><tr><th>Advertiser</th><th>Bid</th><th>CTR</th><th>eCPM</th><th>Rank</th></tr></thead><tbody>
<tr><td>A</td><td>$5.00</td><td>0.10</td><td>5.00 × 0.10 × 1000 = $500</td><td>2</td></tr>
<tr><td>B</td><td>$4.00</td><td>0.15</td><td>4.00 × 0.15 × 1000 = $600</td><td>1</td></tr>
<tr><td>C</td><td>$6.00</td><td>0.05</td><td>6.00 × 0.05 × 1000 = $300</td><td>3</td></tr>
</tbody></table>
<p>Winner: Advertiser B (highest eCPM = $600)</p>
<p>Price paid by B:
$$p_B = \frac{500}{0.15 \times 1000} = \frac{500}{150} = \$3.33$$</p>
<p>Advertiser B bid $4.00 but only pays $3.33 (just enough to beat A).</p>
<h3 id="multi-slot-gsp-position-dependent-auctions">Multi-Slot GSP: Position-Dependent Auctions</h3>
<p>The single-slot example above is foundational, but real search engines show multiple ads. In multi-slot auctions, <strong>position matters</strong> - top positions get more clicks.</p>
<p><strong>The Position Effect (Cascade Model):</strong></p>
<p>Users view ads from top to bottom. An ad in position 1 gets more visibility than position 2.</p>
<p><strong>Position-Dependent CTR:</strong></p>
<p>Actual clicks depend on both ad quality and position:</p>
<p>$$Clicks_{i} = baseCTR_{i} \times \alpha_{position} \times impressions$$</p>
<p>where \(\alpha_1 &gt; \alpha_2 &gt; \alpha_3 &gt; \ldots\) are position-specific multipliers.</p>
<p><strong>Example: Position Effect</strong></p>
<p>Consider an ad with base CTR = 15%:</p>
<style>
#tbl_gsp_multi + table th:first-of-type  { width: 20%; }
#tbl_gsp_multi + table th:nth-of-type(2) { width: 20%; }
#tbl_gsp_multi + table th:nth-of-type(3) { width: 30%; }
#tbl_gsp_multi + table th:nth-of-type(4) { width: 30%; }
</style>
<div id="tbl_gsp_multi"></div>
<table><thead><tr><th>Position</th><th>Click Multiplier (α)</th><th>Calculation</th><th>Actual CTR</th></tr></thead><tbody>
<tr><td>Position 1 (Top)</td><td>α₁ = 1.0</td><td>15% × 1.0</td><td>15.0%</td></tr>
<tr><td>Position 2</td><td>α₂ = 0.7</td><td>15% × 0.7</td><td>10.5%</td></tr>
<tr><td>Position 3</td><td>α₃ = 0.5</td><td>15% × 0.5</td><td>7.5%</td></tr>
<tr><td>Position 4</td><td>α₄ = 0.3</td><td>15% × 0.3</td><td>4.5%</td></tr>
</tbody></table>
<p>Same ad, different positions → dramatically different click-through rates.</p>
<p><strong>Multi-Slot GSP Allocation:</strong></p>
<p><strong>Step 1: Rank by eCPM (using base CTR)</strong></p>
<p>$$eCPM_{i} = b_i \times baseCTR_{i} \times 1000$$</p>
<p><strong>Step 2: Assign positions by rank</strong></p>
<ul>
<li>Highest eCPM → Position 1</li>
<li>2nd highest → Position 2</li>
<li>3rd highest → Position 3</li>
</ul>
<p><strong>Multi-Slot GSP Pricing:</strong></p>
<p>Under the <strong>separable CTR assumption</strong> (clicks = baseCTR × position multiplier), advertiser in position \(k\) pays just enough to beat the advertiser in position \(k+1\):</p>
<p>$$p_{k} = \frac{eCPM_{k+1}}{baseCTR_{k} \times 1000}$$</p>
<p><strong>Key Insight:</strong> The pricing formula is identical to single-slot GSP! The position effects cancel out because higher-ranked ads get better positions. The position multipliers (α) affect allocation but not pricing in equilibrium.</p>
<p><strong>Complete Multi-Slot Example:</strong></p>
<p>Setup: 3 ad positions with α₁ = 1.0, α₂ = 0.7, α₃ = 0.5</p>
<p>4 advertisers submit CPC bids:</p>
<style>
#tbl_gsp_multi_example + table th:first-of-type  { width: 15%; }
#tbl_gsp_multi_example + table th:nth-of-type(2) { width: 10%; }
#tbl_gsp_multi_example + table th:nth-of-type(3) { width: 10%; }
#tbl_gsp_multi_example + table th:nth-of-type(4) { width: 10%; }
#tbl_gsp_multi_example + table th:nth-of-type(5) { width: 10%; }
#tbl_gsp_multi_example + table th:nth-of-type(6) { width: 30%; }
#tbl_gsp_multi_example + table th:nth-of-type(7) { width: 15%; }
</style>
<div id="tbl_gsp_multi_example"></div>
<table><thead><tr><th>Advertiser</th><th>Bid</th><th>Base CTR</th><th>eCPM</th><th>Rank</th><th>Position</th><th>Price per</br>Click</th></tr></thead><tbody>
<tr><td>A</td><td>$5.00</td><td>0.15</td><td>$750</td><td>1</td><td>Position 1 (α₁=1.0)</td><td>$4.00</td></tr>
<tr><td>B</td><td>$6.00</td><td>0.10</td><td>$600</td><td>2</td><td>Position 2 (α₂=0.7)</td><td>$4.80</td></tr>
<tr><td>C</td><td>$4.00</td><td>0.12</td><td>$480</td><td>3</td><td>Position 3 (α₃=0.5)</td><td>$2.00</td></tr>
<tr><td>D</td><td>$3.00</td><td>0.08</td><td>$240</td><td>4</td><td>No position</td><td>N/A</td></tr>
</tbody></table>
<p><strong>Price Calculations:</strong></p>
<p>Using the formula \(p_k = \frac{eCPM_{k+1}}{baseCTR_k \times 1000}\):</p>
<ul>
<li>A pays: $600 / (0.15 × 1000) = $4.00 (bid $5, pay $4 - second-price)</li>
<li>B pays: $480 / (0.10 × 1000) = $4.80</li>
<li>C pays: $240 / (0.12 × 1000) = $2.00</li>
</ul>
<p><strong>Key Property:</strong> Positions assigned by eCPM rank (A=$750 &gt; B=$600 &gt; C=$480), ensuring highest-value ads get best positions. GSP prioritizes allocation efficiency over revenue maximization—a platform revenue-optimizing mechanism like VCG would be more complex.</p>
<p><strong>Connection to Single-Slot GSP:</strong> Multi-slot GSP is the natural extension. Each position is allocated by eCPM ranking, and pricing ensures no advertiser wants to swap positions with another in equilibrium (locally envy-free equilibrium).</p>
<p><strong>Industry Standard:</strong> Google Search Ads uses multi-slot GSP with position effects for sponsored search results. The cascade model (users view top-to-bottom) is well-established in academic literature (<a href="https://people.ischool.berkeley.edu/~hal/Papers/2006/position.pdf">Varian 2007</a>).</p>
<h3 id="vcg-vickrey-clarke-groves-auction">VCG (Vickrey-Clarke-Groves) Auction</h3>
<p>The <strong>VCG (Vickrey-Clarke-Groves) auction</strong> is an alternative mechanism designed to be <strong>truthful</strong>: advertisers maximize their utility by bidding their true value, regardless of others’ bids.</p>
<p><strong>The Problem VCG Solves:</strong></p>
<p>GSP incentivizes strategic bidding (bid shading, gaming). VCG eliminates this: <strong>truthful bidding is always optimal</strong>. The trade-off? Higher computational complexity.</p>
<p><strong>Core Principle: Pay Your Externality</strong></p>
<p>In VCG, winners pay for the <strong>harm they cause to others</strong> by participating in the auction. This aligns incentives: your payment equals the social cost of your presence, making truthful bidding optimal.</p>
<p><strong>Externality Definition:</strong></p>
<p>$$\text{Externality}_w = \text{Welfare (without } w) - \text{Welfare (with } w, \text{ excluding } w\text{’s utility)}$$</p>
<p><strong>Translation:</strong> “How much worse off are other advertisers because you’re in the auction?”</p>
<p><strong>Single-Slot VCG (Vickrey Auction):</strong></p>
<p>For <strong>single-slot auctions</strong>, VCG behaves similarly to GSP: winner pays second-highest value (externality equals opportunity cost to next-best bidder).</p>
<p><strong>Key insight:</strong> With truthful bidding, single-slot VCG = single-slot GSP (both charge second-price).</p>
<p>The real difference between VCG and GSP emerges with <strong>multiple ad slots</strong>, where VCG calculates total reallocation cost while GSP uses simpler position-based pricing.</p>
<p><strong>Multi-Slot VCG:</strong></p>
<p>With multiple ad slots, VCG and GSP diverge significantly. VCG calculates the <strong>total reallocation</strong> if a winner weren’t present.</p>
<p><strong>General VCG Payment Formula:</strong></p>
<p>For advertiser \(i\) assigned to slot \(k\) with click probability \(\alpha_k\), the VCG payment per click is:</p>
<p>$$p_i = \frac{SW_{-i} - SW_{-i}^{i}}{\text{CTR}_i \times \alpha_k}$$</p>
<p>where:</p>
<ul>
<li>\(SW_{-i}\) = social welfare <strong>without</strong> advertiser \(i\) (optimal reallocation of others)</li>
<li>\(SW_{-i}^{i}\) = social welfare <strong>with</strong> advertiser \(i\), <strong>excluding</strong> \(i\)’s utility (others’ welfare under current allocation)</li>
<li>\(\text{CTR}_i\) = advertiser \(i\)’s click-through rate</li>
<li>\(\alpha_k\) = slot \(k\)’s click probability</li>
</ul>
<p><strong>Breaking it down:</strong></p>
<ol>
<li><strong>Externality</strong> (numerator): \(SW_{-i} - SW_{-i}^{i}\) = harm to others, measured in value per impression</li>
<li><strong>Clicks received</strong> (denominator): \(\text{CTR}_i \times \alpha_k\) = advertiser’s expected clicks per impression</li>
<li><strong>Payment per click</strong>: Externality per impression ÷ Clicks per impression</li>
</ol>
<p><strong>Intuition:</strong> “How much harm do I cause others?” (externality) divided by “How many clicks do I get?” (my usage) = My cost per click.</p>
<p><strong>Example: 3 Slots, 4 Advertisers</strong></p>
<p><strong>Setup:</strong></p>
<table><thead><tr><th>Advertiser</th><th>Value/Click</th><th>CTR</th><th>Value × CTR</th><th>Rank</th></tr></thead><tbody>
<tr><td>A</td><td>$10</td><td>0.20</td><td>2.00</td><td>1</td></tr>
<tr><td>B</td><td>$8</td><td>0.25</td><td>2.00</td><td>1</td></tr>
<tr><td>C</td><td>$12</td><td>0.10</td><td>1.20</td><td>3</td></tr>
<tr><td>D</td><td>$6</td><td>0.15</td><td>0.90</td><td>4</td></tr>
</tbody></table>
<p><strong>Slots:</strong> Position 1 (α₁ = 0.3 clicks), Position 2 (α₂ = 0.2), Position 3 (α₃ = 0.1)</p>
<p><strong>VCG Allocation:</strong> Rank by value × CTR</p>
<ul>
<li>Slot 1 → A (2.00)</li>
<li>Slot 2 → B (2.00)</li>
<li>Slot 3 → C (1.20)</li>
</ul>
<p><strong>VCG Pricing for A:</strong></p>
<p><strong>Step 1: Social welfare WITH A</strong> (others only):</p>
<ul>
<li>B in slot 2: value 2.00 × 0.2 clicks = 0.40</li>
<li>C in slot 3: value 1.20 × 0.1 clicks = 0.12</li>
<li>Total (others): 0.52</li>
</ul>
<p><strong>Step 2: Social welfare WITHOUT A</strong> (reallocate):</p>
<ul>
<li>B → slot 1: 2.00 × 0.3 = 0.60</li>
<li>C → slot 2: 1.20 × 0.2 = 0.24</li>
<li>D → slot 3: 0.90 × 0.1 = 0.09</li>
<li>Total (others): 0.93</li>
</ul>
<p><strong>A’s externality:</strong> 0.93 - 0.52 = 0.41</p>
<p><strong>A pays:</strong> \(\frac{0.41}{0.20 \times 0.3} = \frac{0.41}{0.06} = \$6.83\) per click</p>
<p><strong>GSP would charge differently:</strong> A would pay just enough to beat next-highest eCPM at their position.</p>
<p><strong>Why This Matters:</strong></p>
<p><strong>VCG Properties:</strong></p>
<ul>
<li><strong>Truthful:</strong> Bidding true value is dominant strategy (no gaming)</li>
<li><strong>Efficient allocation:</strong> Maximizes social welfare</li>
<li><strong>Complexity:</strong> O(N² log N) - must recalculate welfare for each winner</li>
</ul>
<p><strong>When to Use VCG:</strong></p>
<ul>
<li>Small-scale auctions where truthfulness is critical</li>
<li>High-value auctions where computation cost is acceptable</li>
<li>Environments where strategic bidding causes instability</li>
</ul>
<p><strong>Why Most Platforms Use GSP Instead:</strong></p>
<ul>
<li>VCG requires O(N²) welfare calculations (slow for real-time)</li>
<li>GSP is O(N log N) - much faster</li>
<li>GSP generates 5-10% more revenue in equilibrium</li>
<li>Industry has converged on GSP (network effects)</li>
</ul>
<h3 id="game-theoretic-properties">Game-Theoretic Properties</h3>
<p><strong>Why this section matters:</strong> Pure auction theory says “use VCG (truthful mechanism),” but industry reality uses GSP. This section explains the gap and helps you choose the right mechanism for your platform.</p>
<p><strong>For rigorous proofs</strong>, see <a href="https://www.benedelman.org/publications/gsp-060801.pdf">Edelman et al. 2007</a> and <a href="https://www.cs.cornell.edu/courses/cs6840/2020sp/note/CS6840_Apr29_scribenotes.pdf">Cornell CS6840 lecture notes</a>.</p>
<p><strong>For implementation guidance</strong>, read on.</p>
<p><strong>Key Strategic Properties of GSP:</strong></p>
<p><strong>1. GSP is NOT Truthful</strong></p>
<p>Unlike VCG (where bidding true value is optimal), <strong>GSP incentivizes strategic bidding</strong>. Advertisers can profit by bidding below their true value.</p>
<p><strong>Why:</strong> In GSP, your bid affects both (a) which slot you get, and (b) what you pay. Sometimes a “worse” slot at much lower price yields higher profit than the “best” slot at high price. (<a href="https://www.cs.cornell.edu/courses/cs6840/2020sp/note/CS6840_Apr29_scribenotes.pdf">Proof with concrete example</a> shows 177% profit gain from strategic bidding.)</p>
<p><strong>2. GSP Has Nash Equilibrium (Not Dominant Strategy)</strong></p>
<ul>
<li><strong>VCG:</strong> Dominant strategy - “Bid true value regardless of others”</li>
<li><strong>GSP:</strong> Nash equilibrium - “Best response given what others bid”</li>
</ul>
<p>This means bidders need to learn/adapt to market conditions rather than having a single optimal strategy.</p>
<p><strong>3. Multiple Equilibria → LEFE Refinement</strong></p>
<p>GSP has infinitely many Nash equilibria. In practice, bids converge to <strong>Locally Envy-Free Equilibrium (LEFE)</strong> where no advertiser wants to swap with neighbors at current prices.</p>
<p><strong>LEFE properties (<a href="https://www.benedelman.org/publications/gsp-060801.pdf">Edelman et al. 2007</a>):</strong></p>
<ul>
<li>Efficient allocation (highest-value advertisers get best slots)</li>
<li>Unique payments (despite multiple bid profiles)</li>
<li>Emerges through learning (typically within weeks)</li>
<li><strong>Generates ≥ VCG revenue</strong> (proven, not just empirical)</li>
</ul>
<p><strong>Why Industry Uses GSP Despite Non-Truthfulness:</strong></p>
<style>
#tbl_gsp_vcg_compare + table th:first-of-type  { width: 25%; }
#tbl_gsp_vcg_compare + table th:nth-of-type(2) { width: 37%; }
#tbl_gsp_vcg_compare + table th:nth-of-type(3) { width: 38%; }
</style>
<div id="tbl_gsp_vcg_compare"></div>
<table><thead><tr><th>Property</th><th>VCG</th><th>GSP</th></tr></thead><tbody>
<tr><td>Truthfulness</td><td>Dominant strategy</td><td>Nash equilibrium only</td></tr>
<tr><td>Revenue</td><td>Lower (baseline)</td><td>5-10% higher (proven)</td></tr>
<tr><td>Computational Complexity</td><td>O(N² log N)</td><td>O(N log N)</td></tr>
<tr><td>Explainability</td><td>Complex (externality)</td><td>Simple (rank by eCPM)</td></tr>
<tr><td>Efficiency</td><td>Always efficient</td><td>Efficient at LEFE</td></tr>
<tr><td>Stability</td><td>Unique equilibrium</td><td>Multiple (LEFE emerges)</td></tr>
<tr><td>Industry adoption</td><td>Rare</td><td>Universal</td></tr>
</tbody></table>
<p><strong>Bottom Line:</strong> GSP trades dominant-strategy truthfulness for higher revenue, lower complexity, and better explainability. For real-time platforms serving billions of auctions daily, this is the right trade-off.</p>
<p><strong>Implementation Implications:</strong></p>
<p><strong>What to expect:</strong></p>
<ol>
<li><strong>Strategic bidding:</strong> Advertisers will NOT bid true values - design for learning/optimization</li>
<li><strong>Convergence:</strong> Bids stabilize to LEFE within weeks (monitor for equilibrium)</li>
<li><strong>Bid assistance:</strong> Consider providing bid suggestions to guide toward efficient equilibrium</li>
<li><strong>Revenue advantage:</strong> GSP generates 5-10% more revenue than VCG at LEFE</li>
</ol>
<p><strong>Mechanism design in practice:</strong> Real-world constraints (simplicity, revenue, adoption, latency) often outweigh pure theoretical properties.</p>
<h3 id="quality-score-and-ad-rank-industry-practice">Quality Score and Ad Rank (Industry Practice)</h3>
<p>The GSP mechanism above assumes ads are ranked purely by eCPM = bid × CTR. In practice, <strong>ad quality</strong> also matters.</p>
<p><strong>The Quality Problem:</strong></p>
<p>Consider two advertisers:</p>
<ul>
<li>Advertiser X: Bid $10, fast landing page, relevant ad copy → users happy</li>
<li>Advertiser Y: Bid $11, slow landing page, misleading ad → users complain</li>
</ul>
<p>Should Y win just because they bid more? This degrades user experience.</p>
<p><strong>Google’s Solution: Quality Score</strong></p>
<p>Since ~2005, Google Ads has incorporated <strong>Quality Score</strong> into auction ranking:</p>
<p>$$\text{Ad Rank} = \text{Bid} \times \text{Quality Score}$$</p>
<p><strong>Quality Score Components (1-10 scale):</strong></p>
<ol>
<li><strong>Expected CTR</strong> (40% weight): Historical click-through rate for this keyword/ad combination</li>
<li><strong>Ad Relevance</strong> (30% weight): How well ad text matches search query intent</li>
<li><strong>Landing Page Experience</strong> (30% weight): Page load speed, mobile-friendliness, content relevance, security (HTTPS)</li>
</ol>
<p><strong>Modified Auction Ranking:</strong></p>
<p>Instead of ranking by eCPM alone, rank by <strong>Ad Rank</strong>:</p>
<p>$$\text{Ad Rank}_i = b_i \times \text{CTR}_i \times \text{QualityScore}_i \times 1000$$</p>
<p><strong>Example: Quality Beats Price</strong></p>
<style>
#tbl_quality + table th:first-of-type  { width: 15%; }
#tbl_quality + table th:nth-of-type(2) { width: 12%; }
#tbl_quality + table th:nth-of-type(3) { width: 12%; }
#tbl_quality + table th:nth-of-type(4) { width: 18%; }
#tbl_quality + table th:nth-of-type(5) { width: 18%; }
#tbl_quality + table th:nth-of-type(6) { width: 13%; }
#tbl_quality + table th:nth-of-type(7) { width: 12%; }
</style>
<div id="tbl_quality"></div>
<table><thead><tr><th>Advertiser</th><th>Bid</th><th>CTR</th><th>Quality Score</th><th>Ad Rank</th><th>Position</th><th>Winner?</th></tr></thead><tbody>
<tr><td>X</td><td>$5.00</td><td>0.15</td><td>10/10 (excellent)</td><td>7,500</td><td>1</td><td>Yes</td></tr>
<tr><td>Y</td><td>$7.00</td><td>0.15</td><td>6/10 (poor landing page)</td><td>6,300</td><td>2</td><td>No</td></tr>
</tbody></table>
<p>Advertiser X wins despite lower bid ($5 vs $7) because of higher quality (10/10 vs 6/10).</p>
<p><strong>System Design Implications:</strong></p>
<p><strong>1. Data Pipeline Requirements:</strong></p>
<ul>
<li><strong>Historical CTR tracking:</strong> Store click/impression data per advertiser-keyword pair</li>
<li><strong>Landing page metrics:</strong> Collect page load times, bounce rates, mobile scores</li>
<li><strong>Real-time signals:</strong> HTTPS status, page availability checks</li>
<li><strong>Storage:</strong> Time-series database for CTR history, key-value store for current quality scores</li>
</ul>
<p><strong>2. Computation Architecture:</strong></p>
<p>Quality Score is computed offline by ML model, cached, and served at auction time:</p>
<pre class="mermaid">
    
    graph
    subgraph "Offline Pipeline - Runs Daily/Weekly"
        direction BT
        CACHE_WRITE[Cache Update<br/>Redis/Memcached<br/>Atomic Swap]
        PREDICT[Quality Score Prediction<br/>All Advertiser-Keyword Pairs<br/>Millions of Combinations]
        TRAIN[ML Model Training<br/>XGBoost/Neural Net<br/>Hours of Batch Processing]
        HD[(Historical Data Store<br/>Time-Series DB<br/>Billions of Auction Events)]

        HD --> TRAIN
        TRAIN --> PREDICT
        PREDICT --> CACHE_WRITE
    end

    subgraph "Online Pipeline - Real-Time <100ms"
        direction TB
        AUCTION[Auction Request<br/>User Query + Bids<br/>N Advertisers]
        CACHE_LOOKUP{Cache Lookup<br/>Redis Read<br/>< 1ms}
        CACHE_HIT[Quality Score Retrieved<br/>99%+ Hit Rate]
        CACHE_MISS[Cache Miss<br/>Use Default Score = 7/10<br/>< 1% Rate]
        COMPUTE[Compute Ad Rank<br/>Bid × CTR × QualityScore<br/>< 1ms]
        GSP[GSP Pricing<br/>Rank & Select Winner<br/>< 5ms]
        RESULT[Auction Result<br/>Winner + Price<br/>Click/Impression Event]

        AUCTION --> CACHE_LOOKUP
        CACHE_LOOKUP -->|Hit| CACHE_HIT
        CACHE_LOOKUP -->|Miss| CACHE_MISS
        CACHE_HIT --> COMPUTE
        CACHE_MISS --> COMPUTE
        COMPUTE --> GSP
        GSP --> RESULT
    end

    style HD fill:#e1f5ff
    style TRAIN fill:#e1f5ff
    style PREDICT fill:#e1f5ff
    style CACHE_WRITE fill:#e1f5ff
    style AUCTION fill:#fff4e1
    style CACHE_LOOKUP fill:#fffacd
    style CACHE_HIT fill:#d4edda
    style CACHE_MISS fill:#f8d7da
    style COMPUTE fill:#fff4e1
    style GSP fill:#fff4e1
    style RESULT fill:#fff4e1
</pre>
<p><strong>3. Performance Considerations:</strong></p>
<ul>
<li><strong>Latency impact:</strong> Quality score lookup adds ~0.5-1ms to auction (cache hit)</li>
<li><strong>Cache warming:</strong> Pre-compute scores for active advertisers (99%+ hit rate)</li>
<li><strong>Fallback:</strong> Default quality score (e.g., 7/10) if cache miss</li>
<li><strong>Update frequency:</strong> Quality scores change slowly (update daily, not per-auction)</li>
</ul>
<p><strong>4. ML Model Deployment:</strong></p>
<ul>
<li><strong>Training data:</strong> Billions of historical auctions (click events, landing page metrics)</li>
<li><strong>Features:</strong> Ad-keyword relevance (NLP embeddings), historical CTR, page speed metrics</li>
<li><strong>Model serving:</strong> Offline batch prediction, not real-time inference (too slow for auction latency)</li>
<li><strong>A/B testing:</strong> Shadow scoring to test model changes before production</li>
</ul>
<p><strong>Relationship to GSP:</strong></p>
<p>Quality-adjusted GSP is still a second-price auction:</p>
<ul>
<li>Rank by: Bid × CTR × Quality Score</li>
<li>Pay: Just enough to beat next advertiser (accounting for quality difference)</li>
</ul>
<p>The fundamental GSP property (not truthful, but Nash equilibrium exists) still holds.</p>
<h3 id="computational-complexity">Computational Complexity</h3>
<p><strong>GSP Auction Complexity:</strong></p>
<ul>
<li>Sort advertisers by eCPM: \(O(N \log N)\)</li>
<li>Select winner and compute price: \(O(1)\)</li>
<li><strong>Total: \(O(N \log N)\)</strong></li>
</ul>
<p><strong>VCG Auction Complexity:</strong></p>
<ul>
<li>Compute optimal allocation: \(O(N \log N)\)</li>
<li>Compute counterfactual allocations (\(N\) times): \(O(N^2 \log N)\)</li>
<li><strong>Total: \(O(N^2 \log N)\)</strong></li>
</ul>
<p>For \(N = 50\) DSPs:</p>
<ul>
<li>GSP: ~282 operations</li>
<li>VCG: ~14,100 operations</li>
</ul>
<p><strong>Latency Impact:</strong></p>
<p>At 5ms budget for auction logic:</p>
<ul>
<li>GSP: easily achievable</li>
<li>VCG: may require optimization or approximation</li>
</ul>
<p><strong>Recommendation:</strong> Use GSP for real-time auctions, reserve VCG for offline allocation optimization.</p>
<h3 id="reserve-prices-and-floor-prices">Reserve Prices and Floor Prices</h3>
<p><strong>The Problem:</strong></p>
<p>Without a reserve price (minimum bid), your auction might sell ad slots for pennies when competition is low. Consider a scenario where only one advertiser bids $0.10 for a premium slot - you’d rather show a house ad (promoting your own content) than sell it that cheaply.</p>
<p><strong>What is a Reserve Price?</strong></p>
<p>A <strong>reserve price</strong> \(r\) is the minimum eCPM required to participate in the auction. If no bids exceed \(r\), the impression is not sold (or filled with a house ad).</p>
<p><strong>The Revenue Trade-off:</strong></p>
<p>Setting the reserve price is a balancing act:</p>
<style>
#tbl_6 + table th:first-of-type  { width: 15%; }
#tbl_6 + table th:nth-of-type(2) { width: 40%; }
#tbl_6 + table th:nth-of-type(3) { width: 45%; }
</style>
<div id="tbl_6"></div>
<table><thead><tr><th>Reserve Price</th><th>What Happens</th><th>Example</th></tr></thead><tbody>
<tr><td>Too low<br/>($0.50)</td><td>Sell almost all impressions, but accept low-value bids</td><td>95% fill rate × $0.80 avg eCPM = $0.76 revenue per impression</td></tr>
<tr><td>Optimal<br/>($2.00)</td><td>Balance between fill rate and price</td><td>70% fill rate × $3.50 avg eCPM = $2.45 revenue per impression</td></tr>
<tr><td>Too high<br/>($10.00)</td><td>Only premium bids qualify, but most impressions go unsold</td><td>20% fill rate × $12.00 avg eCPM = $2.40 revenue per impression</td></tr>
</tbody></table>
<p><strong>Mathematical Formulation:</strong></p>
<p>Expected revenue per impression with reserve price \(r\):</p>
<p>$$\text{Revenue}(r) = r \times P(\text{bid} \geq r)$$</p>
<p>where \(P(\text{bid} \geq r)\) is the probability that at least one bid exceeds the reserve.</p>
<p><strong>Optimal Reserve Price:</strong></p>
<p>Find \(r^*\) that maximizes expected revenue. If bids follow a known distribution with CDF \(F(v)\):</p>
<p>$$r^* = \arg\max_r \left[ r \times (1 - F(r)) \right]$$</p>
<p><strong>Interpretation:</strong></p>
<ul>
<li>\(r\) = revenue when impression sells</li>
<li>\((1 - F(r))\) = probability impression sells (fraction of bids above \(r\))</li>
</ul>
<p><strong>Concrete Example:</strong></p>
<p>Suppose historical bids range uniformly from $0 to $10. What’s the optimal reserve?</p>
<p>For uniform distribution: \(P(\text{bid} \geq r) = 1 - \frac{r}{10}\)</p>
<p>Expected revenue:
$$\text{Revenue}(r) = r \times \left(1 - \frac{r}{10}\right) = r - \frac{r^2}{10}$$</p>
<p>Maximize by taking derivative:
$$\frac{d}{dr}\left(r - \frac{r^2}{10}\right) = 1 - \frac{2r}{10} = 0$$</p>
<p>$$r^* = \frac{10}{2} = \$5.00$$</p>
<p><strong>Result:</strong> Optimal reserve is half the maximum bid value (when bids are uniformly distributed).</p>
<p><strong>Practical Approach:</strong></p>
<p>Rather than assuming a distribution, use empirical data:</p>
<ul>
<li>Analyze historical bid distribution from past auctions</li>
<li>Set reserve at 40th-60th percentile of historical bids</li>
<li>A/B test different reserve prices and measure actual revenue impact</li>
<li>Adjust dynamically based on inventory quality (premium placements → higher reserve)</li>
</ul>
<p><strong>System Design Implications:</strong></p>
<p><strong>1. Where to Apply Reserve Price in Auction Pipeline:</strong></p>
<pre class="mermaid">
    
    graph LR
    START["Receive Bids<br/>N advertisers"]
    ECPM["Calculate eCPM<br/>Bid × CTR × 1000"]
    FILTER["Reserve Price Filter<br/>Remove if eCPM &lt; reserve_price<br/>Linear scan"]
    RANK["Rank by eCPM<br/>Sort qualified bids"]
    GSP["Run GSP Pricing<br/>Second-price calculation"]
    RESULT["Return Winner<br/>or No Fill"]

    START --> ECPM
    ECPM --> FILTER
    FILTER --> RANK
    RANK --> GSP
    GSP --> RESULT

    style START fill:#e1f5ff
    style ECPM fill:#fff4e1
    style FILTER fill:#fffacd
    style RANK fill:#fff4e1
    style GSP fill:#fff4e1
    style RESULT fill:#d4edda
</pre>
<p><strong>Performance:</strong> Reserve price filtering is O(N) linear scan, negligible latency (&lt;0.01ms for typical N &lt; 1000 bids).</p>
<p><strong>2. Reserve Price Storage and Lookup:</strong></p>
<p><strong>Multi-dimensional pricing:</strong> Segment reserves by ad unit, geography, device type, time of day, user segment (e.g., US desktop: $4.00 vs India mobile: $0.50).</p>
<p><strong>Caching strategy:</strong></p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Reserve Price Lookup:
</span><span>  - L1: In-memory map (&lt; 0.1ms latency)
</span><span>  - L2: Redis cache (updated hourly)
</span><span>  - L3: Database fallback
</span><span>  - Default: Hardcoded minimum if all fail
</span></code></pre>
<p><strong>Storage key:</strong> <code>reserve_{ad_unit}_{geo}_{device}_{hour_of_day}</code> with hierarchical fallback (specific → general).</p>
<p><strong>3. Dynamic Reserve Price Optimization:</strong></p>
<p><strong>Offline optimization service (runs hourly):</strong></p>
<ul>
<li>Pull last 24h bid data from analytics DB</li>
<li>Segment by dimensions (ad unit, geo, device, hour)</li>
<li>Calculate optimal reserve \(r^*\) per segment: maximize \(r \times P(\text{bid} \geq r)\)</li>
<li>Update Redis cache with new reserves</li>
<li>Monitor revenue impact vs baseline</li>
</ul>
<p><strong>4. Operational Considerations:</strong></p>
<p><strong>Testing:</strong> A/B test reserve price changes (7-day minimum for weekly seasonality), adopt if revenue lift &gt;2%.</p>
<p><strong>Failure handling:</strong> Use last-known value if cache miss (balances revenue and reliability).</p>
<p><strong>Monitoring:</strong> Track fill rate, revenue per impression, cache hit rate (&gt;99% target), auction latency p99.</p>
<h3 id="industry-evolution-first-price-auctions">Industry Evolution: First-Price Auctions</h3>
<p><strong>Historical Context:</strong></p>
<p>The GSP and VCG mechanisms discussed above are <strong>second-price auctions</strong> - winners pay less than their bid. However, the programmatic advertising industry underwent a major shift in 2019.</p>
<p><strong>The Transition:</strong></p>
<style>
#tbl_first_second + table th:first-of-type  { width: 20%; }
#tbl_first_second + table th:nth-of-type(2) { width: 40%; }
#tbl_first_second + table th:nth-of-type(3) { width: 40%; }
</style>
<div id="tbl_first_second"></div>
<table><thead><tr><th>Period</th><th>Dominant Mechanism</th><th>Context</th></tr></thead><tbody>
<tr><td>Pre-2015</td><td>Second-price (GSP)</td><td>Google pioneered GSP for sponsored search</td></tr>
<tr><td>2015-2018</td><td>Modified second-price</td><td>Exchanges added floors, modified pricing rules</td></tr>
<tr><td>2019-Present</td><td>First-price</td><td>Google AdX completed transition (Sept 2019)</td></tr>
</tbody></table>
<p><strong>What Changed:</strong></p>
<p><strong>Second-Price (GSP):</strong></p>
<ul>
<li>Winner pays \(p = \frac{\text{eCPM}_{2nd}}{\text{CTR}_w \times 1000} + \epsilon\)</li>
<li>Bid shading unnecessary (closer to truthful bidding)</li>
</ul>
<p><strong>First-Price:</strong></p>
<ul>
<li>Winner pays their actual bid: \(p = b_w\)</li>
<li>Requires bid shading (bidders must estimate optimal bid below true value)</li>
</ul>
<p><strong>Why the Shift? Header Bidding and Transparency</strong></p>
<p><strong>Header bidding</strong> (publisher-side unified auctions) exposed inconsistencies: exchanges used “modified second-price” with hidden rules (secret floors, varying increments), making it impossible for publishers to compare prices fairly.</p>
<p><strong>Solution:</strong> First-price auctions for transparency—winner pays exactly their bid, no hidden modifications.</p>
<p><strong>Impact on Bidders: Bid Shading Required</strong></p>
<p>First-price requires strategic bidding. Bidding true value \(v\) yields zero profit, so bidders shade: \(b_i = v_i - s(v_i, \text{market})\) where \(s(\cdot)\) is learned via ML.</p>
<p><strong>Example:</strong> True value $10, estimated second-highest $7 → bid ~$7.50 → profit $2.50 if win.</p>
<p><strong>Modern Practice (2025):</strong></p>
<style>
#tbl_modern + table th:first-of-type  { width: 30%; }
#tbl_modern + table th:nth-of-type(2) { width: 35%; }
#tbl_modern + table th:nth-of-type(3) { width: 35%; }
</style>
<div id="tbl_modern"></div>
<table><thead><tr><th>Auction Type</th><th>Used For</th><th>Rationale</th></tr></thead><tbody>
<tr><td>Second-Price (GSP)</td><td>Sponsored search (Google Search Ads)</td><td>Established ecosystem, simpler for advertisers</td></tr>
<tr><td>First-Price</td><td>Programmatic display/video (Google AdX, Prebid)</td><td>Transparency for header bidding</td></tr>
</tbody></table>
<p><strong>Implementation Considerations:</strong></p>
<table><thead><tr><th>Factor</th><th>Second-Price (GSP)</th><th>First-Price</th></tr></thead><tbody>
<tr><td>Bidder strategy</td><td>Closer to truthful</td><td>Requires bid shading (ML)</td></tr>
<tr><td>Transparency</td><td>Hidden pricing logic</td><td>Winner pays bid (transparent)</td></tr>
<tr><td>Complexity</td><td>Simpler for bidders</td><td>Simpler for publishers</td></tr>
<tr><td>Use case</td><td>Search ads (industry standard)</td><td>Programmatic display/video (post-2019)</td></tr>
</tbody></table>
<p><strong>This document focuses on GSP</strong> because it’s the foundation of sponsored search and has richer game-theoretic properties (Nash equilibria, LEFE, VCG comparison). First-price is mechanically simpler (winner pays bid) but requires bidder-side ML for shading.</p>
<hr />
<h2 id="part-7-advanced-topics">Part 7: Advanced Topics</h2>
<div class="part-toc">
<div class="part-toc-header">
<div class="part-toc-title">In this part:</div>
</div>
<ul>
<li><a href="#budget-pacing-distributed-spend-control">Budget Pacing: Distributed Spend Control</a>
<span class="part-toc-desc">Pre-allocation, atomic counters, over-delivery prevention</span></li>
<li><a href="#fraud-detection-pattern-based-abuse-detection">Fraud Detection: Pattern-Based Abuse Detection</a>
<span class="part-toc-desc">Bot detection, click fraud, anomaly detection</span></li>
<li><a href="#multi-region-deployment-and-failover">Multi-Region Deployment and Failover</a>
<span class="part-toc-desc">Active-active architecture, data replication, regional failover</span></li>
<li><a href="#schema-evolution-zero-downtime-data-migration">Schema Evolution: Zero-Downtime Data Migration</a>
<span class="part-toc-desc">Backward compatibility, dual-write patterns, migration strategies</span></li>
<li><a href="#distributed-clock-synchronization-and-time-consistency">Distributed Clock Synchronization and Time Consistency</a>
<span class="part-toc-desc">NTP, TrueTime, timestamp ordering</span></li>
<li><a href="#global-event-ordering-for-financial-ledgers-the-external-consistency-challenge">Global Event Ordering for Financial Ledgers</a>
<span class="part-toc-desc">Spanner-style consistency, transaction ordering, audit trails</span></li>
</ul>

<div class="part-toc-nav">

    <a href="#part-6-auction-mechanism-design" class="prev-part-link"><i class="fa fa-angle-double-up"></i> Part 6: Auction Mechanism Design</a>


    <a href="#part-8-observability-and-operations" class="next-part-link">Part 8: Observability and Operations <i class="fa fa-angle-double-down"></i></a>

</div>

</div>
<h3 id="budget-pacing-distributed-spend-control">Budget Pacing: Distributed Spend Control</h3>
<blockquote>
<p><strong>Architectural Driver: Financial Accuracy</strong> - Pre-allocation pattern with Redis atomic counters ensures budget consistency across regions. Max over-delivery bounded to 1% of daily budget (acceptable legal risk) while avoiding centralized bottleneck.</p>
</blockquote>
<p><strong>Problem:</strong> Advertisers set daily budgets (e.g., $10,000/day). In a distributed system serving 1M QPS, how do we prevent over-delivery without centralizing every spend decision?</p>
<p><strong>Challenge:</strong></p>
<p>Centralized approach (single database tracks spend):</p>
<ul>
<li>Latency: ~10ms per spend check</li>
<li>Throughput bottleneck: ~100K QPS max</li>
<li>Single point of failure</li>
</ul>
<p><strong>Solution: Pre-Allocation with Periodic Reconciliation</strong></p>
<pre class="mermaid">
    
    graph TD
    ADV[Advertiser X<br/>Daily Budget: $10,000]

    ADV --> BUDGET[Budget Controller]

    BUDGET --> REDIS[(Redis<br/>Atomic Counters)]
    BUDGET --> CRDB[(CockroachDB<br/>Billing Ledger<br/>HLC Timestamps)]

    BUDGET -->|Allocate $50| AS1[Ad Server 1]
    BUDGET -->|Allocate $75| AS2[Ad Server 2]
    BUDGET -->|Allocate $100| AS3[Ad Server 3]

    AS1 -->|Spent: $42<br/>Return: $8| BUDGET
    AS2 -->|Spent: $68<br/>Return: $7| BUDGET
    AS3 -->|Spent: $95<br/>Return: $5| BUDGET

    BUDGET -->|Periodic reconciliation<br/>HLC timestamped| CRDB

    TIMEOUT[Timeout Monitor<br/>5min intervals] -.->|Release stale<br/>allocations| REDIS

    REDIS -->|Budget < 10%| THROTTLE[Dynamic Throttle]
    THROTTLE -.->|Reduce allocation<br/>size $100→$10| BUDGET

    classDef server fill:#e3f2fd,stroke:#1976d2
    classDef budget fill:#fff3e0,stroke:#f57c00
    classDef advertiser fill:#e8f5e9,stroke:#4caf50

    class AS1,AS2,AS3 server
    class BUDGET,REDIS,CRDB,TIMEOUT,THROTTLE budget
    class ADV advertiser
</pre>
<p><strong>Budget Allocation Algorithm:</strong></p>
<p>The core algorithm has three operations:</p>
<p><strong>1. Request Allocation:</strong></p>
<ul>
<li>Ad server requests budget chunk (e.g., $100) from centralized Budget Controller</li>
<li>Controller atomically decrements remaining budget using Redis <code>DECRBY</code> (prevents race conditions)</li>
<li>If budget is low (&lt;10% remaining), reduce allocation size to prevent over-delivery</li>
<li>Log allocation to CockroachDB billing ledger with automatic HLC timestamp</li>
<li>Return allocated amount (or 0 if budget exhausted)</li>
</ul>
<p><strong>2. Report Spend:</strong></p>
<ul>
<li>Ad server reports actual spend after serving ads</li>
<li>If <code>actual &lt; allocated</code>, return unused portion via Redis <code>INCRBY</code></li>
<li>Log actual spend to CockroachDB billing ledger for reconciliation with HLC timestamp</li>
<li>Example: Allocated $100, spent $87 → return $13 to budget pool</li>
</ul>
<p><strong>3. Timeout Monitor (Background):</strong></p>
<ul>
<li>Every 5 minutes, scan for allocations older than 10 minutes with no spend report</li>
<li>These likely represent crashed servers holding budget hostage</li>
<li>Automatically return their allocations to the budget pool via <code>INCRBY</code></li>
<li>Prevents budget being permanently locked by failed servers</li>
</ul>
<p><strong>Key design decisions:</strong></p>
<ul>
<li><strong>Redis for speed</strong>: Atomic counters provide strong consistency with &lt;1ms latency</li>
<li><strong>CockroachDB for billing ledger</strong>: HLC timestamps ensure global event ordering across regions, enables billing reconciliation with chronological accuracy</li>
<li><strong>Pre-allocation strategy</strong>: Servers get budget chunks upfront, avoiding per-request latency</li>
<li><strong>Dynamic sizing</strong>: Reduce allocation chunks when budget is low to minimize over-delivery risk</li>
</ul>
<p><strong>Mathematical Analysis:</strong></p>
<p><strong>Over-Delivery Bound:</strong></p>
<p>Maximum over-delivery: $$\text{OverDelivery}_{max} = S \times A$$</p>
<p>where \(S\) = number of servers, \(A\) = allocation chunk size.</p>
<p><strong>Example:</strong> 100 servers with $100 allocation each → <strong>max $10,000 over-delivery</strong> (10% of $100K daily budget).</p>
<p><strong>Mitigation:</strong> Dynamic allocation sizing.</p>
<p>When budget remaining drops below 10%:
$$A_{new} = \frac{B_r}{S \times 10}$$</p>
<p>This reduces max over-delivery to <strong>~1% of budget</strong>.</p>
<h3 id="fraud-detection-pattern-based-abuse-detection">Fraud Detection: Pattern-Based Abuse Detection</h3>
<blockquote>
<p><strong>Architectural Driver: Financial Accuracy</strong> - While rate limiting (Part 2) controls request <strong>volume</strong>, fraud detection identifies <strong>malicious patterns</strong>. A bot clicking 5 ads/minute might pass rate limits but shows suspicious behavioral patterns. Both mechanisms work together: rate limiting stops volume abuse, fraud detection stops sophisticated attacks.</p>
</blockquote>
<p><strong>What Fraud Detection Does (vs Rate Limiting):</strong></p>
<p><strong>Fraud detection</strong> answers: <strong>“Are you malicious?”</strong></p>
<ul>
<li>Bot farm with 95% CTR, uniform timing, rotating IPs → blocked permanently</li>
<li>Protects advertiser budgets from wasted spend ($500K-1M/year losses)</li>
</ul>
<p><strong>Rate limiting</strong> answers: <strong>“Are you requesting too much?”</strong> (see Part 2: Rate Limiting)</p>
<ul>
<li>Legitimate advertiser making 10K QPS (vs 1K limit) → throttled with 429</li>
<li>Protects infrastructure capacity and enforces SLA</li>
</ul>
<p><strong>Problem:</strong> Detect and block fraudulent ad clicks in real-time without adding significant latency.</p>
<p><strong>Fraud Types:</strong></p>
<ol>
<li><strong>Click Farms:</strong> Bots or paid humans generating fake clicks</li>
<li><strong>SDK Spoofing:</strong> Fake app installations reporting ad clicks</li>
<li><strong>Domain Spoofing:</strong> Fraudulent publishers misrepresenting site content</li>
<li><strong>Ad Stacking:</strong> Multiple ads layered, only top visible but all “viewed”</li>
</ol>
<p><strong>Detection Strategy: Multi-Tier Filtering</strong></p>
<pre class="mermaid">
    
    graph TB
    REQ[Ad Request/Click] --> L1{L1: Simple Rules<br/>0ms overhead}

    L1 -->|Known bad IP| BLOCK1[Block<br/>Bloom Filter]
    L1 -->|Pass| L2{L2: Behavioral<br/>5ms latency}

    L2 -->|Suspicious pattern| PROB[Probabilistic Block<br/>50% traffic]
    L2 -->|Pass| L3{L3: ML Model<br/>Async, 20ms}

    L3 -->|Fraud score > 0.8| BLOCK3[Post-Facto Block<br/>Refund advertiser]
    L3 -->|Pass| SERVE[Serve Ad]

    PROB --> SERVE
    SERVE -.->|Log for analysis| OFFLINE[Offline Analysis<br/>Update models]

    OFFLINE -.->|Update rules| L1
    OFFLINE -.->|Retrain model| L3

    classDef block fill:#ffcccc,stroke:#cc0000
    classDef pass fill:#ccffcc,stroke:#00cc00
    classDef async fill:#ffffcc,stroke:#cccc00

    class BLOCK1,BLOCK3 block
    class SERVE pass
    class L3,OFFLINE async
</pre>
<p><strong>L1: Simple Rules (Bloom Filter)</strong></p>
<p>At 1M+ QPS, checking every request against a blocklist of 100K+ fraudulent IPs requires space-efficient data structures. Bloom filters provide 100× space savings (1.25 MB vs ~128 MB for hash tables) with sub-microsecond lookups and zero false negatives. The 0.01% false positive rate is acceptable - flagged legitimate users pass through to L2 behavioral checks.</p>
<p>$$P_{fp} = \left(1 - e^{-kn/m}\right)^k$$</p>
<p><strong>Configuration:</strong> 10⁷ bits (1.25 MB), 100K IPs, 7 hash functions → 0.01% false positive rate.</p>
<p><strong>L2: Behavioral Detection (&lt;5ms latency)</strong></p>
<p>Sophisticated fraudsters rotate IPs to evade L1. Rule-based heuristics catch ~70% of remaining fraud through weighted scoring:</p>
<table><thead><tr><th>Signal</th><th>Normal</th><th>Suspicious</th><th>Weight</th><th>Implementation</th></tr></thead><tbody>
<tr><td><strong>Click rate</strong></td><td>&lt;10/min</td><td>&gt;30/min</td><td>0.4</td><td>Redis sorted sets (ZCOUNT)</td></tr>
<tr><td><strong>CTR</strong></td><td>1-3%</td><td>&gt;50%</td><td>0.25</td><td>Historical click/impression ratio</td></tr>
<tr><td><strong>User agent switching</strong></td><td>1-2 UAs</td><td>5+ UAs from same IP</td><td>0.2</td><td>Bloom filter per IP</td></tr>
<tr><td><strong>Geo inconsistency</strong></td><td>IP/lang match</td><td>US IP + Chinese lang</td><td>0.15</td><td>GeoIP + browser headers</td></tr>
</tbody></table>
<p>Composite score &gt;0.6 triggers probabilistic blocking (serve 50% traffic). Each signal computes in &lt;1ms; total overhead ~5ms. ML models (L3) are too slow (20ms+) for synchronous blocking.</p>
<p><strong>L3: ML-Based Fraud Score (Async, 20ms)</strong></p>
<p>Gradient Boosted Trees (LightGBM) model with 50+ features: device fingerprint entropy, click timestamp distribution (uniform=bot, bursty=human), network characteristics (ASN, hosting providers), historical fraud rates, engagement metrics (time on page, scroll depth).</p>
<p><strong>Class imbalance handling (~1% fraud rate):</strong></p>
<ul>
<li>Class weighting (99:1 ratio) to penalize false negatives heavily</li>
<li>SMOTE oversampling to generate synthetic fraud examples (1% → 10% of training data)</li>
</ul>
<p><strong>Deployment:</strong> Runs asynchronously after ad serving (no latency impact). If fraud detected post-facto: refund advertiser, block device.</p>
<p><strong>Cost optimization:</strong></p>
<p>$$\text{Cost} = C_{fp} \times FP + C_{fn} \times FN$$</p>
<p>Where \(C_{fn}\) (advertiser refund ~$5.00) \(\gg C_{fp}\) (lost revenue ~$0.50). Model optimizes for low false negative rate, accepting higher false positives.</p>
<h3 id="multi-region-deployment-and-failover">Multi-Region Deployment and Failover</h3>
<blockquote>
<p><strong>Architectural Driver: Availability</strong> - Multi-region deployment with 20% standby capacity ensures we survive full regional outages (1 hour outage = $1M revenue loss). Auto-failover within 90 seconds minimizes impact.</p>
</blockquote>
<p><strong>Why Multi-Region:</strong></p>
<p><strong>Business drivers:</strong></p>
<ol>
<li>
<p><strong>Latency requirements</strong>: Sub-100ms p95 latency is physically impossible with single region serving global traffic. Speed of light: US-East to EU = ~80ms one-way, already consuming 80% of our budget. Regional presence required.</p>
</li>
<li>
<p><strong>Availability</strong>: Single-region architecture has single point of failure. AWS historical data: major regional outages occur 1-2 times per year, averaging 2-4 hours. Single outage can cost multiple days worth of revenue (context: 2-4 hour regional outage at $1M/hour revenue rate = $2-4M loss for a scaled platform serving 1M QPS).</p>
</li>
<li>
<p><strong>Regulatory compliance</strong>: GDPR requires EU user data stored in EU. Multi-region enables data locality compliance.</p>
</li>
<li>
<p><strong>User distribution</strong>: for example 60% US, 20% Europe, 15% Asia, 5% other. Serving from nearest region reduces latency 50-100ms.</p>
</li>
</ol>
<p><strong>Normal Multi-Region Operation:</strong></p>
<p><strong>Region allocation (Active-Passive Model):</strong></p>
<table><thead><tr><th>Region</th><th>User Base</th><th>Normal Traffic</th><th>Role</th><th>Capacity</th></tr></thead><tbody>
<tr><td>US-East-1</td><td>40%</td><td>400K QPS</td><td>Primary US</td><td>100% + 20% standby</td></tr>
<tr><td>US-West-2</td><td>20%</td><td>200K QPS</td><td>Secondary US</td><td>100% + 20% standby</td></tr>
<tr><td>EU-West-1</td><td>30%</td><td>300K QPS</td><td>EU Primary</td><td>100% + 20% standby</td></tr>
<tr><td>AP-Southeast-1</td><td>10%</td><td>100K QPS</td><td>Asia Primary</td><td>100% + 20% standby</td></tr>
</tbody></table>
<p><strong>Deployment model:</strong> Active-passive within region pairs. Each region serves local users (lowest latency), can handle overflow from neighbor region (geographic redundancy), but cannot handle full global traffic (cost prohibitive).</p>
<p><strong>Trade-off accepted:</strong> 20% standby insufficient for full regional takeover, but enables graceful degradation. Full redundancy (200% capacity per region) would triple infrastructure costs.</p>
<p><strong>Traffic Routing &amp; DNS:</strong></p>
<p><strong>Global load balancing:</strong> AWS Route53 with geolocation-based routing + health checks.</p>
<p><strong>Normal operation:</strong></p>
<ul>
<li>User in New York → routed to US-East-1 (10-15ms latency)</li>
<li>User in London → routed to EU-West-1 (5-10ms latency)</li>
<li>User in Singapore → routed to AP-Southeast-1 (8-12ms latency)</li>
</ul>
<p><strong>Health check mechanism:</strong></p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Route53 Health Check Configuration:
</span><span>- Protocol: HTTPS
</span><span>- Path: /health/deep (checks database connectivity, not just &quot;alive&quot;)
</span><span>- Interval: 30 seconds (Standard, $0.50/month) or 10 seconds (Fast, $1.00/month)
</span><span>- Failure threshold: 3 consecutive failures
</span><span>- Health checkers: 15+ global endpoints
</span><span>- Decision: Healthy if ≥18% of checkers report success
</span></code></pre>
<p><strong>Failover trigger:</strong> When health checks fail for 90 seconds (3 × 30s interval), Route53 marks region unhealthy and returns secondary region’s IP for DNS queries.</p>
<p><strong>DNS TTL impact:</strong> Set to 60 seconds. After failover triggered, new DNS queries immediately return healthy region, existing client DNS caches expire within 60s (50% of clients fail over in 30s, 95% within 90s).</p>
<p><strong>Why 60s TTL:</strong> Balance between fast failover and DNS query load. Lower TTL (10s) = 6× more DNS queries hitting Route53 nameservers. At high query volumes, this increases costs ($0.40 per million queries), but the primary concern is cache efficiency - shorter TTLs mean resolvers cache records for less time, reducing effectiveness of DNS caching infrastructure.</p>
<p><strong>Health check vs TTL costs:</strong> Note that health check intervals (10s vs 30s) have different pricing: $1.00/month vs $0.50/month per check. The 6× query multiplier applies to DNS resolution, not health checks.</p>
<p><strong>Data Replication Strategy:</strong></p>
<p><strong>CockroachDB (Billing Ledger, User Profiles):</strong></p>
<p>Multi-region deployment with 5 replicas distributed across regions:</p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Table: billing_ledger
</span><span>Replicas: 5 (2 in US-East, 1 in US-West, 1 in EU-West, 1 in AP-Southeast)
</span><span>Survival goal: &quot;zone&quot; (survives AZ failure)
</span><span>Leaseholder preference: &quot;closest&quot; (reads hit nearest replica)
</span></code></pre>
<p><strong>Why 5 replicas:</strong> Survives any single region failure with quorum (5 → 3 remain). Write quorum = 3 replicas, so can lose up to 2.</p>
<p><strong>Write path:</strong> Write acknowledged when 3/5 replicas confirm (Raft consensus). Typical cross-region write latency: 50-150ms (dominated by inter-region network).</p>
<p><strong>Read path:</strong> Served by nearest replica with bounded staleness (default: 4.8s max staleness for follower reads). Strong-consistency reads go to leaseholder.</p>
<p><strong>Redis (Budget Pre-Allocation, User Sessions):</strong></p>
<p><strong>CRITICAL ARCHITECTURAL DECISION:</strong> Redis does NOT replicate across regions in this design.</p>
<p><strong>Why no cross-region Redis replication:</strong></p>
<ol>
<li><strong>Latency</strong>: Redis replication is synchronous or asynchronous. Synchronous = 50-100ms write latency (violates our &lt;1ms budget enforcement requirement). Asynchronous = data loss during failover.</li>
<li><strong>Complexity</strong>: Redis Cluster cross-region replication requires custom solutions (RedisLabs, custom scripts).</li>
<li><strong>Acceptable trade-off</strong>: Budget pre-allocations are already bounded loss (see below).</li>
</ol>
<p><strong>Each region has independent Redis:</strong></p>
<ul>
<li>US-East Redis: Stores budget pre-allocations for campaigns served in US-East</li>
<li>EU-West Redis: Independent budget allocations for EU campaigns</li>
<li>No cross-region replication</li>
</ul>
<p><strong>Data Consistency During Regional Failover (CRITICAL):</strong></p>
<p><strong>The Budget Counter Problem:</strong> When US-East fails, what happens to budget allocations stored in US-East Redis?</p>
<p><strong>Example scenario:</strong></p>
<ul>
<li>Campaign daily budget: $10,000</li>
<li>US-East pre-allocated: $3,000 (stored in US-East Redis)</li>
<li>US-West pre-allocated: $4,000 (stored in US-West Redis)</li>
<li>EU-West pre-allocated: $3,000 (stored in EU-West Redis)</li>
<li>US-East fails at 2pm, having spent $1,500 of its $3,000</li>
</ul>
<p><strong>What happens:</strong></p>
<ol>
<li><strong>Immediate impact:</strong> $1,500 remaining in US-East Redis is lost (region unavailable)</li>
<li><strong>US-West takes over US-East traffic:</strong> Continues spending from its own $4,000 allocation</li>
<li><strong>Bounded over-delivery:</strong> Max over-delivery = lost US-East allocation = $1,500</li>
<li><strong>Percentage impact:</strong> $1,500 / $10,000 = <strong>15% over-delivery</strong> (exceeds our 1% target!)</li>
</ol>
<p><strong>Mitigation: CockroachDB-backed allocation tracking (implemented)</strong></p>
<p>Every 60 seconds, each region writes actual spend to CockroachDB:</p>
<pre data-lang="sql" style="background-color:#fafafa;color:#383a42;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#a0a1a7;">-- US-East writes every 60s (while healthy)
</span><span style="color:#a626a4;">UPDATE</span><span> campaign_budget
</span><span style="color:#a626a4;">SET</span><span> us_east_allocated </span><span style="color:#a626a4;">= </span><span style="color:#c18401;">3000</span><span>,
</span><span>    us_east_spent </span><span style="color:#a626a4;">= </span><span style="color:#c18401;">1500</span><span>,
</span><span>    last_heartbeat_us_east </span><span style="color:#a626a4;">=</span><span> now()
</span><span style="color:#a626a4;">WHERE</span><span> campaign_id </span><span style="color:#a626a4;">= </span><span style="color:#50a14f;">&#39;camp_123&#39;</span><span>;
</span></code></pre>
<p><strong>Failover recovery process:</strong></p>
<ol>
<li><strong>T+0s:</strong> US-East fails</li>
<li><strong>T+90s:</strong> Health checks trigger failover, US-West starts receiving US-East traffic</li>
<li><strong>T+120s:</strong> Budget Controller detects US-East heartbeat timeout (last write was 120s ago)</li>
<li><strong>T+120s:</strong> Budget Controller reads last known state from CockroachDB:
<ul>
<li>US-East allocated: $3,000</li>
<li>US-East spent: $1,500 (written 120s ago)</li>
<li>Remaining (uncertain): ~$1,500</li>
</ul>
</li>
<li><strong>T+120s:</strong> Budget Controller marks US-East allocation as “failed” and removes from available budget</li>
<li><strong>Result:</strong> $1,500 locked but not over-delivered</li>
</ol>
<p><strong>Bounded under-delivery:</strong> Max under-delivery = unspent allocation in failed region = $1,500 = 15% of budget.</p>
<p><strong>Why under-delivery is acceptable:</strong></p>
<ul>
<li>Advertiser complaint: “I paid for $10K, only got $8.5K” → refund $1.5K</li>
<li>Better than over-delivery: “I paid for $10K, you charged me $11.5K” → lawsuit</li>
</ul>
<p><strong>Failure Scenario: US-East Regional Outage</strong></p>
<p><strong>Scenario:</strong> Primary region (US-East) fails, handling 40% of traffic. What happens?</p>
<p><strong>Failover Timeline:</strong></p>
<style>
#tbl_7 + table th:first-of-type  { width: 10%; }
#tbl_7 + table th:nth-of-type(2) { width: 45%; }
#tbl_7 + table th:nth-of-type(3) { width: 45%; }
</style>
<div id="tbl_7"></div>
<table><thead><tr><th>Time</th><th>Event</th><th>System State</th></tr></thead><tbody>
<tr><td>T+0s</td><td>Health check failures detected</td><td>DNS TTL delay (60s)</td></tr>
<tr><td>T+30s</td><td>3× traffic hits US-West</td><td>CPU: 40%→85%, standby activated</td></tr>
<tr><td>T+60s</td><td>Auto-scaling triggered</td><td>Provisioning new capacity</td></tr>
<tr><td>T+90s</td><td>Cache hit degradation</td><td>Latency p95: 100ms→150ms</td></tr>
<tr><td>T+90s</td><td>Route53 marks US-East unhealthy</td><td>DNS failover begins</td></tr>
<tr><td>T+120s</td><td>Budget Controller locks US-East allocations</td><td>Under-delivery protection active</td></tr>
<tr><td>T+150-180s</td><td>New instances online</td><td>Capacity restored (90-120s provisioning delay)</td></tr>
</tbody></table>
<p><strong>Why 20% Standby is Insufficient:</strong></p>
<p>The timeline above shows a critical problem: from T+30s to T+180s (up to 150 seconds), US-West is severely overloaded. To understand why, we need queueing theory.</p>
<p><strong>Capacity Analysis:</strong></p>
<p>Server utilization in queueing theory:
$$\rho = \frac{\lambda}{c \mu}$$</p>
<p>where:</p>
<ul>
<li>\(\lambda\) = arrival rate (requests per second)</li>
<li>\(c\) = number of servers</li>
<li>\(\mu\) = service rate per server</li>
<li>\(\rho\) = utilization (0 to 1+ scale)</li>
</ul>
<p><strong>Critical thresholds:</strong></p>
<ul>
<li>\(\rho &lt; 0.8\): Stable operation, reasonable queue lengths</li>
<li>\(0.8 &lt; \rho &lt; 1.0\): Queues grow, latency increases</li>
<li>\(\rho \geq 1.0\): System unstable, queues grow unbounded</li>
</ul>
<p><strong>Normal operation (US-West):</strong></p>
<ul>
<li>Traffic: 200K QPS</li>
<li>Capacity: 300K QPS (with 20% standby)</li>
<li>\(\rho = 200K / 300K = 0.67\) ✓ Stable</li>
</ul>
<p><strong>During US-East failure (US-West receives 40% of total traffic):</strong></p>
<ul>
<li>Traffic: 200K + 400K = 600K QPS</li>
<li>Capacity: 300K QPS (20% standby already activated)</li>
<li>\(\rho = 600K / 300K = 2.0\) ✗ Severe overload</li>
</ul>
<p><strong>Auto-scaling limitations:</strong> Kubernetes HPA triggers at T+60s, but provisioning new capacity takes <strong>90-120 seconds</strong> for GPU-based ML inference nodes (instance boot + model loading into VRAM), as detailed in Part 6. During this window, the system operates at 2× over capacity, making graceful degradation essential.</p>
<p><strong>Mitigation: Graceful Degradation + Load Shedding</strong></p>
<blockquote>
<p><strong>Architectural Driver: Availability</strong> - During regional failures, graceful degradation (serving stale cache, shedding low-value traffic) maintains uptime while minimizing revenue impact. Better to serve degraded ads than no ads.</p>
</blockquote>
<p>The system employs a two-layer mitigation strategy detailed in Part 2:</p>
<p><strong>Layer 1: Service-Level Degradation (Circuit Breakers)</strong></p>
<ol>
<li><strong>ML Inference</strong>: Switch to cached CTR predictions (-8% revenue impact)</li>
<li><strong>User Profiles</strong>: Serve stale cache with 5-minute TTL (-5% impact)</li>
<li><strong>RTB Auction</strong>: Reduce to top 20 DSPs only (-6% impact)</li>
</ol>
<p><strong>Layer 2: Load Shedding (Utilization-Based)</strong></p>
<p>When utilization exceeds capacity despite degradation:</p>
<table><thead><tr><th>Utilization</th><th>Action</th><th>Logic</th></tr></thead><tbody>
<tr><td>&lt;70%</td><td>Accept all</td><td>Normal operation</td></tr>
<tr><td>70-90%</td><td>Accept all + degrade services</td><td>Circuit breakers active, auto-scaling triggered</td></tr>
<tr><td>&gt;90%</td><td>Value-based shedding</td><td>Accept high-value (&gt;P95), reject 50% of low-value</td></tr>
</tbody></table>
<p><strong>Combined impact during regional failover:</strong></p>
<ul>
<li>Service degradation: ~27% revenue reduction (see Part 2 Circuit Breaker section for details)</li>
<li>Load shedding (if needed): Reject 47.5% of lowest-value traffic, preserve 97.5% of remaining revenue</li>
<li><strong>Net result</strong>: System stays online, handles capacity constraint within 90-120s auto-scaling window</li>
</ul>
<p><strong>Failback Strategy:</strong></p>
<p>After US-East recovers, gradual traffic shift back:</p>
<p><strong>Automated steps:</strong></p>
<ol>
<li><strong>T+0:</strong> US-East infrastructure restored, health checks start passing</li>
<li><strong>T+5min:</strong> Route53 marks US-East healthy again, BUT weight set to 0%</li>
<li><strong>T+5min:</strong> Manual verification: Engineering team checks metrics, error rates</li>
<li><strong>T+10min:</strong> Traffic ramp begins: 5% → 10% → 25% → 50% → 100% over 30 minutes</li>
<li><strong>T+40min:</strong> Full traffic restored to US-East</li>
</ol>
<p><strong>Manual gates:</strong> Failback is semi-automatic. Requires manual approval at each stage to prevent cascade failures.</p>
<p><strong>Data reconciliation:</strong></p>
<p>CockroachDB: Already consistent (Raft consensus maintained across regions). Redis: Rebuild from scratch (Budget Controller re-allocates budgets based on CockroachDB source of truth, cold cache for 10-20 minutes).</p>
<p><strong>Why gradual failback:</strong> Prevents “split-brain” scenario where both regions think they’re primary.</p>
<p><strong>Cost Analysis: Multi-Region Economics</strong></p>
<p><strong>Infrastructure cost multipliers:</strong></p>
<table><thead><tr><th>Component</th><th>Single Region</th><th>Multi-Region (4 regions)</th><th>Multiplier</th></tr></thead><tbody>
<tr><td>Compute (ad servers, ML)</td><td>Baseline</td><td>3× baseline</td><td>3×</td></tr>
<tr><td>CockroachDB (5 replicas)</td><td>Baseline</td><td>3× baseline</td><td>3×</td></tr>
<tr><td>Redis (per region)</td><td>Baseline</td><td>3× baseline</td><td>3×</td></tr>
<tr><td>Cross-region data transfer</td><td>$0</td><td>30% of baseline</td><td>∞ (new cost, e.g., $0.02/GB)</td></tr>
<tr><td>Route53 (health checks)</td><td>Baseline</td><td>3× baseline</td><td>3×</td></tr>
<tr><td><strong>Total</strong></td><td><strong>Baseline</strong></td><td><strong>3.3× baseline</strong></td><td><strong>3.3×</strong></td></tr>
</tbody></table>
<p><strong>Cross-region data transfer breakdown:</strong></p>
<ul>
<li>CockroachDB replication: 5 replicas × request volume × average payload size</li>
<li>Metric/log aggregation: Centralized monitoring across regions</li>
<li>Backup replication: Cross-region redundancy</li>
</ul>
<p><strong>Key cost drivers:</strong></p>
<ul>
<li><strong>Linear scaling (3×)</strong>: Compute, databases, cache replicate fully per region</li>
<li><strong>New cost category</strong>: Cross-region data transfer (~30% of baseline compute costs)</li>
<li><strong>Marginal costs</strong>: DNS health checks scale linearly but are negligible</li>
</ul>
<p><strong>Economic justification:</strong></p>
<p>Single region annual risk:</p>
<ul>
<li>Regional outages: 1-2 per year (AWS historical average)</li>
<li>Average duration: 2-4 hours</li>
<li>Expected availability: 99.8-99.9% (excludes regional outages)</li>
</ul>
<p>Multi-region availability: 99.99%+ (survives full regional failures)</p>
<p><strong>Trade-off analysis:</strong></p>
<ul>
<li>Multi-region additional cost: <strong>2.3× baseline annual infrastructure cost</strong></li>
<li>Benefits: +0.1-0.2% availability improvement, 50-100ms latency reduction for international users, GDPR compliance</li>
<li>Break-even: Multi-region pays off if single regional outage costs exceed 2.3× annual infrastructure baseline</li>
</ul>
<p><strong>Intangible benefits:</strong></p>
<ul>
<li>Reputation protection (uptime matters for advertiser trust)</li>
<li>Regulatory compliance (GDPR data locality requirements)</li>
<li>Competitive advantage (global latency consistency)</li>
</ul>
<p><strong>Decision:</strong> Multi-region worth the 3.3× cost multiplier for platforms where revenue rate justifies availability investment.</p>
<p><strong>Note on cost multiplier:</strong> The 3.3× figure represents infrastructure duplication (3-4 regions with some shared services) plus cross-region data transfer overhead. Industry patterns show 1.3-2× for dual-region setups; 4-region active-passive architecture with shared control plane extrapolates to 3-3.5× based on documented cost drivers.</p>
<p><strong>Capacity conclusion:</strong> 20% standby insufficient for immediate regional takeover, but combined with auto-scaling (90-120s) and graceful degradation, provides cost-effective resilience. Alternative (200% over-provisioning per region) would reach 8-10× baseline costs. Trade-off: Accept degraded performance and bounded under-delivery during rare regional failures rather than excessive capacity overhead.</p>
<h3 id="schema-evolution-zero-downtime-data-migration">Schema Evolution: Zero-Downtime Data Migration</h3>
<p><strong>The Challenge:</strong></p>
<p>You’ve been running your CockroachDB-based user profile store for 18 months. It’s grown to <strong>4TB across 60 nodes</strong>. Now the product team wants to add a complex new feature that requires fundamental schema changes:</p>
<ul>
<li>Add new column for user preferences (JSONB structure)</li>
<li>Modify table partitioning to include <code>region</code> for data locality compliance (GDPR)</li>
<li>Add secondary index on <code>last_active_timestamp</code> for better query performance</li>
</ul>
<p><strong>The constraint:</strong> Zero downtime. You can’t take the platform offline for migration.</p>
<p><strong>Why Schema Evolution in Distributed SQL:</strong></p>
<p>CockroachDB (distributed SQL) provides native schema migration support with <code>ALTER TABLE</code>, but large-scale changes still require careful planning:</p>
<ol>
<li><strong>Online schema changes</strong> - CockroachDB supports most DDL operations without blocking (ADD COLUMN, CREATE INDEX with CONCURRENTLY)</li>
<li><strong>Strong consistency</strong> - ACID guarantees mean no dual-schema reads (unlike eventual consistency systems)</li>
<li><strong>Massive scale</strong> - 4TB migration for index backfill = 2-4 hours with proper throttling</li>
<li><strong>Version compatibility</strong> - Application code should use backward-compatible queries during rolling deployment</li>
</ol>
<p><strong>Zero-Downtime Migration Strategy:</strong></p>
<p><strong>Phase 1: Add Column (Non-blocking - Day 1)</strong></p>
<p>CockroachDB supports online schema changes with <code>ALTER TABLE</code>:</p>
<pre data-lang="sql" style="background-color:#fafafa;color:#383a42;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#a0a1a7;">-- Add new JSONB column (non-blocking, returns immediately)
</span><span style="color:#a626a4;">ALTER TABLE </span><span>user_profiles ADD COLUMN preferences JSONB </span><span style="color:#a626a4;">DEFAULT </span><span style="color:#50a14f;">&#39;{}&#39;</span><span>;
</span><span>
</span><span style="color:#a0a1a7;">-- Backfill happens asynchronously, reads see NULL/default during backfill
</span></code></pre>
<p>Application code updated to write to new column immediately. Reads handle both NULL (old rows) and populated (new rows) gracefully.</p>
<p><strong>No dual-write complexity:</strong> ACID transactions guarantee consistency - either transaction sees new schema or old schema, never inconsistent state.</p>
<p><strong>Phase 2: Add Index (Background with throttling - Week 1-2)</strong></p>
<p>Create index with <code>CONCURRENTLY</code> to avoid blocking writes:</p>
<pre data-lang="sql" style="background-color:#fafafa;color:#383a42;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#a0a1a7;">-- Create index concurrently (non-blocking, runs in background)
</span><span style="color:#a626a4;">CREATE INDEX </span><span>CONCURRENTLY idx_last_active ON </span><span style="color:#0184bc;">user_profiles</span><span> (last_active_timestamp);
</span></code></pre>
<p><strong>Index backfill rate:</strong></p>
<p>CockroachDB throttles background index creation to ~25% of cluster resources to avoid impacting production traffic. For 4TB data:</p>
<p>$$T_{index} = \frac{4000 \text{ GB}}{100 \text{ MB/s} \times 0.25} \approx 4-6 \text{ hours}$$</p>
<p>Monitor progress: <code>SHOW JOBS</code> displays percentage complete and estimated completion time.</p>
<p><strong>Phase 3: Partition Restructuring (Complex - Week 2-4)</strong></p>
<p>Modifying table partitioning (adding <code>region</code> to partition key) requires creating new table with desired partitioning, then migrating data. This is the <strong>only</strong> operation that requires dual-write pattern:</p>
<pre data-lang="sql" style="background-color:#fafafa;color:#383a42;" class="language-sql "><code class="language-sql" data-lang="sql"><span style="color:#a0a1a7;">-- Create new partitioned table
</span><span style="color:#a626a4;">CREATE TABLE </span><span style="color:#0184bc;">user_profiles_v2</span><span> (
</span><span>  user_id UUID,
</span><span>  region STRING,
</span><span>  ... (other columns),
</span><span>  </span><span style="color:#a626a4;">PRIMARY KEY</span><span> (region, user_id)
</span><span>) PARTITION BY LIST (region) (
</span><span>  PARTITION us </span><span style="color:#a626a4;">VALUES IN</span><span> (</span><span style="color:#50a14f;">&#39;US&#39;</span><span>),
</span><span>  PARTITION eu </span><span style="color:#a626a4;">VALUES IN</span><span> (</span><span style="color:#50a14f;">&#39;EU&#39;</span><span>),
</span><span>  PARTITION asia </span><span style="color:#a626a4;">VALUES IN</span><span> (</span><span style="color:#50a14f;">&#39;ASIA&#39;</span><span>)
</span><span>);
</span></code></pre>
<p><strong>Dual-write application logic</strong> (temporary, 2-4 weeks):</p>
<ul>
<li>Write to both <code>user_profiles</code> and <code>user_profiles_v2</code></li>
<li>Read from <code>user_profiles</code> (authoritative)</li>
<li>Background job migrates historical data</li>
<li>After validation, switch reads to <code>user_profiles_v2</code></li>
<li>Drop <code>user_profiles</code></li>
</ul>
<p><strong>Why this is simpler than Cassandra:</strong></p>
<ul>
<li>ACID transactions eliminate consistency issues during migration</li>
<li>No token range management - just batch SELECT/INSERT</li>
<li>Built-in backpressure and throttling mechanisms</li>
</ul>
<p><strong>Rollback Strategy:</strong></p>
<p>At any point during migration, rollback is possible:</p>
<table><thead><tr><th>Phase</th><th>Rollback Complexity</th><th>Max Data Loss</th></tr></thead><tbody>
<tr><td>Phase 1-2 (Dual-write)</td><td>Easy - flip read source back to old schema</td><td>0 (both schemas current)</td></tr>
<tr><td>Phase 3-4 (Gradual cutover)</td><td>Medium - revert traffic percentage</td><td>0 (still dual-writing)</td></tr>
<tr><td>Phase 5 (Cleanup started)</td><td>Hard - restore from archive</td><td>Up to 90 days if archive corrupted</td></tr>
</tbody></table>
<p><strong>Critical lesson:</strong> Keep dual-write active for <strong>2+ weeks after full cutover</strong> to ensure new schema stability before cleanup.</p>
<p><strong>CockroachDB-Specific Advantages:</strong></p>
<p><strong>Online schema changes:</strong></p>
<p>CockroachDB performs most schema changes online without blocking - adding columns, creating indexes, and modifying constraints happen in the background while applications continue to operate normally.</p>
<p><strong>Partition restructuring complexity:</strong></p>
<p>Changing primary key requires full rewrite - you can’t update partition key in place:</p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Old schema: PRIMARY KEY (user_id)
</span><span>New schema: PRIMARY KEY ((region, user_id))
</span></code></pre>
<p>This requires <strong>complete data copy</strong> to new table with reshuffling across nodes. Plan for <strong>2-4 week migration window</strong> for large datasets (estimate varies based on data volume, cluster capacity, and acceptable impact on production traffic).</p>
<p><strong>Cost-Benefit Analysis:</strong></p>
<p><strong>Note:</strong> The following estimates are <strong>order-of-magnitude approximations</strong> to illustrate trade-offs. Actual costs depend on team size, seniority, geographic location, data volume, and infrastructure configuration.</p>
<p><strong>Option A: Zero-downtime migration (described above)</strong></p>
<ul>
<li>Duration: ~8 weeks (estimate: 2 weeks dual-write setup + 4 weeks background migration + 2 weeks validation/cutover)</li>
<li>Engineering cost: ~2 Senior/Staff engineers × 8 weeks = 16 engineer-weeks (0.3-0.4 engineer-years fully loaded)</li>
<li>Associated costs: test infrastructure, code review, PM coordination</li>
<li>Risk: Low (gradual rollout, extensive validation, rollback safety)</li>
</ul>
<p><strong>Option B: Maintenance window migration</strong></p>
<ul>
<li>Duration: 12-hour downtime window (optimistic - could be 24+ hours if issues arise)</li>
<li>Engineering cost: ~1 engineer × 2 weeks prep + 12 hours execution</li>
<li>Revenue loss: 12-24 hours of complete downtime = <strong>12-24 days worth of revenue</strong> (For scaled platforms: 1M QPS, $1M/hour revenue rate = $12-24M loss. Smaller platforms: scale proportionally.)</li>
</ul>
<p><strong>Decision:</strong> Zero-downtime migration cost (0.3-0.4 engineer-years) &lt;&lt; downtime cost (weeks of revenue) by <strong>40-70×</strong>.</p>
<p>The exact multiplier depends on your revenue rate and engineering costs, but the conclusion holds across wide ranges: for high-traffic revenue-generating systems, zero-downtime migrations are economically justified despite higher engineering complexity.</p>
<h3 id="distributed-clock-synchronization-and-time-consistency">Distributed Clock Synchronization and Time Consistency</h3>
<blockquote>
<p><strong>Architectural Driver: Financial Accuracy</strong> - Clock skew across regions can cause budget double-allocation or billing disputes. HLC + bounded allocation windows guarantee deterministic ordering for financial transactions.</p>
</blockquote>
<p><strong>Problem:</strong> Multi-region systems require accurate timestamps for budget tracking and billing reconciliation. Clock drift (1-50ms/day per server) causes billing disputes, budget race conditions, and causality violations. Without synchronization, 1000 servers can diverge by 50s in one day.</p>
<p><strong>Solution Spectrum: NTP → PTP → Global Clocks</strong></p>
<table><thead><tr><th>Technology</th><th>Accuracy</th><th>Cost</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>NTP</strong><br/>Network Time Protocol</td><td>±50ms (public),<br/>±10ms (local)</td><td>Free</td><td>General-purpose time sync</td></tr>
<tr><td><strong>PTP</strong><br/>Precision Time Protocol</td><td>±100μs</td><td>Medium (hardware switches)</td><td>High-frequency trading, telecom</td></tr>
<tr><td><strong>GPS-based Clocks</strong></td><td>±1μs</td><td>High<br/>(GPS receivers per rack)</td><td>Critical infrastructure</td></tr>
<tr><td><strong>Google Spanner<br/>TrueTime</strong></td><td>±7ms<br/>(bounded uncertainty)</td><td>Very high (proprietary)</td><td>Global strong consistency</td></tr>
<tr><td><strong>AWS Time Sync Service</strong></td><td>&lt;100μs (0.1ms)<br/>Legacy: ±1ms</td><td>Free (on AWS)</td><td>Cloud deployments (upgraded 2023+)</td></tr>
</tbody></table>
<p><strong>Multi-tier time synchronization:</strong></p>
<p><strong>Tier 1 - Event Timestamping:</strong> AWS Time Sync (&lt;100μs, free). Network latency (20-100ms) dwarfs clock skew, making NTP sufficient for impressions/clicks.</p>
<p><strong>Tier 2 - Financial Reconciliation:</strong> CockroachDB built-in HLC provides automatic globally-ordered timestamps: \(HLC = (t_{physical}, c_{logical}, id_{node})\). Guarantees causality preservation (if A→B then HLC(A) &lt; HLC(B)) and deterministic ordering via logical counters + node ID tie-breaking.</p>
<p><strong>Clock skew mitigation:</strong> Create 200ms “dead zone” at day boundaries (23:59:59.900 to 00:00:00.100) where budget allocations are forbidden. Prevents regions with skewed clocks from over-allocating across day boundaries.</p>
<p><strong>Architecture decision:</strong> AWS Time Sync (±1ms, free) + CockroachDB built-in HLC. Google Spanner’s TrueTime (±7ms) not worth complexity given 20-100ms network variability.</p>
<p><strong>Advantage:</strong> Eliminates ~150 lines of custom HLC code, provides battle-tested clock synchronization.</p>
<p><strong>Monitoring:</strong> Alert if clock offset &gt;100ms, HLC logical counter growth &gt;1000/sec sustained, or budget discrepancy &gt;0.5% of daily budget.</p>
<h3 id="global-event-ordering-for-financial-ledgers-the-external-consistency-challenge">Global Event Ordering for Financial Ledgers: The External Consistency Challenge</h3>
<blockquote>
<p><strong>Architectural Driver: Financial Accuracy</strong> - Financial audit trails require globally consistent event ordering across regions. CockroachDB’s HLC-timestamped billing ledger provides near-external consistency, ensuring that events are ordered chronologically for regulatory compliance, while PostgreSQL serves only as cold archive.</p>
</blockquote>
<p><strong>The Problem: Global Event Ordering</strong></p>
<p>Budget pre-allocation (Redis) solves fast local enforcement, but billing ledgers require globally consistent event ordering across regions. Without coordinated timestamps, audit trails can show incorrect event sequences.</p>
<p><strong>Example:</strong> US-East allocates $100 (T1), EU-West spends $100 exhausting budget (T2). Separate PostgreSQL instances using local clocks might timestamp T1 after T2 due to clock skew, showing wrong ordering in audit logs.</p>
<p><strong>Solution: CockroachDB HLC-Timestamped Ledger</strong></p>
<p>CockroachDB provides near-external consistency using Hybrid Logical Clocks: $$HLC = (pt, c)$$ where pt = physical time, c = logical counter.</p>
<p><strong>Guarantee:</strong> Causally related transactions get correctly ordered timestamps via Raft consensus. Independent transactions within ±100ms uncertainty window may have ambiguous ordering, but this is acceptable - network latency (50-150ms) already dominates, and causally related events (same campaign) are correctly ordered.</p>
<p><strong>Requirements met:</strong></p>
<ul>
<li>SOX/MiFID regulatory compliance (chronologically ordered financial records, 5-7 year retention)</li>
<li>Legal dispute resolution (“Did impression X happen before budget exhaustion?”)</li>
<li>Audit trail correctness for billing reconciliation</li>
</ul>
<p><strong>Architecture Decision: Three-Tier Financial Data Storage</strong></p>
<pre class="mermaid">
    
    graph LR
    ADV[Ad Server<br/>1M QPS]
    REDIS[(Tier 1: Redis<br/>Atomic DECRBY<br/><1ms)]
    CRDB[(Tier 2: CockroachDB<br/>HLC Timestamps<br/>10-15ms<br/>90-day hot)]
    POSTGRES[(Tier 3: PostgreSQL/S3<br/>Cold Archive<br/>7-year retention)]

    ADV -->|Budget check| REDIS
    REDIS -->|Every 5 min<br/>HLC timestamped| CRDB
    CRDB -->|Nightly archive| POSTGRES

    classDef fast fill:#e3f2fd,stroke:#1976d2
    classDef ledger fill:#fff3e0,stroke:#f57c00
    classDef archive fill:#f3e5f5,stroke:#7b1fa2

    class REDIS fast
    class CRDB ledger
    class POSTGRES archive
</pre>
<p><strong>Why This Three-Tier Architecture:</strong></p>
<table><thead><tr><th>Tier</th><th>Technology</th><th>Purpose</th><th>Consistency Requirement</th></tr></thead><tbody>
<tr><td><strong>Tier 1: Fast Path</strong></td><td>Redis</td><td>Real-time budget enforcement</td><td>Local atomic operations (DECRBY)</td></tr>
<tr><td><strong>Tier 2: Billing Ledger</strong></td><td>CockroachDB</td><td>Active financial transactions with global ordering</td><td>Serializable + HLC ordering (near-external consistency)</td></tr>
<tr><td><strong>Tier 3: Cold Archive</strong></td><td>PostgreSQL + S3</td><td>7-year regulatory retention</td><td>None (immutable archive)</td></tr>
</tbody></table>
<p><strong>Workflow:</strong></p>
<ol>
<li><strong>Real-time spend</strong> (1M QPS): Redis DECRBY on pre-allocated budgets (&lt;1ms)</li>
<li><strong>Periodic reconciliation</strong> (5min): Flush Redis deltas to CockroachDB with automatic HLC timestamps</li>
<li><strong>Nightly archival</strong>: Export 90-day-old records to PostgreSQL/S3 Glacier (7-year retention)</li>
</ol>
<p><strong>Cost Analysis:</strong></p>
<table><thead><tr><th>Component</th><th>Technology</th><th>Relative Cost</th></tr></thead><tbody>
<tr><td>Fast path</td><td>Redis Cluster (20 nodes)</td><td>16-20%</td></tr>
<tr><td>Billing ledger (90-day hot)</td><td>CockroachDB (60-80 nodes)</td><td>75-80%</td></tr>
<tr><td>Cold archive (7-year)</td><td>PostgreSQL + S3 Glacier</td><td>4-5%</td></tr>
<tr><td><strong>Total financial storage</strong></td><td></td><td><strong>100% baseline</strong></td></tr>
</tbody></table>
<p><strong>Build vs Buy:</strong> Custom PostgreSQL + HLC implementation costs 1-1.5 engineer-years (6 engineer-months) plus ongoing maintenance. CockroachDB’s premium (20-30% of financial storage baseline) eliminates upfront engineering cost and operational burden.</p>
<h2 id="part-8-observability-and-operations">Part 8: Observability and Operations</h2>
<div class="part-toc">
<div class="part-toc-header">
<div class="part-toc-title">In this part:</div>
</div>
<ul>
<li><a href="#service-level-indicators-and-objectives">Service Level Indicators and Objectives</a>
<span class="part-toc-desc">SLI/SLO definitions, availability targets, latency percentiles</span></li>
<li><a href="#incident-response-dashboard">Incident Response Dashboard</a>
<span class="part-toc-desc">Real-time monitoring, alert aggregation, runbook automation</span></li>
<li><a href="#distributed-tracing">Distributed Tracing</a>
<span class="part-toc-desc">Request tracing, latency attribution, performance debugging</span></li>
</ul>

<div class="part-toc-nav">

    <a href="#part-7-advanced-topics" class="prev-part-link"><i class="fa fa-angle-double-up"></i> Part 7: Advanced Topics</a>


    <a href="#part-9-security-and-compliance" class="next-part-link">Part 9: Security and Compliance <i class="fa fa-angle-double-down"></i></a>

</div>

</div>
<h3 id="service-level-indicators-and-objectives">Service Level Indicators and Objectives</h3>
<p><strong>Key SLIs:</strong></p>
<style>
#tbl_key_slis + table th:first-of-type  { width: 15%; }
#tbl_key_slis + table th:nth-of-type(2) { width: 20%; }
#tbl_key_slis + table th:nth-of-type(3) { width: 30%; }
#tbl_key_slis + table th:nth-of-type(4) { width: 35%; }
</style>
<div id="tbl_key_slis"></div>
<table><thead><tr><th>Service</th><th>SLI</th><th>Target</th><th>Why</th></tr></thead><tbody>
<tr><td><strong>Ad API</strong></td><td>Availability</td><td>99.9%</td><td>Revenue tied to successful serves</td></tr>
<tr><td><strong>Ad API</strong></td><td>Latency</td><td>p95 &lt;100ms, p99 &lt;150ms</td><td>Mobile timeouts above 150ms</td></tr>
<tr><td><strong>ML</strong></td><td>Accuracy</td><td>AUC &gt;0.78</td><td>Below 0.75 = 15%+ revenue drop</td></tr>
<tr><td><strong>RTB</strong></td><td>Response Rate</td><td>&gt;80% DSPs within 30ms</td><td>&lt;80% = remove from rotation</td></tr>
<tr><td><strong>Budget</strong></td><td>Consistency</td><td>Over-delivery &lt;1%</td><td>&gt;2% = refunds, &gt;5% = lawsuits</td></tr>
</tbody></table>
<p><strong>Error Budget Policy (99.9% = 43 min/month):</strong></p>
<p>When budget exhausted:</p>
<ol>
<li>Freeze feature launches (critical fixes only)</li>
<li>Focus on reliability work</li>
<li>Mandatory root cause analysis</li>
<li>Next month: 99.95% target to rebuild trust</li>
</ol>
<h3 id="incident-response-dashboard">Incident Response Dashboard</h3>
<p>Effective incident response requires immediate access to:</p>
<p><strong>SLO deviation metrics</strong> - Latency (p95, p99) and error rate vs targets to determine severity</p>
<p><strong>Resource utilization</strong> - CPU/GPU/memory metrics plus active configuration (model versions, feature flags) to distinguish capacity from configuration issues</p>
<p><strong>Dependency breakdown</strong> - Per-service latency (cache, database, ML, external APIs) to isolate the actual bottleneck</p>
<p><strong>Historical patterns</strong> - Similar past incidents and time-series showing when degradation began</p>
<h3 id="distributed-tracing">Distributed Tracing</h3>
<p>Single user reports “ad not loading” among 1M+ req/sec:</p>
<pre style="background-color:#fafafa;color:#383a42;"><code><span>Request ID: 7f3a8b2c...
</span><span>Total: 287ms (VIOLATED SLO)
</span><span>
</span><span>├─ API Gateway: 2ms
</span><span>├─ User Profile: 45ms
</span><span>│  └─ Redis: 43ms (normally 5ms)
</span><span>│     └─ TCP timeout: 38ms
</span><span>│        └─ Cause: Node failure, awaiting replica
</span><span>├─ ML Inference: 156ms
</span><span>│  └─ Batch incomplete: 8/32
</span><span>│     └─ Cause: Low traffic (Redis failure reduced QPS)
</span><span>└─ RTB: 84ms
</span></code></pre>
<p><strong>Root cause:</strong> Redis node failure → cascading slowdown. Trace shows exactly why.</p>
<hr />
<h2 id="part-9-security-and-compliance">Part 9: Security and Compliance</h2>
<div class="part-toc">
<div class="part-toc-header">
<div class="part-toc-title">In this part:</div>
</div>
<ul>
<li><a href="#data-lifecycle-and-gdpr">Data Lifecycle and GDPR</a>
<span class="part-toc-desc">User data retention, right to deletion, compliance automation</span></li>
</ul>

<div class="part-toc-nav">

    <a href="#part-8-observability-and-operations" class="prev-part-link"><i class="fa fa-angle-double-up"></i> Part 8: Observability and Operations</a>


    <a href="#part-10-production-operations-at-scale" class="next-part-link">Part 10: Production Operations at Scale <i class="fa fa-angle-double-down"></i></a>

</div>

</div>
<p><strong>Service-to-Service Authentication: Zero Trust with mTLS</strong></p>
<p>In distributed systems with 50+ microservices, network perimeters are insufficient. Solution: <strong>mutual TLS (mTLS)</strong> via Istio service mesh.</p>
<p>Every service receives a unique X.509 certificate (24-hour TTL) from Istio CA via SPIFFE/SPIRE. Envoy sidecar proxies automatically handle certificate rotation, mutual authentication, and traffic encryption - transparent to application code. All plaintext connections are rejected.</p>
<p><strong>Authorization policies</strong> enforce least-privilege access:</p>
<ul>
<li>Ad Server → ML Inference: Allowed</li>
<li>Ad Server → Budget Database: Blocked (must use Budget Controller)</li>
<li>External DSPs → Internal Services: Blocked (terminate at gateway)</li>
</ul>
<p>Defense in depth: Even if network segmentation fails, attackers cannot decrypt inter-service traffic, impersonate services, or call unauthorized endpoints.</p>
<p><strong>PII Protection:</strong></p>
<ul>
<li><strong>Encryption at rest:</strong> KMS-encrypted CockroachDB storage</li>
<li><strong>Column-level encryption:</strong> Only ML pipeline has decrypt permission</li>
<li><strong>Data minimization:</strong> Hashed user IDs, no email/name in ad requests</li>
<li><strong>Log scrubbing:</strong> <code>user_id=[REDACTED]</code></li>
</ul>
<p><strong>Secrets: Vault with Dynamic Credentials</strong></p>
<ul>
<li>Lease credentials auto-rotated every 24h</li>
<li>Audit log: which service accessed what when</li>
<li>Revoke access instantly if compromised</li>
</ul>
<p><strong>ML Data Poisoning Protection:</strong></p>
<p>Training pipeline validates incoming events before model training:</p>
<ol>
<li><strong>CTR anomaly detection</strong>: Quarantine events with &gt;3σ CTR spikes (e.g., 2%→8%)</li>
<li><strong>IP entropy check</strong>: Flag low-diversity IP clusters (&lt;2.0 entropy = botnet)</li>
<li><strong>Temporal patterns</strong>: Detect uniform timing intervals (human=bursty, bot=mechanical)</li>
</ol>
<p><strong>Model integrity</strong>: GPG-signed models prevent loading tampered artifacts. Inference servers verify signatures before loading models, rejecting invalid signatures with immediate alerting.</p>
<h3 id="data-lifecycle-and-gdpr">Data Lifecycle and GDPR</h3>
<p><strong>Retention policies:</strong></p>
<table><thead><tr><th>Data</th><th>Retention</th><th>Rationale</th></tr></thead><tbody>
<tr><td>Raw events</td><td>7 days</td><td>Real-time only; archive to S3</td></tr>
<tr><td>Aggregated metrics</td><td>90 days</td><td>Dashboard queries</td></tr>
<tr><td>Model training data</td><td>30 days</td><td>Older data less predictive</td></tr>
<tr><td>User profiles</td><td>365 days</td><td>GDPR; inactive purged</td></tr>
<tr><td>Audit logs</td><td>7 years</td><td>Legal compliance</td></tr>
</tbody></table>
<p><strong>GDPR “Right to be Forgotten”:</strong></p>
<p>Deletion across 10+ systems in parallel:</p>
<ul>
<li>CockroachDB: DELETE user_profiles</li>
<li>Redis/Valkey: FLUSH user keys</li>
<li>Kafka: Publish tombstone (log compaction)</li>
<li>ML training: Mark deleted</li>
<li>Backups: Crypto erasure (delete encryption key)</li>
</ul>
<p><strong>Verification:</strong> All systems confirm → send deletion certificate to user within 48h.</p>
<hr />
<h2 id="part-10-production-operations-at-scale">Part 10: Production Operations at Scale</h2>
<div class="part-toc">
<div class="part-toc-header">
<div class="part-toc-title">In this part:</div>
</div>
<ul>
<li><a href="#deployment-safety-and-zero-downtime-operations">Deployment Safety and Zero-Downtime Operations</a>
<span class="part-toc-desc">Canary releases, blue-green deployments, rollback strategies</span></li>
<li><a href="#error-budgets-balancing-velocity-and-reliability">Error Budgets: Balancing Velocity and Reliability</a>
<span class="part-toc-desc">SLO-based development velocity, incident attribution</span></li>
<li><a href="#cost-management-at-scale">Cost Management at Scale</a>
<span class="part-toc-desc">Resource attribution, chargeback models, efficiency metrics</span></li>
</ul>

<div class="part-toc-nav">

    <a href="#part-9-security-and-compliance" class="prev-part-link"><i class="fa fa-angle-double-up"></i> Part 9: Security and Compliance</a>


    <a href="#part-11-resilience-and-failure-scenarios" class="next-part-link">Part 11: Resilience and Failure Scenarios <i class="fa fa-angle-double-down"></i></a>

</div>

</div>
<h3 id="deployment-safety-and-zero-downtime-operations">Deployment Safety and Zero-Downtime Operations</h3>
<p><strong>The availability imperative:</strong> With 99.9% SLO providing only 43 minutes/month error budget, we cannot afford to waste any portion on <strong>planned</strong> downtime. All deployments and schema changes must be zero-downtime operations.</p>
<p><strong>Progressive deployment strategy:</strong></p>
<p>Rolling deployments (canary → 10% → 50% → 100%) with automated gates on error rate, latency p99, and revenue metrics. Each phase must pass health checks before proceeding. Feature flags provide blast radius control - new features start dark, gradually enabled per user cohort.</p>
<p><strong>Zero-downtime schema migrations:</strong></p>
<p>Database schema changes consume zero availability budget through online DDL operations:</p>
<ul>
<li><strong>Simple changes</strong> (ADD COLUMN, CREATE INDEX): CockroachDB’s online schema changes with background backfill</li>
<li><strong>Complex restructuring</strong> (partition changes): Dual-write pattern with gradual cutover (detailed in Part 7: Schema Evolution section)</li>
<li><strong>Validation</strong>: Shadow reads verify new schema correctness before cutover</li>
</ul>
<p>The cost trade-off is clear: zero-downtime migrations require 2-4× more engineering effort than “take the system down” approaches, but protect against wasting the precious 43-minute availability budget on planned maintenance.</p>
<p><strong>Key insight:</strong> The 43 minutes/month error budget is reserved for <strong>unplanned</strong> failures (infrastructure outages, cascading failures, external dependency failures). Planned operations (deployments, migrations, configuration changes) must never consume this budget.</p>
<h3 id="error-budgets-balancing-velocity-and-reliability">Error Budgets: Balancing Velocity and Reliability</h3>
<p>Error budgets formalize the trade-off between reliability and feature velocity. For a 99.9% availability SLO, the error budget is 43.2 minutes/month of <strong>unplanned</strong> downtime.</p>
<p>$$\text{Error Budget} = (1 - 0.999) \times 30 \times 24 \times 60 = 43.2 \text{ minutes/month}$$</p>
<p><strong>Budget allocation strategy (unplanned failures only):</strong></p>
<table><thead><tr><th>Source</th><th>Allocation</th><th>Rationale</th></tr></thead><tbody>
<tr><td>Infrastructure failures</td><td>15 min (35%)</td><td>Cloud provider incidents, hardware failures, regional outages</td></tr>
<tr><td>Dependency failures</td><td>12 min (28%)</td><td>External DSP timeouts, third-party API issues</td></tr>
<tr><td>Code defects</td><td>8 min (19%)</td><td>Bugs escaping progressive rollout gates</td></tr>
<tr><td>Unknown/buffer</td><td>8 min (18%)</td><td>Unexpected failure modes, cascading failures</td></tr>
</tbody></table>
<p><strong>Note:</strong> Planned deployments and schema migrations target zero downtime through progressive rollouts and online DDL operations. When deployment-related issues occur (e.g., bad code pushed past canary gates), they count against “Code defects” budget.</p>
<p><strong>Burn rate alerting:</strong></p>
<p>Monitor how quickly budget is consumed. Burn rate = current error rate / target error rate. A 10× burn rate means exhausting the monthly budget in ~3 hours, triggering immediate on-call escalation.</p>
<p><strong>Policy-driven decision making:</strong></p>
<p>Error budget remaining drives release velocity:</p>
<ul>
<li><strong>&gt;75% remaining</strong>: Ship aggressively, run experiments, test risky features</li>
<li><strong>25-75% remaining</strong>: Normal operations, standard release cadence</li>
<li><strong>&lt;25% remaining</strong>: Freeze non-critical releases, focus on reliability</li>
<li><strong>Exhausted</strong>: Code freeze except critical fixes, mandatory postmortems</li>
</ul>
<p><strong>Why 99.9% not 99.99%?</strong></p>
<p>With zero-downtime deployments and migrations eliminating <strong>planned</strong> downtime, the 99.9% SLO (43 minutes/month) is entirely allocated to <strong>unplanned</strong> failures. Moving to 99.99% (4.3 minutes/month) would reduce our tolerance for unplanned failures from 43 to 4.3 minutes - a 10× tighter constraint.</p>
<p>This requires multi-region active-active with automatic failover (approximately doubling infrastructure costs) to achieve sub-minute recovery from regional outages. The economic question: is tolerating 39 fewer minutes of unplanned failures worth doubling infrastructure spend?</p>
<p>For advertising platforms with client-side retries and geographic distribution, the answer is typically no. Brief regional outages have limited revenue impact due to automatic retries and traffic redistribution. Better ROI comes from reducing MTTR (faster detection and recovery) than preventing all failures.</p>
<p>The tolerance for unplanned failures varies by domain - payment processing or healthcare systems require 99.99%+ because every transaction matters. Ad platforms operate at higher request volumes where statistical averaging and retries provide natural resilience.</p>
<h3 id="cost-management-at-scale">Cost Management at Scale</h3>
<p>Resource attribution with chargeback models (vCPU-hours, GPU-hours, storage IOPS per team). Standard optimizations: spot instances for training (70% cheaper), tiered storage, reserved capacity for baseline load. Track efficiency via vCPU-ms per request and investigate &gt;15% month-over-month increases.</p>
<hr />
<h2 id="part-11-resilience-and-failure-scenarios">Part 11: Resilience and Failure Scenarios</h2>
<p>A robust architecture must survive catastrophic failures, security breaches, and business model pivots. This section addresses three critical scenarios:</p>
<p><strong>Catastrophic Regional Failure:</strong> When an entire AWS region fails, our semi-automatic failover mechanism combines Route53 health checks (2-minute detection) with manual runbook execution to promote secondary regions. The critical challenge is budget counter consistency—asynchronous Redis replication creates potential overspend windows during failover. We mitigate this through pre-allocation patterns that limit blast radius to allocated quotas per ad server, bounded by replication lag multiplied by allocation size.</p>
<p><strong>Malicious Insider Attack:</strong> Defense-in-depth through zero-trust architecture (SPIFFE/SPIRE for workload identity), mutual TLS between all services, and behavioral anomaly detection on budget operations. Critical financial operations like budget allocations require cryptographic signing with Kafka message authentication, creating an immutable audit trail. Lateral movement is constrained through Istio authorization policies enforcing least-privilege service mesh access.</p>
<p><strong>Business Model Pivot to Guaranteed Inventory:</strong> Transitioning from auction-based to guaranteed delivery requires strong consistency for impression quotas. Rather than replacing our stack, we extend the existing pre-allocation pattern—CockroachDB maintains source-of-truth impression counters (leveraging the same HLC-based billing ledger) while Redis provides fast-path allocation with periodic reconciliation. This hybrid approach adds only 10-15ms to the critical path for guaranteed campaigns while preserving sub-millisecond performance for auction traffic. The 12-month evolution path reuses 80% of existing infrastructure (ML pipeline, feature store, Kafka, billing ledger) while adding campaign management and SLA tracking layers.</p>
<p>These scenarios validate that the architecture is not merely elegant on paper, but battle-hardened for production realities: regional disasters, adversarial threats, and fundamental business transformations.</p>
<hr />
<h2 id="conclusion-known-gaps-and-missing-topics">Conclusion: Known gaps and Missing Topics</h2>
<p>Despite extensive coverage, several important areas were not explored in depth:</p>
<p><strong>1. A/B Testing and Experimentation Platform</strong>
Statistical rigor for auction mechanism changes, feature rollouts, and ML model testing. Statistical power calculations, early stopping criteria, multi-armed bandits for automatic winner selection, and feature flag infrastructure for gradual rollouts.</p>
<p><strong>2. Capacity Planning and Predictive Autoscaling</strong>
Mathematical models for forecasting resource needs during traffic spikes (Black Friday, Super Bowl). Cost trade-offs: over-provisioning waste vs revenue loss from under-provisioning. Predictive scaling vs reactive scaling latency.</p>
<p><strong>3. Chaos Engineering and Resilience Validation</strong>
Systematic testing of failure scenarios claimed throughout this design. Controlled fault injection (kill Redis nodes, partition networks), blast radius measurement, validating actual MTTR vs theoretical calculations.</p>
<p><strong>4. Multi-Tenancy and Resource Isolation</strong>
Preventing one advertiser’s traffic spike from starving another’s campaigns. CPU/memory quotas per tenant, noisy neighbor detection in shared Redis clusters, QoS enforcement at the platform level.</p>
<p><strong>5. Geographic Load Balancing and Traffic Steering</strong>
DNS-based routing (Route53 latency-based policies), anycast for edge deployments, orchestrating regional failovers. Differs from Part 7’s multi-region deployment by focusing on traffic routing intelligence.</p>
<p><strong>6. Backpressure and Admission Control</strong>
Load shedding strategies beyond circuit breakers. Rejecting requests at the edge when backend capacity is saturated, graceful degradation coordination across services, preventing cascading overload.</p>
<p><strong>7. Data Lineage and Root Cause Analysis</strong>
When ML predictions are wrong, how to trace feature staleness backward through Kafka→Flink→Redis→inference. Critical for debugging “why did this ad perform poorly?” in production.</p>
<p><strong>8. Disaster Recovery Testing and Validation</strong>
RPO/RTO analysis, backup verification strategies, automated failover drills. How to validate that the multi-region architecture actually works during regional failures without waiting for AWS to have an outage.</p>
<hr />
<h2 id="final-thoughts">Final Thoughts</h2>
<p>This 3 weeks learning exercise reinforced a fundamental truth: <strong>everything is a trade-off with a price tag</strong>. There’s no “best” solution - only “best given constraints and costs.”</p>
<p>If you’ve made it this far, thanks for reading. This was a mental exercise in systems thinking and cost optimization - treating distributed systems design like an extended puzzle. Better than sudoku, arguably.</p>
<p><strong>I’d love your feedback</strong> - what I got wrong, what I missed, or alternative approaches. Found a calculation error? Have battle stories about cache sizing? Want to debate 99.9% vs 99.99% trade-offs? <strong><a href="https://github.com/immediatus/immediatus.github.io/discussions/">💭 Join the discussion on GitHub</a></strong>. Let’s optimize the cost function of learning together.</p>



  <hr>
  <nav id="post-nav">
    
      <a class="post-nav-item post-nav-prev" href="https:&#x2F;&#x2F;e-mindset.space&#x2F;blog&#x2F;engineering-robust-intelligence-ai-collectives&#x2F;">
        <div class="nav-arrow">← Previous</div>
        <span class="post-title">Engineering Robust Intelligence in AI Collectives</span>
      </a>
    
    
  </nav>


<p class="dialog-buttons">
<a class="inline-button" href="#top">Back to top</a>
</p>
</div>
  <footer id="site-footer">
  <p><small>Powered by <a href="https://www.getzola.org">Zola</a></small></p>
</footer>

<script>
  feather.replace();
</script>

</body>
</html>
