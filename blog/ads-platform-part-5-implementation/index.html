<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Generic Description Meta Tag -->
  
  <meta name="description" content="Series capstone: complete technology stack with decision rationale. Why each choice matters (Java 21 + ZGC for GC pauses, CockroachDB for cost efficiency, Linkerd for latency). Includes cluster sizing, configuration patterns, system integration, and implementation roadmap. Validates all requirements met. Reference architecture for 1M+ QPS real-time ads platforms." />
  

  <!-- Open Graph -->
  <meta property="og:site_name" content="Mindset Footprint" />
  <meta property="og:title" content="Complete Implementation Blueprint: Technology Stack &amp; Architecture Guide - Mindset Footprint" />
  <meta property="og:url" content="https:&#x2F;&#x2F;e-mindset.space&#x2F;blog&#x2F;ads-platform-part-5-implementation&#x2F;" />
  <meta property="og:description" content="Series capstone: complete technology stack with decision rationale. Why each choice matters (Java 21 + ZGC for GC pauses, CockroachDB for cost efficiency, Linkerd for latency). Includes cluster sizing, configuration patterns, system integration, and implementation roadmap. Validates all requirements met. Reference architecture for 1M+ QPS real-time ads platforms." />

  <title>Complete Implementation Blueprint: Technology Stack &amp; Architecture Guide - Mindset Footprint</title>

  <link rel="canonical" href="https:&#x2F;&#x2F;e-mindset.space&#x2F;blog&#x2F;ads-platform-part-5-implementation&#x2F;" />
  <link rel="stylesheet" type="text/css" href="https://e-mindset.space/css/main.css" />
  <link rel="apple-touch-icon" sizes="180x180" href="https://e-mindset.space/icon/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="https://e-mindset.space/icon/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="https://e-mindset.space/icon/favicon-16x16.png" />
  <link rel="manifest" href="https://e-mindset.space/icon/site.webmanifest" />

  

    <!-- Cookie Consent by TermsFeed https://www.TermsFeed.com -->
    <script type="text/javascript" src="https://e-mindset.space/js/cookie-consent-code.js" charset="UTF-8"></script>
    <script type="text/javascript" charset="UTF-8">
      document.addEventListener('DOMContentLoaded', function () {
        cookieconsent.run({
          "notice_banner_type":"simple",
          "consent_type":"express",
          "palette":"light",
          "language":"en",
          "page_load_consent_levels":["strictly-necessary"],
          "notice_banner_reject_button_hide":false,
          "preferences_center_close_button_hide":false,
          "page_refresh_confirmation_buttons":false,
          "website_name":"https://e-mindset.space/"
        });
      });
    </script>

    <!-- Google Analytics -->
        <script type="text/plain" data-cookie-consent="tracking" async src="https://www.googletagmanager.com/gtag/js?id=G-X0M5X84BLR"></script>
        <script type="text/plain" data-cookie-consent="tracking">
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-X0M5X84BLR');
        </script>
    <!-- end of Google Analytics-->

    <noscript>Free cookie consent management tool by <a href="https://www.termsfeed.com/">TermsFeed Generator</a></noscript>
  

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css" integrity="sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.js" integrity="sha384-2B8pfmZZ6JlVoScJm/5hQfNS2TI/6hPqDZInzzPc8oHpN5SgeNOf4LzREO6p5YtZ" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous" onload="renderMathInElement(document.body, { strict: true });"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/contrib/mathtex-script-type.min.js" integrity="sha384-sg4gBRJTqTCyzYbB7e72xGs3dA2LK994XRZS6urZW6Uh6Mu3j2JJ3YG2s9HALO8U" crossorigin="anonymous"></script>


  <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>

  <script type="module">
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.9.0/dist/mermaid.esm.min.mjs";

    function getCSSVariable(variable, fallback) {
      if (typeof window !== 'undefined' && typeof document !== 'undefined') {
        return getComputedStyle(document.documentElement).getPropertyValue(variable).trim() || fallback;
      }
      return fallback;
    };

    mermaid.initialize({
      startOnLoad: true,
      theme: 'base',
      themeVariables: {
        primaryColor: getCSSVariable('--mermaid-primary-color', '#ede9fe'),
        primaryTextColor: getCSSVariable('--mermaid-primary-text-color', '#6d28d9'),
        primaryBorderColor: getCSSVariable('--mermaid-primary-border-color', '#c4b5fd'),
        lineColor: getCSSVariable('--mermaid-line-color', '#a78bfa'),
        secondaryColor: getCSSVariable('--mermaid-secondary-color', '#f0fdf4'),
        secondaryTextColor: getCSSVariable('--mermaid-secondary-text-color', '#047857'),
        secondaryBorderColor: getCSSVariable('--mermaid-secondary-border-color', '#86efac'),
        tertiaryColor: getCSSVariable('--mermaid-tertiary-color', '#fff7ed'),
        tertiaryTextColor: getCSSVariable('--mermaid-tertiary-text-color', '#c2410c'),
        tertiaryBorderColor: getCSSVariable('--mermaid-tertiary-border-color', '#fdba74'),
        edgeLabelBackground: getCSSVariable('--mermaid-edge-label-background', '#ffffff'),
        edgeLabelColor: getCSSVariable('--mermaid-edge-label-color', '#4a5568'),
        fontSize: '14px',
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif'
      },
      flowchart: {
        padding: 8,
        nodeSpacing: 40,
        rankSpacing: 40,
        curve: 'basis'
      },
      sequence: {
        diagramMarginX: 8,
        diagramMarginY: 8,
        actorMargin: 40,
        boxMargin: 8,
        boxTextMargin: 4,
        noteMargin: 8,
        messageMargin: 30
      },
      gantt: {
        titleTopMargin: 15,
        barHeight: 18,
        barGap: 3,
        topPadding: 40,
        leftPadding: 60,
        gridLineStartPadding: 30,
        fontSize: 12
      }
    });
  </script>

</head>
<body>
  <header id="site-nav">
    <nav aria-label="Main navigation">
        <ul>
            
            <li>
                <a href="https://e-mindset.space/">
                    <i data-feather="coffee" class="ico"></i><span class="nav-text">&nbsp;Blog</span>
                </a>
            </li>
            
            <li>
                <a href="https://github.com/immediatus/immediatus.github.io/discussions">
                    <i data-feather="message-square" class="ico"></i><span class="nav-text">&nbsp;Discussions</span>
                </a>
            </li>
            
            <li>
                <a href="https://e-mindset.space/about">
                    <i data-feather="user" class="ico"></i><span class="nav-text">&nbsp;About</span>
                </a>
            </li>
            
        </ul>
        <div id="cookies-preferences">
            <a href="#" id="open_preferences_center">
                <i data-feather="settings" class="ico"></i>
            </a>
        </div>
    </nav>
</header>
<div id="main" class="container">
    
<header class="post-header">
  <h1>Complete Implementation Blueprint: Technology Stack &amp; Architecture Guide</h1>

  <div class="post-meta">
      <time datetime="2025-11-15T00:00:00+00:00" pubdate>15 November 2025</time>

    
        <span class="meta-separator">•</span>
        
          <div class="post-tags">
              <a class="tag" href="https://e-mindset.space/tags/system-design/">#system-design</a>
              <a class="tag" href="https://e-mindset.space/tags/distributed-systems/">#distributed-systems</a>
              <a class="tag" href="https://e-mindset.space/tags/ads-tech/">#ads-tech</a>
          </div>
        

  </div>
</header>








<h2 id="introduction-from-requirements-to-reality">Introduction: From Requirements to Reality</h2>
<p>Over the past four parts of this series, we’ve built up the architecture for a real-time ads platform serving 1M+ QPS with 150ms P99 latency:</p>
<p><strong><a href="/blog/ads-platform-part-1-foundation-architecture/">Part 1</a></strong> established the architectural foundation - requirements analysis, latency budgeting (decomposing 150ms across components), resilience patterns (circuit breakers, graceful degradation), and the P99 tail latency challenge. We identified three critical drivers: revenue maximization, sub-150ms latency, and 99.9% availability. These requirements shaped every decision that followed.</p>
<p><strong><a href="/blog/ads-platform-part-2-rtb-ml-pipeline/">Part 2</a></strong> designed the dual-source revenue engine - parallelizing internal ML-scored inventory (65ms) with external RTB auctions (100ms) to achieve 30-48% revenue lift over single-source approaches. We detailed the OpenRTB protocol implementation, GBDT-based CTR prediction, feature engineering pipeline, and timeout handling strategies.</p>
<p><strong><a href="/blog/ads-platform-part-3-data-revenue/">Part 3</a></strong> built the data layer - L1/L2/L3 cache hierarchy (Caffeine → Redis/Valkey → CockroachDB) achieving 78-88% hit rates and sub-10ms reads. We covered eCPM-based auction mechanisms for fair price comparison across CPM/CPC/CPA models, and distributed budget pacing using atomic operations with proven ≤1% overspend guarantee.</p>
<p><strong><a href="/blog/ads-platform-part-4-production/">Part 4</a></strong> addressed production operations - pattern-based fraud detection (20-30% bot filtering), active-active multi-region deployment with 2-5min failover, zero-downtime schema evolution, clock synchronization for financial ledgers, observability with error budgets, zero-trust security, and chaos engineering validation.</p>
<p><strong>Part 5 (this post)</strong> brings it all together - the complete technology stack with concrete choices, detailed configurations, and integration patterns. This is where abstract requirements become a deployable system.</p>
<h3 id="what-this-post-covers">What This Post Covers</h3>
<ol>
<li><strong>Complete Technology Stack</strong> - Every component with specific versions, rationale, and alternatives considered</li>
<li><strong>Technology Decision Framework</strong> - The five criteria used for every choice</li>
<li><strong>Runtime &amp; Infrastructure</strong> - Java 21 + ZGC configuration, Kubernetes cluster setup, container orchestration</li>
<li><strong>Communication Layer</strong> - gRPC setup with connection pooling, Linkerd service mesh configuration</li>
<li><strong>Data Layer</strong> - CockroachDB cluster topology, Valkey sharding strategy, Caffeine cache sizing</li>
<li><strong>Feature Platform</strong> - Tecton architecture (Offline: Spark + Rift, Online: Redis), Flink integration</li>
<li><strong>Observability</strong> - Prometheus + Thanos multi-region setup, Tempo sampling strategy, Grafana dashboards</li>
<li><strong>Integration Patterns</strong> - How all components work together as a cohesive system</li>
<li><strong>Validation</strong> - How the final architecture meets Part 1’s requirements</li>
</ol>
<p>Let’s dive into the decisions.</p>
<hr />
<h2 id="complete-technology-stack">Complete Technology Stack</h2>
<p>Here’s the final stack, organized by layer:</p>
<h3 id="application-layer">Application Layer</h3>
<table><thead><tr><th>Component</th><th>Technology</th><th>Version</th><th>Rationale</th></tr></thead><tbody>
<tr><td><strong>Ad Server Orchestrator</strong></td><td>Java + Spring Boot</td><td>21 LTS</td><td>Ecosystem maturity, ZGC availability, team expertise</td></tr>
<tr><td><strong>Garbage Collector</strong></td><td>ZGC (Z Garbage Collector)</td><td>Java 21+</td><td>&lt;1ms p99.9 pauses, eliminates GC as P99 contributor</td></tr>
<tr><td><strong>User Profile Service</strong></td><td>Java + Spring Boot</td><td>21 LTS</td><td>Dual-mode architecture (identity + contextual fallback), consistency with orchestrator</td></tr>
<tr><td><strong>ML Inference</strong></td><td>GBDT (LightGBM/XGBoost)</td><td>-</td><td>Day-1 CTR prediction, 20ms inference. Evolution path: two-pass ranking with distilled DNN reranker (see <a href="/blog/ads-platform-part-2-rtb-ml-pipeline/#model-architecture-gradient-boosted-trees-vs-neural-networks">Part 2</a>)</td></tr>
<tr><td><strong>Budget Service</strong></td><td>Java + Spring Boot</td><td>21 LTS</td><td>Strong consistency requirements, atomic operations</td></tr>
<tr><td><strong>RTB Gateway</strong></td><td>Java + Spring Boot</td><td>21 LTS</td><td>HTTP/2 connection pooling, protobuf support</td></tr>
<tr><td><strong>Integrity Check</strong></td><td>Go</td><td>1.21+</td><td>Sub-ms latency, minimal resource footprint, stateless filtering</td></tr>
</tbody></table>
<h3 id="communication-layer">Communication Layer</h3>
<table><thead><tr><th>Component</th><th>Technology</th><th>Rationale</th></tr></thead><tbody>
<tr><td><strong>Internal RPC</strong></td><td>gRPC over HTTP/2</td><td>Binary serialization (3-10× smaller than JSON), type safety, &lt;1ms overhead</td></tr>
<tr><td><strong>External API</strong></td><td>REST/JSON over HTTP/2</td><td>OpenRTB standard compliance, DSP compatibility</td></tr>
<tr><td><strong>Service Mesh</strong></td><td>Linkerd</td><td>Lightweight (5-10ms overhead), native gRPC support, mTLS</td></tr>
<tr><td><strong>Service Discovery</strong></td><td>Kubernetes DNS</td><td>Built-in, no external dependencies, &lt;1ms resolution</td></tr>
<tr><td><strong>Load Balancing</strong></td><td>Kubernetes Service + gRPC client-side</td><td>L7 awareness, connection-level distribution</td></tr>
</tbody></table>
<h3 id="data-layer">Data Layer</h3>
<table><thead><tr><th>Component</th><th>Technology</th><th>Rationale</th></tr></thead><tbody>
<tr><td><strong>L3: Transactional DB</strong></td><td>CockroachDB Serverless</td><td>User profiles, campaigns, billing ledger. Strong consistency, cross-region ACID transactions, HLC timestamps. 50-75% cheaper than DynamoDB, fully managed. Self-hosted break-even depends on operational costs (see capacity planning).</td></tr>
<tr><td><strong>L2: Distributed Cache</strong></td><td>Valkey 7.x (Redis fork)</td><td>Budget counters (DECRBY atomic), L2 cache, rate limit tokens. Sub-ms latency, permissive BSD-3 license</td></tr>
<tr><td><strong>L1: In-Process Cache</strong></td><td>Caffeine</td><td>Hot user profiles, 60-70% hit rate. 8-12× faster than Redis, JVM-native, excellent eviction</td></tr>
<tr><td><strong>Feature Store</strong></td><td>Tecton (managed)</td><td>Batch (Spark) + Streaming (Rift) + Real-time online store. Sub-10ms P99, Redis-backed</td></tr>
</tbody></table>
<h3 id="infrastructure-layer">Infrastructure Layer</h3>
<table><thead><tr><th>Component</th><th>Technology</th><th>Rationale</th></tr></thead><tbody>
<tr><td><strong>Container Orchestration</strong></td><td>Kubernetes 1.28 or later</td><td>Industry standard, declarative config, auto-scaling, multi-region federation</td></tr>
<tr><td><strong>Container Runtime</strong></td><td>containerd</td><td>Lightweight, OCI-compliant, lower overhead than Docker</td></tr>
<tr><td><strong>Cloud Provider</strong></td><td>AWS (multi-region)</td><td>Broadest service coverage, mature networking (VPC peering, Transit Gateway)</td></tr>
<tr><td><strong>Regions</strong></td><td>us-east-1, us-west-2, eu-west-1</td><td>Geographic distribution, &lt;50ms inter-region latency</td></tr>
<tr><td><strong>CDN/Edge</strong></td><td>CloudFront + Lambda@Edge</td><td>Global PoPs, request routing, geo-filtering</td></tr>
</tbody></table>
<h3 id="observability-layer">Observability Layer</h3>
<table><thead><tr><th>Component</th><th>Technology</th><th>Rationale</th></tr></thead><tbody>
<tr><td><strong>Metrics</strong></td><td>Prometheus + Thanos</td><td>Kubernetes-native, multi-region aggregation, PromQL for SLO queries</td></tr>
<tr><td><strong>Distributed Tracing</strong></td><td>OpenTelemetry + Tempo</td><td>Vendor-neutral, low overhead, latency analysis across services</td></tr>
<tr><td><strong>Logging</strong></td><td>Fluentd + Loki</td><td>Structured logs, label-based querying, cost-effective storage</td></tr>
<tr><td><strong>Alerting</strong></td><td>Alertmanager</td><td>Integrated with Prometheus, SLO-based alerts, escalation policies</td></tr>
</tbody></table>
<hr />
<h2 id="technology-decision-framework">Technology Decision Framework</h2>
<p>Every technology choice in this architecture was evaluated against five criteria:</p>
<h3 id="1-latency-impact">1. Latency Impact</h3>
<p>Does it fit within the component’s latency budget? (From <a href="/blog/ads-platform-part-1-foundation-architecture/#latency-budget-decomposition">Part 1’s latency decomposition</a>)</p>
<ul>
<li>Example: ZGC’s &lt;2ms pauses vs G1GC’s 41-55ms pauses</li>
<li>Example: gRPC’s binary protocol vs JSON’s parsing overhead</li>
</ul>
<h3 id="2-operational-complexity">2. Operational Complexity</h3>
<p>How many additional systems, proxies, or failure modes does it introduce?</p>
<ul>
<li>Example: Envoy Gateway + Linkerd (same proxy) vs Kong + Istio (two different proxies)</li>
<li>Example: Tecton (managed) vs self-hosted Feast</li>
</ul>
<h3 id="3-cost-efficiency">3. Cost Efficiency</h3>
<p>What’s the total cost of ownership at 1M+ QPS scale?</p>
<ul>
<li>Example: CockroachDB 2-3× cheaper than DynamoDB at 1M+ QPS (post-Nov 2024 pricing)</li>
<li>Example: Kubernetes bin-packing achieves 60% more capacity than VMs</li>
</ul>
<h3 id="4-team-expertise">4. Team Expertise</h3>
<p>Can the team operate it effectively, or does it require hiring specialists?</p>
<ul>
<li>Example: Java ecosystem maturity vs Go’s smaller tooling ecosystem</li>
<li>Example: Postgres-compatible CockroachDB vs learning Spanner</li>
</ul>
<h3 id="5-production-validation">5. Production Validation</h3>
<p>Has it been proven at similar scale by other companies?</p>
<ul>
<li>Example: Netflix’s ZGC validation at scale</li>
<li>Example: LinkedIn’s Valkey adoption</li>
</ul>
<p>When trade-offs were necessary, <strong>latency always won</strong> - because every millisecond lost reduces revenue at 1M+ QPS.</p>
<hr />
<h2 id="runtime-garbage-collection-java-21-zgc">Runtime &amp; Garbage Collection: Java 21 + ZGC</h2>
<h3 id="decision-java-21-generational-zgc">Decision: Java 21 + Generational ZGC</h3>
<p><strong>Why Java over Go/Rust:</strong></p>
<ol>
<li><strong>Ecosystem maturity</strong>: Battle-tested libraries for ads (OpenRTB, protobuf, gRPC), mature monitoring tools</li>
<li><strong>Team expertise</strong>: Java developers are easier to hire than Rust specialists</li>
<li><strong>Sub-millisecond GC</strong>: Modern ZGC eliminates GC as a latency source</li>
</ol>
<p><strong>Why ZGC over G1GC/Shenandoah:</strong></p>
<ul>
<li><strong>G1GC</strong>: Stop-the-world pauses of 41-55ms at P99.9 - consumes 30% of latency budget</li>
<li><strong>Shenandoah</strong>: Concurrent, but higher CPU overhead (15-20% vs ZGC’s 10%)</li>
<li><strong>ZGC</strong>: Sub-10ms pauses typical, design goal &lt;1ms. Netflix production deployment (March 2024) on JDK 21 with Generational ZGC reports “no explicit tuning required” for critical streaming services. Achievable with proper heap sizing and allocation rate management.</li>
</ul>
<h3 id="zgc-configuration">ZGC Configuration</h3>
<p><strong>Key Configuration Decisions:</strong></p>
<p><strong>Heap Sizing:</strong> 32GB heap chosen based on allocation rate analysis. With 5,000 QPS per instance and average request creating ~50KB objects, allocation rate reaches 250 MB/sec. At this rate with ZGC’s concurrent collection, heap cycles every ~2 minutes at 50% utilization.</p>
<p><strong>Why 32GB:</strong></p>
<ul>
<li>Large enough to avoid frequent GC cycles (allocation rate 250 MB/sec)</li>
<li>Small enough for fast evacuation during compaction phases</li>
<li>Matches EC2 instance memory profile: 64GB total (32GB JVM heap + 32GB OS page cache for Redis/file operations)</li>
</ul>
<p><strong>Thread Pool Strategy:</strong></p>
<ul>
<li><strong>Request threads</strong>: 200 virtual threads (Java 21 Project Loom) - lightweight execution without OS thread limitations, enabling high concurrency without thread pool exhaustion</li>
<li><strong>gRPC threads</strong>: 32 threads (2× CPU cores) dedicated to I/O operations for handling network communication with downstream services</li>
<li><strong>Background tasks</strong>: 16 threads for async operations like event publishing to Kafka and cache warming</li>
</ul>
<p><strong>Validation:</strong>
From <a href="/blog/ads-platform-part-1-foundation-architecture/#p99-tail-latency-defense-the-unacceptable-tail">Part 1</a>: P99 tail is 10,000 req/sec. With G1GC’s 41-55ms pauses, 410-550 requests would timeout per pause. ZGC’s &lt;2ms P99.9 pauses (32GB heap) affect only 20 requests - <strong>98% reduction in GC-caused timeouts</strong>.</p>
<hr />
<h2 id="communication-layer-grpc-linkerd">Communication Layer: gRPC + Linkerd</h2>
<h3 id="grpc-configuration">gRPC Configuration</h3>
<p><strong>Why gRPC over REST/JSON:</strong>
From <a href="/blog/ads-platform-part-1-foundation-architecture/#latency-budget-decomposition">Part 1’s latency budget</a>, service-to-service calls must be &lt;10ms. JSON parsing overhead adds 2-5ms per request.</p>
<ul>
<li><strong>Protocol buffers</strong>: 3-10× smaller than JSON, zero-copy deserialization</li>
<li><strong>HTTP/2 multiplexing</strong>: Single TCP connection carries multiple RPCs</li>
<li><strong>Streaming</strong>: Supports bidirectional streaming (useful for RTB auctions)</li>
</ul>
<p><strong>Connection Pooling Strategy:</strong></p>
<p>Each Ad Server instance maintains <strong>32 persistent connections</strong> to each downstream service. At 5,000 QPS per instance, this yields ~156 requests per second per connection, effectively reusing connections and avoiding expensive connection establishment overhead (TLS handshakes cost 10-20ms).</p>
<p><strong>Key configuration decisions:</strong></p>
<ul>
<li><strong>Keepalive pings (60s intervals)</strong>: Detect dead connections proactively before requests fail</li>
<li><strong>Keepalive timeout (20s)</strong>: Close unresponsive connections to prevent request accumulation</li>
<li><strong>Message size limit (4MB)</strong>: Prevents memory exhaustion from unexpectedly large responses</li>
<li><strong>Plaintext transport</strong>: Encryption handled by Linkerd service mesh at proxy layer, avoiding double-encryption overhead</li>
</ul>
<p><strong>Load balancing:</strong> Round-robin distribution across service replicas with DNS-based service discovery (Kubernetes DNS provides automatic endpoint updates).</p>
<p><strong>Retry Policy:</strong> Maximum 2 attempts with exponential backoff (10ms → 50ms). <strong>Critical:</strong> Only retry UNAVAILABLE status (service temporarily down), never DEADLINE_EXCEEDED (timeout) - retrying timeouts amplifies cascading failures under load.</p>
<h3 id="service-mesh-linkerd">Service Mesh: Linkerd</h3>
<p><strong>Decision: Linkerd over Istio</strong></p>
<p>From <a href="/blog/ads-platform-part-1-foundation-architecture/#latency-budget-decomposition">Part 1</a>: We need &lt;5ms gateway overhead, sub-10ms service-to-service latency.</p>
<p><strong>Benchmarks:</strong></p>
<ul>
<li><strong>Linkerd P99</strong>: 5-10ms overhead</li>
<li><strong>Istio P99</strong>: 15-25ms overhead</li>
<li><strong>Academic validation</strong>: Istio added 166% latency with mTLS, Linkerd added 33%</li>
</ul>
<p><strong>Why Linkerd:</strong></p>
<ol>
<li><strong>Lower latency</strong>: 5-10ms vs Istio’s 15-25ms</li>
<li><strong>Lower resource usage</strong>: ~50MB memory per proxy vs Envoy’s ~150MB</li>
<li><strong>Rust-based proxy</strong>: linkerd2-proxy is lighter than Envoy (C++)</li>
<li><strong>gRPC-native</strong>: Zero-copy proxying for gRPC (our primary protocol)</li>
</ol>
<p><strong>Configuration:</strong></p>
<p>Service profile for User Profile Service:
<strong>Service Profile Configuration:</strong> Linkerd ServiceProfiles define per-route behavior for fine-grained traffic management:</p>
<ul>
<li><strong>GetProfile route</strong>: 10ms timeout, non-retryable (profile lookups must be fast or fail)</li>
<li><strong>BatchGetProfiles route</strong>: 15ms timeout, retryable on 5xx errors with max 1 retry (batch operations tolerate single retry without cascading delays)</li>
</ul>
<p>This per-route configuration ensures timeouts match <a href="/blog/ads-platform-part-1-foundation-architecture/#latency-budget-decomposition">Part 1’s latency budget</a> while preventing retry storms during service degradation.</p>
<p><strong>mTLS (Mutual TLS) Encryption:</strong></p>
<ul>
<li>Automatic certificate rotation every 24 hours prevents long-lived certificate compromise</li>
<li>Certificates issued by Linkerd’s built-in CA with trust-anchor certificate establishing root of trust</li>
<li><strong>Zero application code changes</strong> - mTLS handled transparently at proxy layer, services communicate over plaintext internally</li>
</ul>
<p><strong>Traffic Splitting for Canary Deployments:</strong> Linkerd’s SMI TrafficSplit API enables gradual rollouts by weight-based routing:</p>
<ul>
<li><strong>90% traffic → stable version</strong> (proven reliability)</li>
<li><strong>10% traffic → canary version</strong> (testing new deployment)</li>
<li>Monitor error rates, latency P99, and business metrics</li>
<li>If healthy, increase canary weight to 100% over 2-4 hours</li>
<li>If degraded, instant rollback by setting canary weight to 0%</li>
</ul>
<p>This pattern (detailed in <a href="/blog/ads-platform-part-4-production/#production-operations-at-scale">Part 4 Production Operations</a>) reduces blast radius of defects while maintaining production velocity.</p>
<h3 id="api-gateway-envoy-gateway-decision">API Gateway: Envoy Gateway Decision</h3>
<p>From <a href="/blog/ads-platform-part-1-foundation-architecture/#latency-budget-decomposition">Part 1’s latency budget</a>, gateway operations (authentication, rate limiting, routing) must complete within 4-5ms to preserve 150ms SLO. Envoy Gateway achieves 2-4ms total overhead: JWT auth via ext_authz filter (1-2ms, cached 60s), rate limiting via Valkey token bucket (0.5ms atomic DECR), routing decisions (1-1.5ms). Production measurements: P50 2.8ms, P99 4.2ms.</p>
<h4 id="technology-comparison">Technology Comparison</h4>
<table><thead><tr><th>Gateway</th><th>Latency Overhead</th><th>Memory per Pod</th><th>Operational Complexity</th><th>Kubernetes-Native</th></tr></thead><tbody>
<tr><td><strong>Envoy Gateway</strong></td><td><strong>2-4ms</strong></td><td>50-80MB</td><td>Low (Envoy config only)</td><td>Gateway API native</td></tr>
<tr><td><strong>Kong</strong></td><td>10-15ms</td><td>150-200MB</td><td>Medium (plugin ecosystem learning curve)</td><td>CRD-based</td></tr>
<tr><td><strong>Traefik</strong></td><td>5-8ms</td><td>100-120MB</td><td>Medium (label-based config, less flexible)</td><td>Gateway API support</td></tr>
<tr><td><strong>NGINX Ingress</strong></td><td>3-6ms</td><td>80-100MB</td><td>Medium (annotation-heavy, error-prone)</td><td>Annotation-based</td></tr>
</tbody></table>
<p><strong>Kong rejected:</strong> 10-15ms latency (7-10% of budget), 150-200MB memory, different proxy tech from service mesh (Kong Lua + Istio Envoy = 20-30ms combined overhead). <strong>NGINX rejected:</strong> annotation-based config error-prone (<code>nginx.ingress.kubernetes.io/rate-limit</code> typo fails silently), no native gRPC support, external rate-limit sidecar complexity. <strong>Traefik rejected:</strong> label-based config insufficient for RTB’s sophisticated timeout/header transformation requirements.</p>
<h4 id="unified-proxy-stack-with-linkerd-service-mesh">Unified Proxy Stack with Linkerd Service Mesh</h4>
<p>Platform handles two traffic patterns: <strong>north-south</strong> (external → cluster via Envoy Gateway) and <strong>east-west</strong> (internal service-to-service via Linkerd). Both use Envoy proxy technology, enabling smooth transitions without double-proxying overhead. Alternative (Kong + Istio) requires learning two proxies, separate observability, 20-30ms combined latency.</p>
<p><strong>Traffic flow:</strong> External request → Envoy Gateway (TLS termination, JWT validation, rate limiting) → Linkerd sidecar (mTLS encryption, load balancing, retries) → Ad Server → internal calls via Linkerd (automatic mTLS, observability). Each service hop adds ~1ms Linkerd overhead; 3-4 hops = 3-4ms total, well within budget. Achieves zero-trust (every call authenticated/encrypted) without code changes.</p>
<p><strong>Gateway API benefits:</strong> HTTPRoute enables per-DSP timeout policies and header transformations declaratively. ReferenceGrant provides namespace isolation for multi-tenant deployments. Native HTTP/2, gRPC, WebSocket support eliminates manual proxy_pass configuration for RTB bidstream.</p>
<p><strong>Trade-off:</strong> Smaller plugin ecosystem vs Kong. Complex transformations (GraphQL→REST) implemented as dedicated microservices rather than gateway plugins, preserving low latency while allowing independent scaling.</p>
<hr />
<h2 id="container-orchestration-kubernetes">Container Orchestration: Kubernetes</h2>
<h3 id="why-kubernetes-over-raw-ec2-vms">Why Kubernetes over Raw EC2/VMs</h3>
<p><strong>Kubernetes Provides:</strong></p>
<ol>
<li><strong>Declarative Configuration</strong>: Define desired state, Kubernetes reconciles</li>
<li><strong>Auto-Scaling</strong>: Horizontal Pod Autoscaler (HPA) scales based on metrics</li>
<li><strong>Self-Healing</strong>: Automatic pod restarts, node failure recovery</li>
<li><strong>Service Discovery</strong>: Built-in DNS, no external registry needed</li>
<li><strong>Rolling Updates</strong>: Zero-downtime deployments with health checks</li>
<li><strong>Multi-Region Federation</strong>: Cluster federation for global deployment</li>
</ol>
<p><strong>Why Not Raw EC2:</strong></p>
<ul>
<li><strong>Manual scaling</strong>: Auto-scaling groups lack app-aware logic</li>
<li><strong>No service discovery</strong>: Requires external registry (Consul, Eureka)</li>
<li><strong>Deployment complexity</strong>: Blue-green deploys require custom automation</li>
<li><strong>Resource utilization</strong>: VMs waste capacity, containers pack efficiently</li>
</ul>
<p><strong>Resource Efficiency Example:</strong></p>
<ul>
<li><strong>EC2</strong>: 300 instances × 8 vCPU × 50% avg utilization = 1,200 vCPUs utilized</li>
<li><strong>Kubernetes</strong>: 150 nodes × 16 vCPU × 80% avg utilization = 1,920 vCPUs utilized</li>
<li><strong>Gain</strong>: (1,920 - 1,200) / 1,200 = 60%</li>
<li><strong>Result</strong>: <strong>60% more capacity</strong> from the same infrastructure via bin-packing</li>
</ul>
<h3 id="kubernetes-architecture">Kubernetes Architecture</h3>
<p><strong>Cluster Configuration:</strong></p>
<ul>
<li><strong>Node count</strong>: 150 nodes across 3 regions (50 nodes per region)</li>
<li><strong>Node type</strong>: c6i.4xlarge (16 vCPU, 32 GB RAM)</li>
<li><strong>Pod density</strong>: ~10-12 pods per node (avg)</li>
<li><strong>Total pods</strong>: ~1,500 pods across cluster
<ul>
<li>300 Ad Server Orchestrator instances</li>
<li>150 User Profile Service pods (50 per region)</li>
<li>150 ML Inference pods (50 per region)</li>
<li>150 RTB Gateway pods (50 per region)</li>
<li>90 Budget Service pods (30 per region)</li>
<li>90 Auction Service pods (30 per region)</li>
<li>90 Integrity Check pods (30 per region)</li>
<li>90 Redis/Valkey nodes (30 per region)</li>
<li>90 Kafka brokers (30 per region)</li>
<li>150 observability stack (Prometheus, Grafana, Tempo, Loki)</li>
<li>150 system pods (kube-system, ingress controllers, operators)</li>
</ul>
</li>
</ul>
<p><strong>Namespaces:</strong></p>
<ul>
<li><code>production</code>: Live traffic (1M QPS)</li>
<li><code>staging</code>: Pre-production validation</li>
<li><code>canary</code>: Traffic shadowing and A/B tests</li>
<li><code>monitoring</code>: Prometheus, Grafana, Alertmanager</li>
</ul>
<p><strong>Auto-Scaling Strategy:</strong></p>
<p>Horizontal Pod Autoscaler (HPA) monitors both CPU utilization (target: 70%) and custom metrics (requests per second per pod). Scaling triggers when pods exceed 5K QPS threshold. Scale-up happens aggressively (50% increase) with 60-second stabilization window, while scale-down is conservative (10% reduction) with 5-minute stabilization to avoid flapping. Minimum 200 pods ensures baseline capacity, maximum 400 pods caps burst handling.</p>
<p><strong>Why containerd over Docker:</strong></p>
<ul>
<li><strong>Lightweight</strong>: Lower overhead, faster pod startup</li>
<li><strong>OCI-compliant</strong>: Standard container runtime interface</li>
<li><strong>Kubernetes-native</strong>: First-class support, no shim layer</li>
</ul>
<hr />
<h2 id="data-layer-cockroachdb-cluster">Data Layer: CockroachDB Cluster</h2>
<h3 id="decision-cockroachdb-over-postgresql-spanner-dynamodb">Decision: CockroachDB over PostgreSQL/Spanner/DynamoDB</h3>
<p>From <a href="/blog/ads-platform-part-1-foundation-architecture/">Part 1</a> and <a href="/blog/ads-platform-part-3-data-revenue/">Part 3</a>: Need strongly-consistent transactional database for billing ledger, multi-region active-active, 10-15ms latency.</p>
<p><strong>Why CockroachDB:</strong></p>
<ol>
<li><strong>2-3× cheaper than DynamoDB</strong> at 1M+ QPS (see cost breakdown below)</li>
<li><strong>Postgres-compatible</strong> - existing team expertise, tooling compatibility</li>
<li><strong>HLC timestamps</strong> for linearizable billing events (Part 3 requirement)</li>
<li><strong>Multi-region native</strong> - automatic replication, leader election</li>
<li><strong>No vendor lock-in</strong> (vs Spanner’s Google-only deployment)</li>
</ol>
<p><strong>Cost comparison (1M QPS, 8 billion writes/day):</strong></p>
<ul>
<li>DynamoDB: 100% baseline (on-demand pricing per AWS published rates)</li>
<li>CockroachDB (60 compute nodes): ~45% of DynamoDB cost</li>
<li><strong>Savings: ~55% infrastructure cost reduction</strong></li>
</ul>
<h3 id="cluster-topology">Cluster Topology</h3>
<p><strong>Day-1 Choice: CockroachDB Serverless</strong></p>
<ul>
<li>Fully managed by Cockroach Labs</li>
<li>Pay-per-use pricing (~40-50% of DynamoDB)</li>
<li>Auto-scaling capacity (no manual node management)</li>
<li>Same features as self-hosted (cross-region ACID, HLC, SQL)</li>
</ul>
<p><strong>Self-Hosted Configuration (if operational costs justify it):</strong></p>
<ul>
<li><strong>60-80 nodes</strong> across 3 AWS regions (us-east-1, us-west-2, eu-west-1)</li>
<li><strong>20-27 nodes per region</strong> (distributed across 3 availability zones)</li>
<li><strong>Replication factor: 5</strong> (2 replicas in home region, 1 in each remote region)</li>
<li><strong>Node specs</strong>: c5.4xlarge (16 vCPU, 32GB RAM, 500GB NVMe SSD per node)</li>
</ul>
<p><strong>Why 60-80 nodes (self-hosted sizing):</strong>
From benchmarks: CockroachDB achieves 400K QPS (99% reads) with 20 nodes, 1.2M QPS (write-heavy) with 200 nodes.</p>
<p>Our workload: ~70% reads, ~30% writes, 1M+ QPS total → 60-80 nodes provides headroom.</p>
<p><strong>Sizing Strategy:</strong> Database is sized for <strong>sustained load</strong> (1M QPS baseline), while Ad Server instances are sized for <strong>peak capacity</strong> (1.5M QPS with 50% headroom). This is intentional: databases scale slowly (adding nodes requires rebalancing), while stateless Ad Servers scale instantly (spin up pods). During traffic bursts to 1.5M QPS, cache hit rates absorb most load (95% hits = only 75K additional DB queries), keeping database well within capacity.</p>
<p><strong>Decision point:</strong> Evaluate self-hosted when infrastructure savings exceed operational costs. Break-even varies significantly: US-based SRE team (3-5 engineers) requires 20-30B req/day, while global/regional teams with existing database expertise may break even at 4-8B req/day. See <a href="/blog/ads-platform-part-3-data-revenue/#transactional-database-cockroachdb-vs-alternatives">Part 3’s database cost comparison</a> for detailed break-even analysis with geographic and team structure scenarios.</p>
<p><strong>Multi-Region Deployment:</strong></p>
<p><strong>Database Architecture:</strong> CockroachDB deployed with us-east-1 as primary region and us-west-2, eu-west-1 as secondary regions. The database is configured with SURVIVE REGION FAILURE semantics, requiring 5-way replication with a 2-1-1-1 replica distribution pattern (2 replicas in the primary region for fast quorum, 1 replica in each secondary region for disaster recovery).</p>
<p><strong>Schema Design Decisions:</strong></p>
<p><strong>Billing Ledger Table</strong> uses several critical design patterns:</p>
<ul>
<li><strong>UUID primary keys:</strong> Globally unique identifiers enable conflict-free writes across regions without coordination, essential for multi-region active-active pattern from <a href="/blog/ads-platform-part-4-production/#multi-region-deployment-and-failover">Part 4</a></li>
<li><strong>Integer amount storage:</strong> DECIMAL type for financial precision eliminates floating-point rounding errors that would violate <a href="/blog/ads-platform-part-3-data-revenue/#budget-pacing-distributed-spend-control">Part 3’s ≤1% accuracy requirement</a></li>
<li><strong>HLC timestamp column:</strong> Hybrid Logical Clock (combination of physical timestamp + logical counter) provides linearizable ordering across regions for audit trails. Critical for resolving event ordering when physical clocks drift (addressed in <a href="/blog/ads-platform-part-4-production/#distributed-clock-synchronization-and-time-consistency">Part 4’s clock synchronization</a>)</li>
<li><strong>Composite index:</strong> Campaign ID + event time enables efficient queries for billing reconciliation and dispute resolution without full table scans</li>
<li><strong>REGIONAL BY ROW locality:</strong> Each row stored in the region closest to access pattern (determined by user geography), reducing cross-region queries from 50-100ms to 1-2ms for common operations</li>
</ul>
<p><strong>Connection Pooling:</strong></p>
<ul>
<li>Each Ad Server instance: 20 connections to CockroachDB cluster</li>
<li>Total: 300 instances × 20 connections = 6,000 connections across 60 nodes = 100 connections/node</li>
<li>CockroachDB limit: 5,000 connections/node - well within capacity</li>
</ul>
<p><strong>Latency breakdown:</strong></p>
<ul>
<li><strong>Intra-AZ read</strong>: 1-2ms (single replica query)</li>
<li><strong>Cross-AZ read (same region)</strong>: 5-8ms (network latency)</li>
<li><strong>Cross-region read</strong>: 10-15ms (Part 5 claim - applies to cross-region queries)</li>
</ul>
<p>From <a href="/blog/ads-platform-part-1-foundation-architecture/#latency-budget-decomposition">Part 1</a>: L3 cache (CockroachDB) is the fallback, accessed only on L1/L2 misses (5-10% of requests). The 10-15ms latency applies to these rare cross-region misses.</p>
<hr />
<h2 id="capacity-planning-sizing-model">Capacity Planning &amp; Sizing Model</h2>
<h3 id="instance-count-formulas">Instance Count Formulas</h3>
<p><strong>Core Sizing Principle:</strong></p>
<p>$$\text{Instance Count} = \frac{\text{Target QPS} \times 1.5}{\text{QPS per Instance}}$$</p>
<p><strong>Safety Factor = 1.5</strong> accounts for: traffic bursts, regional failover (one region down → 2 remaining absorb 50% more load), and deployment headroom.</p>
<p><strong>Ad Server Orchestrator (Critical Path):</strong></p>
<p>$$N_{ads} = \frac{Q_{target} \times 1.5}{5,000}$$</p>
<p><strong>Example at 1M QPS:</strong>
$$N_{ads} = \frac{1,000,000 \times 1.5}{5,000} = 300 \text{ instances}$$</p>
<p><strong>Why 5K QPS per instance?</strong> Measured from load testing:</p>
<ul>
<li>32GB heap with ZGC → 250 MB/sec allocation rate</li>
<li>200 virtual threads (Java 21 Loom) → handles concurrent RTB calls</li>
<li>gRPC connection pooling → 32 connections per downstream service</li>
<li>At 5K QPS: avg CPU 60-70%, P99 latency ~140ms (within 150ms SLO)</li>
</ul>
<p><strong>User Profile Service (Cache-Heavy):</strong></p>
<p>$$N_{profile} = \frac{Q_{target} \times 1.5}{10,000}$$</p>
<p><strong>Why 10K QPS per instance?</strong> Read-heavy workload:</p>
<ul>
<li>L1 cache (60% hit) → sub-millisecond, no backend call</li>
<li>L2 cache (25% hit) → 2-3ms Valkey read</li>
<li>L3 database (15% miss) → 10-15ms CockroachDB read</li>
<li>Lightweight service: 4GB RAM, minimal CPU</li>
</ul>
<p><strong>ML Inference Service (Compute-Heavy):</strong></p>
<p>$$N_{ml} = \frac{Q_{target} \times 1.5}{1,000}$$</p>
<p><strong>Why only 1K QPS per instance?</strong> GBDT inference is CPU-intensive:</p>
<ul>
<li>LightGBM with 200 trees, depth 6, 500+ features</li>
<li>~20ms P50, ~40ms P99 per prediction</li>
<li>16GB RAM for model + feature cache</li>
<li>4 vCPU fully utilized</li>
</ul>
<p><strong>RTB Gateway (I/O Bound):</strong></p>
<p>$$N_{rtb} = \frac{Q_{target} \times 1.5}{10,000}$$</p>
<p><strong>Why 10K QPS per instance?</strong> Network I/O bound, not CPU:</p>
<ul>
<li>HTTP/2 connection pooling to 50+ DSPs</li>
<li>Async I/O (waiting for DSP responses, not computing)</li>
<li>Timeout handling at 100ms</li>
<li>Low memory footprint: 4GB RAM</li>
</ul>
<p><strong>Budget Service (Redis-Backed):</strong></p>
<p>$$N_{budget} = \frac{Q_{target} \times 1.5}{50,000}$$</p>
<p><strong>Why 50K QPS per instance?</strong> Extremely lightweight:</p>
<ul>
<li>Single Redis EVAL call per request (atomic budget check)</li>
<li>3ms P50, 5ms P99 latency</li>
<li>Minimal CPU and memory (2GB RAM)</li>
<li>Network latency dominant, not compute</li>
</ul>
<p><strong>CockroachDB Sizing (Benchmark-Driven):</strong></p>
<p>From official benchmarks:</p>
<ul>
<li><strong>Read-heavy (99% reads):</strong> 20 nodes → 400K QPS</li>
<li><strong>Write-heavy (50% writes):</strong> 200 nodes → 1.2M QPS</li>
<li><strong>Our workload (70% reads, 30% writes):</strong> Interpolate</li>
</ul>
<p>$$N_{crdb} = 20 + \left(\frac{Q_{target} - 400K}{800K}\right) \times 180$$</p>
<p><strong>Example at 1M QPS:</strong>
$$N_{crdb} = 20 + \left(\frac{1M - 400K}{800K}\right) \times 180 = 20 + 135 = 155 \text{ nodes (theoretical)}$$</p>
<p><strong>BUT:</strong> With 78-88% cache hit rate (from <a href="/blog/ads-platform-part-3-data-revenue/#cache-performance-analysis">Part 3</a>):</p>
<ul>
<li>Only 12-22% of traffic hits database</li>
<li>Effective DB load: 120K-220K QPS</li>
<li><strong>Actual sizing: 60-80 nodes</strong> (provides 2-3× headroom over effective load)</li>
</ul>
<p><strong>Valkey/Redis Sizing:</strong></p>
<p>From Valkey 8.1 benchmarks: 1M RPS per 16 vCPU instance</p>
<p>$$N_{cache} = \frac{Q_{target} \times \text{Cache Traffic \%}}{1M}$$</p>
<p><strong>Example at 1M QPS:</strong></p>
<ul>
<li>L2 cache handles: 25% of traffic (L1 misses)</li>
<li>Rate limiting: ~1M checks/sec (token bucket)</li>
<li>Budget pacing: ~1M atomic operations/sec</li>
<li><strong>Total cache load:</strong> ~1.25M RPS</li>
<li><strong>Instances needed:</strong> ~2 per region × 3 regions = <strong>6 instances minimum, 30 for redundancy</strong></li>
</ul>
<h3 id="per-service-resource-requirements">Per-Service Resource Requirements</h3>
<table><thead><tr><th>Service</th><th>vCPU/Pod</th><th>RAM/Pod</th><th>Heap (JVM)</th><th>QPS/Pod</th><th>Pods @ 1M QPS</th><th>Total vCPU</th><th>Total RAM</th><th>Notes</th></tr></thead><tbody>
<tr><td><strong>Ad Server Orchestrator</strong></td><td>2</td><td>8GB</td><td>32GB</td><td>5,000</td><td>300</td><td>600</td><td>2,400GB</td><td>ZGC, virtual threads</td></tr>
<tr><td><strong>User Profile Service</strong></td><td>1</td><td>4GB</td><td>-</td><td>10,000</td><td>150</td><td>150</td><td>600GB</td><td>Cache-heavy, read-only</td></tr>
<tr><td><strong>ML Inference Service</strong></td><td>4</td><td>16GB</td><td>-</td><td>500-700</td><td>1,500-2,000</td><td>6,000-8,000</td><td>24,000-32,000GB</td><td>CPU GBDT (20ms inference, requires load testing)</td></tr>
<tr><td><strong>RTB Gateway</strong></td><td>2</td><td>4GB</td><td>16GB</td><td>10,000</td><td>150</td><td>300</td><td>600GB</td><td>HTTP/2, async I/O</td></tr>
<tr><td><strong>Budget Service</strong></td><td>2</td><td>4GB</td><td>16GB</td><td>1,200-1,500</td><td>600-800</td><td>1,200-1,600</td><td>2,400-3,200GB</td><td>Redis-backed (3ms async I/O, requires load testing)</td></tr>
<tr><td><strong>Auction Service</strong></td><td>2</td><td>4GB</td><td>16GB</td><td>10,000-15,000</td><td>70-100</td><td>140-200</td><td>280-400GB</td><td>In-memory ranking (requires load testing)</td></tr>
<tr><td><strong>Integrity Check</strong></td><td>2</td><td>4GB</td><td>16GB</td><td>2,000-3,000</td><td>300-500</td><td>600-1,000</td><td>1,200-2,000GB</td><td>Bloom filter + validation logic (requires load testing)</td></tr>
<tr><td><strong>Feature Store (Tecton)</strong></td><td>2</td><td>8GB</td><td>-</td><td>10,000</td><td>150</td><td>300</td><td>1,200GB</td><td>Managed service</td></tr>
<tr><td><strong>CockroachDB Nodes</strong></td><td>16</td><td>32GB</td><td>-</td><td>~17K</td><td>60</td><td>960</td><td>1,920GB</td><td>c5.4xlarge instances</td></tr>
<tr><td><strong>Valkey Cache Nodes</strong></td><td>8</td><td>64GB</td><td>-</td><td>~42K</td><td>30</td><td>240</td><td>1,920GB</td><td>r5.2xlarge instances</td></tr>
<tr><td><strong>Kafka Brokers</strong></td><td>8</td><td>32GB</td><td>-</td><td>-</td><td>30</td><td>240</td><td>960GB</td><td>Event streaming</td></tr>
<tr><td><strong>Observability Stack</strong></td><td>-</td><td>-</td><td>-</td><td>-</td><td>150</td><td>300</td><td>600GB</td><td>Prometheus, Grafana, Loki</td></tr>
<tr><td><strong>System Pods</strong></td><td>-</td><td>-</td><td>-</td><td>-</td><td>150</td><td>200</td><td>400GB</td><td>kube-system, controllers</td></tr>
<tr><td><strong>TOTAL</strong></td><td>-</td><td>-</td><td>-</td><td>-</td><td><strong>~4,000-4,500</strong></td><td><strong>~12,500-13,500</strong></td><td><strong>~43,000-46,000GB</strong></td><td><strong>1M QPS baseline</strong></td></tr>
</tbody></table>
<p><strong>Key Insights:</strong></p>
<ol>
<li><strong>ML Inference dominates compute:</strong> 6,000-8,000 vCPUs (48-60% of total) for CPU-based GBDT prediction - see <a href="/blog/ads-platform-part-2-ml-infrastructure/#cpu-based-gbdt-inference-architecture-decision">Part 2</a> for CPU vs GPU trade-off analysis</li>
<li><strong>Budget Service requires significant resources:</strong> 1,200-1,600 vCPUs (10-12% of total) despite lightweight operations - async I/O throughput limited by CPU for gRPC parsing/serialization</li>
<li><strong>Memory requirements:</strong> ~43-46TB total RAM across ~200-250 Kubernetes nodes (c6i.4xlarge: 16 vCPU, 32GB RAM or similar)</li>
<li><strong>Pod density:</strong> ~16-20 pods per node average (4,000-4,500 pods / 200-250 nodes)</li>
<li><strong>Database is ~7-8% of compute:</strong> 960 vCPUs (CockroachDB) vs 12,500-13,500 total - cache effectiveness reduces DB load</li>
<li><strong>All QPS estimates require validation:</strong> Throughput calculations based on theoretical CPU time per request - load testing mandatory to validate and optimize actual performance</li>
</ol>
<p><strong>Throughput Estimates: Validation with External Benchmarks</strong></p>
<p>All QPS/Pod estimates are derived from external production benchmarks and theoretical analysis. Each service estimate is validated against published research and real-world case studies.</p>
<p><strong>External Benchmark Baseline:</strong></p>
<p>Industry benchmarks establish realistic throughput expectations for Java microservices:</p>
<ul>
<li>gRPC Java servers: <a href="https://nexthink.com/blog/comparing-grpc-performance">~5,000 QPS per core (tuned), 245K QPS on 8-core VM</a></li>
<li>Spring Boot production: <a href="https://medium.com/@agamkakkar/how-we-scaled-a-spring-boot-app-from-50k-to-1m-requests-per-second-and-what-we-learned-e424b3922d93">1.2M requests/sec peak (optimized), 50K baseline, 31K simple reactive</a></li>
<li>Redis throughput: <a href="https://redis.io/docs/latest/operate/oss_and_stack/management/optimization/benchmarks/">100K+ QPS typical, 1M+ QPS optimized single instance</a></li>
<li>HTTP/2 gateways: <a href="https://www.alibabacloud.com/blog/kubernetes-gateway-selection-nginx-or-envoy_599485">Envoy ~18.5K RPS, Nginx ~15K RPS (benchmark), millions in production (Dropbox)</a></li>
<li>Virtual threads: <a href="https://fusionauth.io/blog/java-http-new-release">120K+ req/sec with java-http library</a></li>
</ul>
<p><strong>Service-by-Service Validation:</strong></p>
<p><strong>1. Ad Server Orchestrator (5,000 QPS per pod, 2 vCPU)</strong></p>
<p>External validation:</p>
<ul>
<li>Spring Boot with virtual threads: <a href="https://medium.com/@dinesharney/designing-high-throughput-spring-boot-microservices-5000-qps-6013b5992ebf">Designing systems for 5000+ QPS</a></li>
<li>gRPC benchmark: 5,000 QPS per core is industry standard for tuned systems</li>
</ul>
<p>Our calculation:</p>
<ul>
<li>Request orchestration: gRPC parsing (0.3ms) + service coordination (0.1ms) + response (0.1ms) = 0.5ms CPU</li>
<li>With virtual threads handling I/O wait for downstream calls (parallel ML + RTB)</li>
<li>Theoretical: 2 cores × 1000ms / 0.5ms = 4,000 QPS</li>
<li>With JVM overhead, GC (ZGC 10-15%), network variance: <strong>5,000 QPS realistic</strong></li>
</ul>
<p>Confidence: HIGH - aligns with published Spring Boot microservice benchmarks at 5K+ QPS</p>
<p><strong>2. User Profile Service (10,000 QPS per pod, 1 vCPU)</strong></p>
<p>External validation:</p>
<ul>
<li>Redis client throughput: 100K+ QPS achievable from single client with pipelining</li>
<li>Cache-heavy read service with minimal CPU processing</li>
</ul>
<p>Our calculation:</p>
<ul>
<li>Cache hit path (85% of requests): gRPC parsing (0.3ms) + local cache lookup (0.01ms) + response (0.1ms) = 0.41ms CPU</li>
<li>Cache miss path (15%): + Redis network call (5ms I/O, 0.1ms CPU overhead) = 0.51ms CPU</li>
<li>Weighted average: 0.85 × 0.41ms + 0.15 × 0.51ms = 0.42ms CPU per request</li>
<li>Theoretical: 1000ms / 0.42ms = ~2,400 QPS per core</li>
<li><strong>With virtual threads allowing 4-5× concurrency for I/O-bound work: 10,000 QPS achievable</strong></li>
</ul>
<p>Confidence: MEDIUM-HIGH - depends on virtual thread efficiency for I/O wait. Actual validation needed.</p>
<p><strong>3. ML Inference Service (500-700 QPS per pod, 4 vCPU)</strong></p>
<p>External validation:</p>
<ul>
<li>GBDT CPU inference: <a href="https://medium.com/whatnot-engineering/6x-faster-ml-inference-why-online-batch-16cbf1203947">10-20ms documented in production case studies</a></li>
<li>LightGBM/XGBoost: CPU-bound, no I/O wait</li>
</ul>
<p>Our calculation:</p>
<ul>
<li>GBDT inference: 20ms CPU (from Part 1 latency budget)</li>
<li>gRPC overhead: 0.5ms</li>
<li>Total: 20.5ms CPU per request</li>
<li>Theoretical: 4 cores × 1000ms / 20.5ms = 195 QPS</li>
<li><strong>With batching (2-4 requests per batch) and optimizations: 500-700 QPS realistic</strong></li>
</ul>
<p>Confidence: HIGH - based on documented GBDT inference latency. Conservative estimate assumes no aggressive batching.</p>
<p><strong>4. RTB Gateway (10,000 QPS per pod, 2 vCPU)</strong></p>
<p>External validation:</p>
<ul>
<li>HTTP/2 gateway benchmarks: <a href="https://www.alibabacloud.com/blog/kubernetes-gateway-selection-nginx-or-envoy_599485">Envoy ~18.5K RPS, production millions</a></li>
<li>Async I/O workload (fan-out to 50 DSPs, collect responses)</li>
</ul>
<p>Our calculation:</p>
<ul>
<li>Request parsing + fan-out coordination: 0.5ms CPU</li>
<li>Network I/O to DSPs: 100ms wait (async, non-blocking)</li>
<li>Response aggregation: 0.3ms CPU</li>
<li>Total CPU: 0.8ms per request</li>
<li>Theoretical: 2 cores × 1000ms / 0.8ms = 2,500 QPS</li>
<li><strong>With async I/O allowing high concurrency: 10,000 QPS realistic</strong></li>
</ul>
<p>Confidence: HIGH - aligns with HTTP/2 gateway benchmarks showing 15K-18K RPS per instance</p>
<p><strong>5. Budget Service (1,200-1,500 QPS per pod, 2 vCPU)</strong></p>
<p>External validation:</p>
<ul>
<li>gRPC with Redis: Industry baseline ~1,000-2,000 QPS per core for I/O-bound workloads</li>
<li>Redis single operation latency: 3ms (from Part 1)</li>
</ul>
<p>Our calculation:</p>
<ul>
<li>gRPC parsing: 0.3ms CPU</li>
<li>Redis DECRBY call: 3ms total (2.5ms I/O wait + 0.5ms CPU for client)</li>
<li>Response: 0.2ms CPU</li>
<li>Total CPU: 1.0ms per request</li>
<li>Theoretical max: 2 cores × 1000ms / 1.0ms = 2,000 QPS per pod</li>
<li><strong>Provisioned target: 1,200-1,500 QPS per pod (60-75% utilization)</strong></li>
</ul>
<p>Rationale: We run pods at 60-75% of theoretical capacity (not 100%) to handle:</p>
<ul>
<li>ZGC pause-less collection (consumes 10-15% CPU even with low pauses)</li>
<li>Network variance and TCP retransmissions</li>
<li>Pod restarts and rolling deployments</li>
<li>Sudden traffic spikes within degradation buffer</li>
</ul>
<p>Confidence: MEDIUM-HIGH - conservative estimate. May achieve higher with connection pooling optimizations.</p>
<p><strong>6. Auction Service (10,000-15,000 QPS per pod, 2 vCPU)</strong></p>
<p>External validation:</p>
<ul>
<li>In-memory ranking algorithms: sub-millisecond CPU time</li>
<li>No I/O, pure CPU computation</li>
</ul>
<p>Our calculation:</p>
<ul>
<li>eCPM ranking (200 candidates): 0.1ms CPU (array sort)</li>
<li>Winner selection + quality scoring: 0.05ms CPU</li>
<li>gRPC overhead: 0.3ms CPU</li>
<li>Total: 0.45ms CPU per request</li>
<li>Theoretical: 2 cores × 1000ms / 0.45ms = 4,400 QPS</li>
<li><strong>With optimizations (SIMD, cache locality): 10,000-15,000 QPS achievable</strong></li>
</ul>
<p>Confidence: MEDIUM - highly dependent on ranking algorithm complexity. Estimate assumes simple eCPM sort.</p>
<p><strong>7. Integrity Check (2,000-3,000 QPS per pod, 2 vCPU)</strong></p>
<p>External validation:</p>
<ul>
<li>Bloom filter operations: microsecond-level CPU time</li>
<li>Hash computation + validation logic adds overhead</li>
</ul>
<p>Our calculation:</p>
<ul>
<li>gRPC parsing: 0.3ms CPU</li>
<li>Hash computation (xxHash): 0.1ms CPU</li>
<li>Bloom filter check: 0.05ms CPU (bitwise operations)</li>
<li>IP blacklist check: 0.1ms CPU</li>
<li>Device fingerprint validation: 0.15ms CPU</li>
<li>Response: 0.2ms CPU</li>
<li>Total: 0.9ms CPU per request</li>
<li>Theoretical: 2 cores × 1000ms / 0.9ms = 2,200 QPS</li>
<li>With overhead: <strong>2,000-3,000 QPS realistic</strong></li>
</ul>
<p>Confidence: MEDIUM - depends on validation logic complexity beyond Bloom filter.</p>
<p><strong>8. Feature Store (10,000 QPS per pod, 2 vCPU) - Tecton Managed</strong></p>
<p>External validation:</p>
<ul>
<li>Managed service (Tecton) - vendor optimized</li>
<li>Feature serving optimized for low-latency lookups</li>
</ul>
<p>Estimate based on:</p>
<ul>
<li>Tecton documentation: sub-10ms p99 latency target</li>
<li>Similar to User Profile Service (cache-heavy reads)</li>
<li><strong>10,000 QPS reasonable for managed service</strong></li>
</ul>
<p>Confidence: LOW - vendor-specific performance. Requires Tecton documentation validation.</p>
<p><strong>Overprovisioning Strategy: Why We Don’t Run at 100% Capacity</strong></p>
<p>All QPS estimates represent <strong>provisioned capacity at 60-75% utilization</strong>, not theoretical maximum throughput. This is a deliberate architectural decision from <a href="/blog/ads-platform-part-1-foundation-architecture/#garbage-collection-analysis-beyond-the-hype">Part 1’s GC analysis</a>.</p>
<p><strong>Theoretical vs Provisioned Example (Budget Service):</strong></p>
<ul>
<li>Theoretical max: 2,000 QPS per pod (2 vCPU × 1000ms / 1.0ms CPU per request)</li>
<li>Provisioned target: 1,200-1,500 QPS per pod</li>
<li><strong>Utilization: 60-75% of theoretical max</strong></li>
</ul>
<p><strong>Why we overprovision (25-40% extra capacity):</strong></p>
<ol>
<li><strong>ZGC overhead:</strong> Even pause-less GC consumes 10-15% CPU for concurrent marking and compaction</li>
<li><strong>Rolling deployments:</strong> During updates, 20-30% of pods are unavailable (graceful shutdown + warmup)</li>
<li><strong>Network variance:</strong> TCP retransmissions, health checks, DNS lookups add 5-10% overhead</li>
<li><strong>Traffic spikes:</strong> Sudden bursts within degradation thresholds require immediate capacity</li>
<li><strong>Pod failures:</strong> Individual pod crashes should not trigger cascading degradation</li>
</ol>
<p><strong>This is not waste - it’s insurance against SLO violations.</strong></p>
<p>Running services at 95-100% CPU utilization means:</p>
<ul>
<li>Any GC pause causes request queuing and latency spikes</li>
<li>Rolling deployments trigger circuit breakers</li>
<li>Minor traffic increases violate SLOs</li>
<li>No buffer for degradation scenarios</li>
</ul>
<p><strong>Trade-off:</strong> 25-40% more infrastructure cost → avoid catastrophic failures and SLO violations</p>
<p><strong>Example calculation (Budget Service at 1M QPS, 70% traffic needs budget check):</strong></p>
<ul>
<li>Total budget checks needed: 700K QPS</li>
<li>Theoretical capacity: 700K / 2,000 QPS/pod = 350 pods minimum</li>
<li><strong>Actual provisioning: 600-800 pods (71-128% overprovisioning)</strong></li>
<li>This accounts for: ZGC (10-15%), deployments (20%), variance (10%), buffer (10-20%)</li>
</ul>
<p><strong>Critical Dependencies:</strong></p>
<p>All estimates assume:</p>
<ul>
<li>Java 21+ with virtual threads enabled for I/O-bound services</li>
<li>ZGC (low-pause garbage collector) configured properly</li>
<li>Proper connection pooling (Redis, gRPC channels)</li>
<li>Network latency within same availability zone (1-2ms)</li>
<li>Target utilization 60-75% sustained, 85-90% peak</li>
</ul>
<p><strong>Load testing validates both theoretical max AND safe utilization thresholds</strong> to determine optimal provisioning ratios.</p>
<h3 id="multi-scale-cost-projections">Multi-Scale Cost Projections</h3>
<p><strong>Infrastructure Cost Components:</strong></p>
<ol>
<li><strong>Compute (Kubernetes Nodes):</strong> Standard compute instances × node count</li>
<li><strong>Database (CockroachDB Self-Hosted):</strong> Compute instances × node count</li>
<li><strong>Cache (Valkey):</strong> Memory-optimized instances × node count</li>
<li><strong>Network Egress:</strong> Per-GB charges for RTB traffic to DSPs (50+ partners)</li>
<li><strong>Managed Services:</strong> Tecton (feature store), monitoring, storage, etc.</li>
</ol>
<table><thead><tr><th>Scale</th><th>QPS</th><th>Compute Nodes</th><th>DB Nodes</th><th>Cache Nodes</th><th>Relative Total Cost</th><th>Cost Scaling Factor</th></tr></thead><tbody>
<tr><td><strong>Small</strong></td><td>100K</td><td>15</td><td>15</td><td>6</td><td>15%</td><td>0.15× baseline</td></tr>
<tr><td><strong>Medium</strong></td><td>500K</td><td>75</td><td>40</td><td>15</td><td>55%</td><td>0.5× baseline</td></tr>
<tr><td><strong>Baseline</strong></td><td>1M</td><td>150</td><td>60</td><td>30</td><td>100%</td><td>1.0× (reference)</td></tr>
<tr><td><strong>Large</strong></td><td>5M</td><td>750</td><td>200</td><td>90</td><td>440%</td><td>4.5× baseline</td></tr>
</tbody></table>
<p><strong>Cost composition @ 1M QPS baseline:</strong> Compute 53%, Database 21%, Cache 8%, Network egress 7%, Managed services 11%.</p>
<p><strong>Key insight:</strong> Cost scales sub-linearly - 5× QPS increase = 4.5× cost (not 5×) due to fixed infrastructure amortization.</p>
<h3 id="break-even-analysis-cockroachdb-vs-dynamodb">Break-Even Analysis: CockroachDB vs DynamoDB</h3>
<p><strong>Pricing Model Comparison:</strong></p>
<ul>
<li><strong>DynamoDB:</strong> Linear per-request pricing (published AWS rates: $0.625/M writes, $0.125/M reads on-demand)</li>
<li><strong>CockroachDB:</strong> Fixed infrastructure cost (compute nodes) amortized across requests</li>
</ul>
<p><strong>1M QPS workload (8B requests/day, 70% reads, 30% writes):</strong></p>
<ul>
<li>DynamoDB: 100% baseline (reference)</li>
<li>CockroachDB: ~45% of DynamoDB cost (60 compute nodes)</li>
<li><strong>Savings: ~55% infrastructure cost</strong></li>
</ul>
<p><strong>Break-Even Analysis by Scale:</strong></p>
<table><thead><tr><th>Scale</th><th>Daily Requests</th><th>DynamoDB Cost</th><th>CRDB Cost</th><th>Cost Ratio</th><th>Winner</th></tr></thead><tbody>
<tr><td>100K QPS</td><td>864M</td><td>100%</td><td>90%</td><td>0.9×</td><td><strong>DynamoDB</strong> (10% cheaper)</td></tr>
<tr><td>500K QPS</td><td>4.3B</td><td>100%</td><td>50%</td><td>0.5×</td><td><strong>CRDB</strong> (2× cheaper)</td></tr>
<tr><td>1M QPS</td><td>8.6B</td><td>100%</td><td>45%</td><td>0.45×</td><td><strong>CRDB</strong> (2.5× cheaper)</td></tr>
<tr><td>5M QPS</td><td>43B</td><td>100%</td><td>30%</td><td>0.3×</td><td><strong>CRDB</strong> (3.5× cheaper)</td></tr>
</tbody></table>
<p><strong>Why economics flip:</strong> DynamoDB’s linear per-request pricing becomes expensive at scale, while CockroachDB’s fixed infrastructure cost amortizes across growing traffic. Crossover at ~150-200K QPS where self-hosted operational complexity becomes justified by cost savings.</p>
<h3 id="capacity-planning-decision-flow">Capacity Planning Decision Flow</h3>
<pre class="mermaid">
    
    graph TD
    START[Start: Target QPS?] --> SCALE{QPS Level?}

    SCALE -->|< 100K QPS| SMALL[Small Scale Strategy]
    SCALE -->|100K - 1M QPS| MEDIUM[Medium Scale Strategy]
    SCALE -->|1M - 5M QPS| LARGE[Large Scale Strategy]
    SCALE -->|> 5M QPS| XLARGE[Extra Large Scale Strategy]

    SMALL --> SMALL_DB{Database Choice}
    SMALL_DB --> SMALL_CRDB[CRDB Serverless<br/>Managed, auto-scale<br/>~0.15× baseline]
    SMALL_DB --> SMALL_DYNAMO[DynamoDB<br/>Pay-per-use<br/>~0.15× baseline]

    MEDIUM --> MEDIUM_INFRA[Infrastructure Sizing]
    MEDIUM_INFRA --> MEDIUM_COMPUTE[Compute: 50-150 nodes<br/>DB: 30-60 CRDB nodes<br/>Cache: 10-30 Valkey]
    MEDIUM_INFRA --> MEDIUM_COST[Cost: ~0.5× baseline<br/>Break-even: CRDB wins]

    LARGE --> LARGE_INFRA[Production Scale]
    LARGE_INFRA --> LARGE_COMPUTE[Compute: 150-750 nodes<br/>DB: 60-200 CRDB nodes<br/>Cache: 30-90 Valkey]
    LARGE_INFRA --> LARGE_MULTI[Multi-Region Required<br/>3+ regions active-active<br/>Cost: 1-4× baseline]

    XLARGE --> XLARGE_INFRA[Hyper Scale]
    XLARGE_INFRA --> XLARGE_SHARD[Geographic Sharding<br/>Regional autonomy<br/>Cost: 4×+ baseline]
    XLARGE_INFRA --> XLARGE_OPT[Custom Optimizations<br/>ASICs for ML inference<br/>CDN for static content]

    SMALL_CRDB --> VALIDATE[Validate Requirements]
    SMALL_DYNAMO --> VALIDATE
    MEDIUM_COST --> VALIDATE
    LARGE_MULTI --> VALIDATE
    XLARGE_OPT --> VALIDATE

    VALIDATE --> CHECK_LATENCY{Meet 150ms<br/>P99 SLO?}
    CHECK_LATENCY -->|No| OPTIMIZE[Optimize:<br/>- Add cache capacity<br/>- Increase pod count<br/>- Tune GC settings]
    CHECK_LATENCY -->|Yes| CHECK_COST{Budget<br/>acceptable?}

    OPTIMIZE --> CHECK_LATENCY

    CHECK_COST -->|No| REDUCE[Cost Reduction:<br/>- Managed services<br/>- Right-size instances<br/>- Reserved capacity]
    CHECK_COST -->|Yes| DEPLOY[Deploy & Monitor]

    REDUCE --> CHECK_COST

    DEPLOY --> MONITOR[Continuous Monitoring]
    MONITOR --> ADJUST{Need to scale?}
    ADJUST -->|Yes| SCALE
    ADJUST -->|No| MONITOR

    style START fill:#e1f5ff
    style DEPLOY fill:#d4edda
    style VALIDATE fill:#fff3cd
    style OPTIMIZE fill:#f8d7da
    style REDUCE fill:#f8d7da
</pre>
<p><strong>Critical Sizing Insights:</strong></p>
<ol>
<li><strong>ML Inference dominates:</strong> 6,000-8,000 vCPUs (48-60% of total) - explains why CPU-based GBDT was chosen over GPU (cost, operational simplicity)</li>
<li><strong>Cache reduces DB by 5-8×:</strong> 78-88% hit rate turns 1M QPS into 120-220K effective database load</li>
<li><strong>Cost crossover at 200K QPS:</strong> DynamoDB wins below 200K, self-hosted CRDB provides 2×+ savings above</li>
<li><strong>Cost scales sub-linearly:</strong> 5× QPS increase = 4.5× cost increase (fixed infrastructure amortizes)</li>
</ol>
<h3 id="hardware-evolution-strategy-cpu-first-architecture">Hardware Evolution Strategy: CPU-First Architecture</h3>
<p>This section clarifies our long-term ML infrastructure evolution path and explains the CPU-only architecture decision.</p>
<p><strong>Design Philosophy: Start Simple, Evolve Deliberately</strong></p>
<p>We deliberately chose CPU-only infrastructure for ML inference despite GPU being the “standard” choice in ML serving. This decision trades some model complexity ceiling for significant operational and cost benefits.</p>
<p><strong>Phase 1: Day 1 - CPU GBDT (Current)</strong></p>
<p><strong>Infrastructure:</strong></p>
<ul>
<li>1,500-2,000 CPU pods (4 vCPU, 16GB RAM each)</li>
<li>Standard c6i.4xlarge instances (no GPU drivers, no CUDA)</li>
<li>LightGBM/XGBoost models served via standard HTTP/gRPC</li>
</ul>
<p><strong>Performance:</strong></p>
<ul>
<li>10-20ms GBDT inference latency</li>
<li>500-700 QPS per pod</li>
<li>Total capacity: 1M-1.4M QPS (1M baseline + 40% headroom)</li>
</ul>
<p><strong>Model characteristics:</strong></p>
<ul>
<li>100-150 trees, depth 6-8</li>
<li>200-500 features</li>
<li>Model size: 50-150MB</li>
<li>AUC target: 0.78-0.82</li>
</ul>
<p><strong>Advantages:</strong></p>
<ul>
<li>Simple deployment (no GPU orchestration complexity)</li>
<li>Fast iteration (standard Kubernetes HPA, no specialized hardware)</li>
<li>Low cost (30-40% cheaper than GPU for GBDT workloads)</li>
<li>Team velocity (engineers familiar with CPU deployment)</li>
</ul>
<p><strong>Limitations accepted:</strong></p>
<ul>
<li>Cannot run large neural networks (yet)</li>
<li>10-20ms latency floor (vs 8-15ms on GPU)</li>
<li>Lower throughput per pod (500-700 vs 1,000-1,500 QPS)</li>
</ul>
<p><strong>Phase 2: 6-12 Months - Two-Stage Ranking with Distilled DNN (Planned)</strong></p>
<p><strong>Infrastructure addition:</strong></p>
<ul>
<li>Same CPU pods (no hardware changes!)</li>
<li>Add ONNX Runtime with INT8 quantization support</li>
<li>Deploy distilled DNN models alongside GBDT</li>
</ul>
<p><strong>Architecture:</strong></p>
<ol>
<li>
<p><strong>Stage 1 - GBDT Candidate Generation (5-10ms):</strong></p>
<ul>
<li>Existing CPU GBDT model</li>
<li>Reduce 10M ads → 200 top candidates</li>
<li>Unchanged from Phase 1</li>
</ul>
</li>
<li>
<p><strong>Stage 2 - DNN Reranking (10-15ms):</strong></p>
<ul>
<li>Distilled neural network (60-100M parameters)</li>
<li>INT8 quantized, ONNX optimized</li>
<li>Scores only top-200 candidates (not all 10M)</li>
<li>Runs on same CPU infrastructure</li>
</ul>
</li>
</ol>
<p><strong>Performance:</strong></p>
<ul>
<li>Combined latency: 15-25ms (within 40ms budget)</li>
<li>Expected AUC improvement: +1-2% (0.80-0.84 range)</li>
<li>Revenue impact: +5-10% from better targeting</li>
</ul>
<p><strong>Requirements to unlock this phase:</strong></p>
<ul>
<li>Build distillation pipeline (teacher-student training)</li>
<li>INT8 post-training quantization</li>
<li>ONNX Runtime integration</li>
<li>Load testing to validate 10-15ms DNN latency on CPU</li>
</ul>
<p><strong>Model characteristics (DNN reranker):</strong></p>
<ul>
<li>Architecture: DistilBERT-class or small transformer (60-100M params)</li>
<li>Quantization: INT8 (4× size reduction, 25-50% latency improvement)</li>
<li>Input: Top-200 candidates + user features</li>
<li>Model size: 100-200MB (post-quantization)</li>
</ul>
<p><strong>Proven CPU DNN latency (external validation):</strong></p>
<ul>
<li><a href="https://getstream.io/blog/optimize-transformer-inference/">DistilBERT p50 &lt;10ms on CPU</a> with ONNX quantization</li>
<li><a href="https://medium.com/nixiesearch/how-to-compute-llm-embeddings-3x-faster-with-model-quantization-25523d9b4ce5">E5-base-v2 15ms on CPU</a> (3.5× improvement via quantization)</li>
<li><a href="https://mlnews.dev/int8-quantization-a-proficient-llms-on-cpu-inference/">INT8 quantization achieves 20-80ms</a> for larger models on Intel Xeon</li>
</ul>
<p><strong>Phase 3: 18-24 Months - Decision Point (GPU Migration or Continue CPU)</strong></p>
<p>At this phase, we evaluate whether CPU architecture has reached its limits:</p>
<p><strong>Option 3A: Continue CPU evolution (if model quality sufficient)</strong></p>
<p>Stick with CPU if:</p>
<ul>
<li>AUC 0.82-0.84 meets business goals</li>
<li>Cost savings (30-40% vs GPU) outweigh marginal quality gains</li>
<li>Operational simplicity valued over cutting-edge models</li>
</ul>
<p><strong>Next steps:</strong></p>
<ul>
<li>Further model compression (pruning, distillation)</li>
<li>Experiment with smaller model architectures (MobileNet-style)</li>
<li>Optimize inference pipeline (batching, multi-threading)</li>
</ul>
<p><strong>Option 3B: Add GPU pool (if hitting CPU ceiling)</strong></p>
<p>Migrate to hybrid CPU+GPU if:</p>
<ul>
<li>Need AUC &gt;0.85 (requires larger transformers, &gt;100M params)</li>
<li>Research team wants to experiment with large pre-trained models (BERT-Large, etc.)</li>
<li>Business justifies 30-40% infrastructure cost increase for quality gains</li>
</ul>
<p><strong>Migration path:</strong></p>
<ul>
<li>Deploy small GPU pool (50-100 pods with T4/A10g GPUs)</li>
<li>Run A/B test (GPU vs CPU DNN reranker)</li>
<li>Gradually shift traffic if GPU shows ROI</li>
<li><strong>Estimated migration time:</strong> 3-6 months (GPU orchestration, model adaptation, load testing)</li>
<li><strong>Cost impact:</strong> +30-40% infrastructure cost (+15-20% total platform cost)</li>
</ul>
<p><strong>Trade-Off Analysis: What We Explicitly Accept</strong></p>
<p>By choosing CPU-first architecture, we are <strong>deliberately accepting</strong>:</p>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>Cost efficiency:</strong> 30-40% infrastructure cost reduction vs GPU for GBDT workloads at 1M QPS</li>
<li><strong>Faster time-to-market:</strong> CPU deployment expertise widely available</li>
<li><strong>Lower operational risk:</strong> Fewer components to fail (no GPU drivers, CUDA versions)</li>
<li><strong>Easier troubleshooting:</strong> Standard CPU profiling tools vs specialized GPU tools</li>
<li><strong>Portability:</strong> Runs on any cloud provider without GPU availability constraints</li>
</ul>
<p><strong>Trade-offs:</strong></p>
<ul>
<li>
<p><strong>Model size ceiling:</strong> Limited to ~100M parameter models (DistilBERT-class) in Phase 2</p>
<ul>
<li>Cannot easily run BERT-Large (340M), GPT-style models (billions)</li>
<li><em>Impact:</em> Potential 1-2% AUC gap vs unlimited model complexity</li>
</ul>
</li>
<li>
<p><strong>Research flexibility:</strong> 2-4 month lag to productionize cutting-edge models</p>
<ul>
<li>Must wait for distilled versions or conduct distillation internally</li>
<li>Cannot quickly experiment with latest research from arXiv</li>
</ul>
</li>
<li>
<p><strong>Future migration cost:</strong> If we hit CPU ceiling, GPU migration takes 3-6 months</p>
<ul>
<li>Need to build GPU orchestration from scratch</li>
<li>Re-architect model serving pipeline</li>
<li><em>Mitigation:</em> Decision is reversible, just expensive to reverse</li>
</ul>
</li>
</ul>
<p><strong>Why This Makes Sense for Our Use Case:</strong></p>
<p>Our constraints favor CPU-first:</p>
<ol>
<li><strong>Scale:</strong> 1M QPS scale where 30-40% cost reduction justifies operational effort</li>
<li><strong>Business:</strong> Ad platform ROI from 0.80→0.82 AUC is substantial (5-10% revenue)</li>
<li><strong>Timeline:</strong> 6-12 month deployment cadence allows careful evolution</li>
<li><strong>Team:</strong> Engineering-heavy team (vs research-heavy) values operational simplicity</li>
</ol>
<p><strong>When CPU-First Might NOT Make Sense:</strong></p>
<p>Choose GPU from Day 1 if:</p>
<ul>
<li><strong>Low scale</strong> (&lt;100K QPS): Cost difference negligible, GPU premium worth flexibility</li>
<li><strong>Research-driven:</strong> Team wants to experiment with large models immediately</li>
<li><strong>High-margin business:</strong> Can afford 30-40% premium for marginal quality gains</li>
<li><strong>Existing GPU expertise:</strong> Team already has GPU ML infrastructure experience</li>
</ul>
<p><strong>Summary: Deliberate Architecture Constraints</strong></p>
<p>Our CPU-first architecture is not a compromise—it’s a deliberate choice optimizing for cost, operational simplicity, and team velocity at 1M QPS scale. We accept model complexity constraints (100M param ceiling in Phase 2) in exchange for 30-40% infrastructure cost savings and faster iteration.</p>
<p>The evolution path (Phase 1 GBDT → Phase 2 two-stage CPU DNN → Phase 3 decision point) allows us to extract 80-90% of ML value without GPU complexity. If we hit the CPU ceiling in 18-24 months, we have a clear migration path to GPU—but we’ll have achieved significant cost savings and learned what model quality truly requires.</p>
<p><strong>See <a href="/blog/ads-platform-part-2-ml-infrastructure/#cpu-based-gbdt-inference-architecture-decision">Part 2 ML Architecture</a> for detailed technical justification and external research validation.</strong></p>
<hr />
<h2 id="distributed-cache-valkey-redis-fork">Distributed Cache: Valkey (Redis Fork)</h2>
<h3 id="decision-valkey-over-redis-7-x-memcached">Decision: Valkey over Redis 7.x / Memcached</h3>
<p>From <a href="/blog/ads-platform-part-3-data-revenue/#budget-pacing-distributed-spend-control">Part 3</a>: Need atomic operations (DECRBY for budget pacing), sub-ms latency, 1M+ QPS capacity.</p>
<p><strong>Why Valkey over Redis:</strong></p>
<ol>
<li><strong>Licensing</strong>: BSD-3 (permissive) vs Redis SSPL (restrictive)</li>
<li><strong>Performance</strong>: Valkey 8.1 achieves 999.8K RPS with 0.8ms P99 latency (research-validated)</li>
<li><strong>Community</strong>: Linux Foundation backing, active development</li>
<li><strong>Compatibility</strong>: Drop-in replacement for Redis 7.2</li>
</ol>
<p><strong>Why Valkey over Memcached:</strong></p>
<ul>
<li><strong>Atomic operations</strong>: DECRBY, INCRBY for budget pacing (Memcached lacks atomics)</li>
<li><strong>Data structures</strong>: Lists, sets, sorted sets for complex caching</li>
<li><strong>Persistence</strong>: AOF/RDB for durability (Memcached is volatile-only)</li>
</ul>
<h3 id="cluster-architecture">Cluster Architecture</h3>
<p><strong>Configuration:</strong></p>
<ul>
<li><strong>20 nodes</strong> across 3 AWS regions (primary: 12 nodes, secondary: 4+4 nodes)</li>
<li><strong>Node specs</strong>: r5.2xlarge (8 vCPU, 64GB RAM per node)</li>
<li><strong>Sharding</strong>: 16,384 hash slots, evenly distributed across 20 nodes (~819 slots/node)</li>
<li><strong>Replication</strong>: Each master has 1 replica (40 total nodes including replicas)</li>
</ul>
<p><strong>Why 20 nodes:</strong>
From benchmarks: Valkey 8.1 achieves 1M RPS on a 16 vCPU instance. Our workload: 1M+ QPS across L2 cache + budget counters + rate limiting.</p>
<ul>
<li>L2 cache hit rate: 25% (from <a href="/blog/ads-platform-part-3-data-revenue/#multi-tier-cache-hierarchy">Part 3</a>) → 250K QPS</li>
<li>Budget operations: ~50K QPS (atomic DECRBY on every ad serve)</li>
<li>Rate limiting: 1M QPS (token bucket checks)</li>
<li><strong>Total</strong>: ~1.3M operations/sec → 20 nodes provides 2× headroom</li>
</ul>
<p><strong>Cluster Configuration:</strong></p>
<p><strong>Memory Management:</strong> Valkey configured with 48GB heap allocation (out of 64GB total node memory), leaving 16GB for operating system page cache and kernel buffers. This ratio (75% application / 25% OS) optimizes for large working sets while preventing OOM conditions. Eviction policy uses allkeys-lru (least recently used) to automatically evict cold keys when memory pressure occurs, ensuring the cache remains operational under high load without manual intervention.</p>
<p><strong>Durability Strategy:</strong> Append-Only File (AOF) persistence enabled with everysec fsync policy. This provides a middle ground between performance and durability:</p>
<ul>
<li>Writes acknowledged immediately (sub-ms latency)</li>
<li>Fsync batches buffered writes to disk every 1 second</li>
<li>Maximum data loss window: 1 second of writes in catastrophic failure</li>
<li>Trade-off: Stronger than no persistence, faster than per-write fsync (which would add 5-10ms per operation)</li>
</ul>
<p><strong>Cluster Mode Configuration:</strong></p>
<ul>
<li><strong>Distributed hash slots (16,384 slots):</strong> Enable horizontal sharding across 20 nodes without manual key distribution</li>
<li><strong>Node timeout (5 seconds):</strong> Cluster detects failed nodes within 5 seconds and triggers automatic failover to replica</li>
<li><strong>Authentication required:</strong> Strong password authentication prevents unauthorized access, critical for protecting budget counters from manipulation</li>
</ul>
<p><strong>Network Binding:</strong> Configured to listen on all interfaces (0.0.0.0) with protected mode enabled, allowing inter-cluster communication while requiring authentication for external connections. Essential for Kubernetes pod-to-pod communication across availability zones.</p>
<p><strong>Atomic Budget Operations (Lua Script):</strong></p>
<p>From <a href="/blog/ads-platform-part-3-data-revenue/#budget-pacing-distributed-spend-control">Part 3</a>: Budget pacing uses atomic DECRBY to prevent overspend.</p>
<p><strong>Atomic Check-and-Deduct Pattern:</strong> Budget validation requires a check-then-deduct operation that must execute atomically to prevent overspend. The pattern reads the current budget counter from Valkey, validates sufficient funds exist for the requested ad impression cost, and decrements the counter only if funds are available - all as a single atomic transaction.</p>
<p><strong>Why Lua Scripting:</strong></p>
<ul>
<li><strong>Atomicity guarantee:</strong> Entire script executes as single Redis transaction without interleaving from other clients, eliminating race conditions where two Ad Server instances simultaneously check and deduct from the same campaign budget</li>
<li><strong>Server-side execution:</strong> Multi-step conditional logic (check balance → deduct if sufficient) executes within Valkey process, avoiding 3 round-trips (GET, check in application, DECRBY) that would add 2-3ms latency and introduce race windows</li>
<li><strong>Consistency under load:</strong> At 1M+ QPS with 300 Ad Server instances, network-based locking (SETNX) would create contention hotspots. Lua scripts provide lock-free atomicity with &lt;0.1ms execution time</li>
</ul>
<p><strong>Script Execution Model:</strong> Pre-loaded into Valkey using SCRIPT LOAD, invoked by SHA-1 hash to avoid network overhead of sending script text on every request. Application code passes campaign key and deduction amount as parameters, receives binary success/failure response. This pattern achieves the ≤1% overspend guarantee from <a href="/blog/ads-platform-part-3-data-revenue/#budget-pacing-distributed-spend-control">Part 3</a> by ensuring no concurrent modifications can occur between balance check and deduction.</p>
<p><strong>Sharding Strategy:</strong></p>
<ul>
<li>Hash slot calculation: <code>CRC16(key) mod 16384</code></li>
<li>Keys for same campaign co-located: <code>campaign:{id}:budget</code>, <code>campaign:{id}:metadata</code> use same hash tag <code>{id}</code></li>
<li>Ensures atomic operations on related keys hit same node</li>
</ul>
<hr />
<h2 id="immutable-audit-log-technology-stack">Immutable Audit Log: Technology Stack</h2>
<h3 id="compliance-requirement-and-technology-decision">Compliance Requirement and Technology Decision</h3>
<p>From <a href="/blog/ads-platform-part-3-data-revenue/#immutable-financial-audit-log-compliance-architecture">Part 3’s audit log architecture</a>: CockroachDB operational ledger is mutable (allows UPDATE/DELETE for operational efficiency), violating SOX and tax compliance requirements. Regulators require immutable, cryptographically verifiable financial records with 7-year retention for audit trail integrity.</p>
<p><strong>Solution: Kafka + ClickHouse Event Sourcing Pattern</strong></p>
<p>Platform selected Kafka + ClickHouse over AWS QLDB based on four factors. First, proven industry pattern validated at scale (Netflix KV DAL, Uber metadata platform operate similar architectures at 1M+ QPS). Second, query performance advantage: ClickHouse columnar OLAP delivers sub-500ms audit queries compared to QLDB PartiQL requiring 2-5 seconds for equivalent aggregations over billions of rows. Third, operational familiarity: platform already operates both technologies (Kafka for event streaming, ClickHouse for analytics dashboards), reusing existing expertise reduces learning curve. Fourth, AWS deprecation signal: AWS documentation (2024) recommends migrating QLDB workloads to Aurora PostgreSQL, indicating reduced investment in ledger-specific database.</p>
<p>QLDB rejected due to vendor lock-in (AWS-only, no multi-cloud option), query language barrier (PartiQL requires finance team retraining vs standard SQL), and OLAP performance lag for analytical compliance workloads (tax reporting aggregations, multi-year dispute investigations).</p>
<h3 id="implementation-and-performance-characteristics">Implementation and Performance Characteristics</h3>
<p>ClickHouse consumes financial events from Kafka via Kafka Engine table, transforms via Materialized View into columnar MergeTree storage. Configuration optimized for audit access patterns: monthly partitioning by timestamp enables efficient pruning for annual tax queries, ordering key <code>(campaignId, timestamp)</code> co-locates campaign history for fast sequential scans, ZSTD compression achieves 65% reduction (200GB/day raw → 70GB/day compressed). System delivers 100K events/sec ingestion throughput with &lt;5 second end-to-end lag (event published → queryable), sub-500ms query latency for most audit scenarios (campaign spend history, dispute investigation). Full configuration details in <a href="/blog/ads-platform-part-3-data-revenue/#clickhouse-storage-design">Part 3</a>.</p>
<h3 id="resource-trade-offs-and-operational-impact">Resource Trade-Offs and Operational Impact</h3>
<p><strong>Additional Infrastructure Required:</strong></p>
<p>Compliance architecture adds dedicated resources beyond operational systems. ClickHouse cluster: 8 nodes with 3× replication factor across availability zones, consuming approximately 24 compute instances total. Storage footprint: 180TB for 7-year compliance retention (70GB/day × 365 days × 7 years), representing 15-20% additional storage compared to operational database infrastructure baseline (CockroachDB + Valkey). Kafka brokers: 12 nodes reused from existing event streaming infrastructure (impression/click events already flow through same cluster), marginal incremental capacity required.</p>
<p><strong>Ingestion and Query Resource Usage:</strong></p>
<p>ClickHouse ingestion consumes CPU cycles for JSON parsing, columnar transformation, compression, and replication. At 100K events/sec, ingestion workload averages 30-40% CPU utilization per node during peak hours, leaving headroom for query workload. Query resource consumption varies by complexity: simple aggregations (monthly campaign spend) consume &lt;1 CPU-second, complex multi-year tax reports consume 5-10 CPU-seconds. Daily reconciliation job (compares operational vs audit ledgers) runs during off-peak hours (2AM UTC), consuming ~5 minutes CPU time across cluster.</p>
<p><strong>Operational Overhead:</strong></p>
<p>Compliance infrastructure introduces ongoing operational burden. Monitoring: Kafka consumer lag alerts (detect ingestion delays &gt;1 minute), ClickHouse query latency dashboards (ensure audit queries remain sub-second), storage growth tracking (project retention capacity needs). Retention policy enforcement: monthly automated job drops partitions &gt;7 years old, archives to S3 cold storage, validates hash chain integrity. Daily reconciliation: automated Airflow job compares ledgers, alerts on discrepancies &gt;0.01 per campaign, typically finds 0-3 mismatches out of 10,000+ campaigns requiring investigation. Incident response: estimated 2-4 hours/month for discrepancy investigation, schema evolution coordination between operational and audit systems.</p>
<p><strong>Benefit Justifies Resource Cost:</strong></p>
<p>Compliance infrastructure prevents regulatory violations (SOX audit failures, IRS tax disputes), enables advertiser billing dispute resolution with cryptographically verifiable records (hash-chained events prove tampering), and satisfies payment processor requirements (Visa/Mastercard mandate immutable transaction logs). Resource investment (24 ClickHouse nodes, 180TB storage, operational monitoring) eliminates legal/financial risk exposure from non-compliant mutable ledgers.</p>
<hr />
<h2 id="fraud-detection-multi-tier-pattern-based-system">Fraud Detection: Multi-Tier Pattern-Based System</h2>
<h3 id="architecture-overview">Architecture Overview</h3>
<p>From <a href="/blog/ads-platform-part-4-production/#fraud-detection-pattern-based-abuse-detection">Part 4’s fraud detection analysis</a>: 10-30% of ad traffic is fraudulent (bots, click farms, invalid traffic). The multi-tier detection architecture catches fraud progressively with increasing sophistication:</p>
<p><strong>Three-Tier Detection Strategy:</strong></p>
<ul>
<li><strong>L1 (Pre-RTB):</strong> Fast pattern matching blocks 20-30% of blatant bot traffic BEFORE expensive RTB fan-out</li>
<li><strong>L2 (Post-Auction):</strong> Behavioral analysis catches 50-60% of sophisticated bots using device fingerprinting</li>
<li><strong>L3 (Batch ML):</strong> Anomaly detection identifies 70-80% of advanced fraud patterns via 24-hour batch analysis</li>
</ul>
<h3 id="l1-integrity-check-service-go-real-time-filtering">L1: Integrity Check Service (Go) - Real-Time Filtering</h3>
<p><strong>Technology Choice: Go over Java/Python</strong></p>
<ul>
<li><strong>Sub-millisecond latency:</strong> Go’s compiled nature and lightweight runtime achieves &lt;0.5ms P99 for Bloom filter lookups</li>
<li><strong>Minimal memory footprint:</strong> 50-100MB per instance vs 1-2GB for JVM-based services, enabling higher pod density</li>
<li><strong>Stateless design:</strong> Each instance loads 18MB Bloom filter into memory at startup, no external dependencies during request path</li>
</ul>
<p><strong>Implementation Architecture:</strong></p>
<p><strong>Bloom Filter for Known Malicious IPs:</strong></p>
<ul>
<li><strong>Capacity:</strong> 10 million IP addresses with 0.1% false positive rate</li>
<li><strong>Memory:</strong> 18MB in-process data structure (MurmurHash3 with 7 hash functions)</li>
<li><strong>Update frequency:</strong> Refreshed every 5 minutes from shared Redis key populated by L3 batch analysis</li>
<li><strong>Deployment:</strong> Runs as sidecar container alongside Ad Server pods (localhost communication eliminates network hop)</li>
</ul>
<p><strong>IP Reputation Cache (Redis-backed):</strong></p>
<ul>
<li>Stores last-seen timestamps for IP addresses exhibiting suspicious patterns</li>
<li>TTL: 24 hours (IPs age out automatically without manual cleanup)</li>
<li>Lookup latency: &lt;1ms via L2 Valkey cache</li>
<li>Pattern: Rate-limited parallel lookup (don’t block request if Redis slow)</li>
</ul>
<p><strong>Device Fingerprinting (Basic):</strong></p>
<ul>
<li>User-Agent parsing: Detect headless browsers (Puppeteer, Selenium indicators)</li>
<li>Header validation: Missing or malformed required headers (Accept-Language, Referer)</li>
<li>Execution time: &lt;0.2ms via pre-compiled regex patterns</li>
</ul>
<p><strong>Latency Budget:</strong> 5ms allocated in <a href="/blog/ads-platform-part-1-foundation-architecture/#latency-budget-decomposition">Part 1</a>, executes in 0.5-2ms (measured p95), leaving 3-4.5ms buffer.</p>
<p><strong>Key Trade-Off:</strong> Accept 0.1% false positive rate (blocking ~1,000 legitimate requests/second at 1M QPS) to prevent 200,000-300,000 fraudulent requests from consuming RTB bandwidth. The ROI is compelling: 5ms latency investment blocks 20-30% traffic, saving massive egress costs to 50+ DSPs.</p>
<h3 id="l2-behavioral-analysis-service-post-auction-pattern-detection">L2: Behavioral Analysis Service - Post-Auction Pattern Detection</h3>
<p><strong>Architecture:</strong> Asynchronous processing pipeline (NOT in request critical path)</p>
<p><strong>Trigger:</strong> Ad Server publishes click/impression events to Kafka after serving response to user. Fraud Analysis Service consumes events in real-time with &lt;1s lag.</p>
<p><strong>Detection Patterns:</strong></p>
<p><strong>Click-Through Rate Anomalies:</strong></p>
<ul>
<li>Calculate per-campaign CTR over 1-hour sliding windows</li>
<li>Flag campaigns with CTR &gt;5× platform median (potential click fraud)</li>
<li>Cross-reference with device fingerprint diversity (legitimate traffic shows device variety)</li>
</ul>
<p><strong>Velocity Checks:</strong></p>
<ul>
<li>Track impressions-per-IP over 5-minute windows</li>
<li>Threshold: &gt;100 impressions/5min from single IP triggers investigation</li>
<li>Combines with user-agent analysis: Same UA + High velocity = Strong fraud signal</li>
</ul>
<p><strong>Geographic Impossibility:</strong></p>
<ul>
<li>Detect user appearing in multiple distant locations within short timeframe</li>
<li>Example: Ad impression in New York at 10:00 AM, London at 10:05 AM = Physically impossible</li>
<li>Implementation: Redis geohash proximity check (&lt;3ms)</li>
</ul>
<p><strong>Processing Architecture:</strong></p>
<ul>
<li><strong>Flink streaming job:</strong> Consumes Kafka events, performs stateful aggregations (sliding windows)</li>
<li><strong>State backend:</strong> RocksDB for incremental checkpointing (recovery within 30s of failure)</li>
<li><strong>Output:</strong> Suspected fraud events written to separate Kafka topic for L3 analysis + immediate blocking (IP added to Redis reputation cache)</li>
</ul>
<p><strong>Latency:</strong> Fully asynchronous, 5-15ms average processing time doesn’t impact request latency</p>
<h3 id="l3-ml-based-anomaly-detection-batch-gradient-boosted-decision-trees">L3: ML-Based Anomaly Detection - Batch Gradient Boosted Decision Trees</h3>
<p><strong>Model Architecture:</strong> GBDT (same as CTR prediction, different training data)</p>
<ul>
<li><strong>Trees:</strong> ~200 trees, depth 6 - 8</li>
<li><strong>Features:</strong> ~40 features across behavioral, temporal, and device dimensions</li>
<li><strong>Training frequency:</strong> Daily batch retraining on previous 7 days of labeled data</li>
<li><strong>Deployment:</strong> Model updated via blue-green deployment (shadow scoring validates new model before promotion)</li>
</ul>
<p><strong>Feature Categories:</strong></p>
<p><strong>Behavioral Features (~20):</strong></p>
<ul>
<li>Impressions/click ratio per user/device/IP</li>
<li>Session duration distribution</li>
<li>Navigation patterns (direct vs organic)</li>
<li>Ad interaction timing (clicking too fast suggests automation)</li>
</ul>
<p><strong>Temporal Features (~10):</strong></p>
<ul>
<li>Hour-of-day distribution (bots often show flat 24-hour activity)</li>
<li>Day-of-week patterns</li>
<li>Burst detection (sudden spike in activity)</li>
</ul>
<p><strong>Device Features (~10):</strong></p>
<ul>
<li>Screen resolution distribution</li>
<li>Browser/OS combinations</li>
<li>JavaScript execution capabilities</li>
<li>Touch vs mouse interaction patterns (mobile vs desktop)</li>
</ul>
<p><strong>Scoring Pipeline:</strong></p>
<ul>
<li><strong>Batch processing:</strong> Spark job scores all previous day’s traffic overnight</li>
<li><strong>Output:</strong> Fraud score 0.0-1.0 for each impression/click</li>
<li><strong>Threshold:</strong> Score &gt;0.8 triggers retroactive campaign billing adjustment + IP blacklist update</li>
</ul>
<p><strong>Integration with L1:</strong> High-confidence fraud IPs (score &gt;0.9) added to Bloom filter for future real-time blocking.</p>
<h3 id="multi-tier-integration-pattern">Multi-Tier Integration Pattern</h3>
<p><strong>Progressive Filtering Flow:</strong></p>
<ol>
<li><strong>L1 blocks 20-30%</strong> of obvious bots at 0.5-2ms latency (prevents RTB calls, massive bandwidth savings)</li>
<li>Remaining 70-80% traffic proceeds through normal auction</li>
<li><strong>L2 analyzes 100%</strong> of served impressions asynchronously within 1s, catches additional 20-30% (cumulative 40-50%)</li>
<li><strong>L3 reviews 100%</strong> of previous day’s traffic in batch, identifies remaining 20-30% (cumulative 70-80% total fraud detection)</li>
</ol>
<p><strong>Feedback Loop:</strong> L3 discoveries feed back into L1 Bloom filter and L2 Redis reputation cache, continuously improving real-time blocking accuracy.</p>
<p><strong>Operational Metrics:</strong></p>
<ul>
<li><strong>False positive rate:</strong> &lt;2% (measured via advertiser complaints per 1000 blocks)</li>
<li><strong>Detection latency:</strong> L1 immediate, L2 within 5 seconds, L3 within 24 hours</li>
<li><strong>Cost savings:</strong> Blocking 20-30% traffic before RTB prevents ~64PB/month of egress to DSPs</li>
<li><strong>Revenue protection:</strong> Prevents $X fraudulent spend monthly (advertiser trust preservation)</li>
</ul>
<p>This multi-tier approach balances latency (L1 ultra-fast), accuracy (L3 high-precision ML), and operational complexity (L2 provides middle ground for evolving threats).</p>
<hr />
<h2 id="feature-store-tecton-integration-architecture">Feature Store: Tecton Integration Architecture</h2>
<h3 id="technology-decision-tecton-over-self-hosted-feast">Technology Decision: Tecton over Self-Hosted Feast</h3>
<p>From <a href="/blog/ads-platform-part-2-rtb-ml-pipeline/#feature-engineering-architecture">Part 2’s ML Inference Pipeline</a>: Feature store must serve real-time, batch, and streaming features with &lt;10ms P99 latency.</p>
<p><strong>Why Tecton (Managed) over Feast (Self-Hosted):</strong></p>
<ul>
<li><strong>Cost efficiency:</strong> 5-8× cheaper than building custom solution when accounting for engineering time (estimated 2-3 FTEs for Feast self-hosting vs $X/month for Tecton managed)</li>
<li><strong>Operational complexity:</strong> Managed service eliminates need for dedicated team to maintain Spark clusters, Kafka consumers, Redis deployment, monitoring infrastructure</li>
<li><strong>Feature freshness guarantees:</strong> Built-in SLA monitoring for feature staleness, automatic backfilling for late-arriving data</li>
<li><strong>Native multi-region support:</strong> Cross-region replication handled by Tecton, critical for <a href="/blog/ads-platform-part-4-production/#multi-region-deployment-and-failover">Part 4’s active-active deployment</a></li>
</ul>
<h3 id="three-tier-feature-freshness-model">Three-Tier Feature Freshness Model</h3>
<p>From <a href="/blog/ads-platform-part-2-rtb-ml-pipeline/#feature-engineering-architecture">Part 2</a>: Features categorized by freshness requirements.</p>
<p><strong>Tier 1: Batch Features (Daily Refresh):</strong></p>
<ul>
<li><strong>Examples:</strong> User demographics, device type, historical campaign performance</li>
<li><strong>Source:</strong> S3 / Snowflake (data warehouse exports)</li>
<li><strong>Processing:</strong> Spark batch jobs running on schedule (overnight)</li>
<li><strong>Storage:</strong> Tecton Offline Store (Parquet files in S3, indexed for fast retrieval)</li>
<li><strong>Latency:</strong> Not real-time, but pre-computed and cached in Tecton Online Store at serving time</li>
</ul>
<p><strong>Tier 2: Streaming Features (1-Hour Windows):</strong></p>
<ul>
<li><strong>Examples:</strong> Last 7-day CTR per user-campaign pair, hourly impression count per advertiser</li>
<li><strong>Source:</strong> Kafka topics (impression_events, click_events)</li>
<li><strong>Processing:</strong> Flink streaming jobs perform windowed aggregations (tumbling/sliding windows)</li>
<li><strong>Update frequency:</strong> Materializes every 1 hour (trade-off: freshness vs compute cost)</li>
<li><strong>Storage:</strong> Written to Kafka → Consumed by Tecton Rift → Materialized to Tecton Online Store (Redis)</li>
</ul>
<p><strong>Tier 3: Real-Time Features (Sub-Second):</strong></p>
<ul>
<li><strong>Examples:</strong> Session duration (time since first impression), last-seen timestamp, request context (time-of-day, device orientation)</li>
<li><strong>Source:</strong> Generated during request or from immediate cache lookup</li>
<li><strong>Processing:</strong> Computed inline during Ad Server request handling or via Tecton Rift real-time transformations</li>
<li><strong>Storage:</strong> Ephemeral (session-scoped) or cached in Redis with short TTL (60s)</li>
</ul>
<h3 id="flink-kafka-tecton-integration-pipeline">Flink → Kafka → Tecton Integration Pipeline</h3>
<p><strong>Architecture Flow:</strong></p>
<p><strong>1. Event Ingestion (Flink Source):</strong></p>
<ul>
<li>Flink consumes raw impression/click events from primary Kafka topics (impression_raw, click_raw)</li>
<li>Parallelism: 32 task slots across 8 worker nodes (sufficient for 1M+ events/second)</li>
<li>Checkpointing: RocksDB state backend with 60-second checkpoint intervals (balance between recovery time and performance)</li>
</ul>
<p><strong>2. Stream Processing (Flink Transformations):</strong></p>
<ul>
<li><strong>Deduplication:</strong> Stateful deduplication using Flink keyed state (window size: 5 minutes) removes duplicate impression events from retries</li>
<li><strong>Enrichment:</strong> Left-join with user profile dimension table (cached in Flink state) adds demographics without external lookup latency</li>
<li><strong>Aggregation:</strong> Tumbling windows (1-hour) compute CTR, impression counts, spend totals per user-campaign pair</li>
<li><strong>Output:</strong> Enriched feature events written to dedicated Kafka topics (features_hourly_agg, features_user_context)</li>
</ul>
<p><strong>3. Feature Materialization (Tecton Rift Streaming Engine):</strong></p>
<ul>
<li><strong>Rift consumes</strong> feature events from Kafka topics</li>
<li><strong>Transformation:</strong> Applies Tecton-defined feature transformations (e.g., ratio calculations, Z-score normalization)</li>
<li><strong>Materialization:</strong> Writes computed features to Tecton Online Store (Redis cluster managed by Tecton)</li>
<li><strong>SLA:</strong> 99.9% of features materialized within 2 minutes of event occurrence</li>
</ul>
<p><strong>4. Feature Serving (Tecton Online Store):</strong></p>
<ul>
<li><strong>Storage:</strong> Redis cluster (separate from application Valkey cluster to isolate feature serving from budget operations)</li>
<li><strong>Read pattern:</strong> Ad Server calls Tecton SDK during ML inference phase, retrieves feature vector for user-campaign pair</li>
<li><strong>Latency:</strong> &lt;10ms P99 (measured from <a href="/blog/ads-platform-part-1-foundation-architecture/#latency-budget-decomposition">Part 1’s latency budget</a>)</li>
<li><strong>Cache hit rate:</strong> &gt;95% due to pre-materialized features (miss = fallback to stale features or default values)</li>
</ul>
<h3 id="feature-versioning-and-schema-evolution">Feature Versioning and Schema Evolution</h3>
<p><strong>Problem:</strong> ML model expects specific feature schema (e.g., 150 features). Adding/removing features breaks model inference.</p>
<p><strong>Solution: Feature Versioning:</strong></p>
<ul>
<li>Each feature set has semantic version (e.g., v1, v2)</li>
<li>ML model deployment specifies required feature set version</li>
<li>Tecton serves features for specified version, handling schema evolution transparently</li>
<li><strong>Migration pattern:</strong> Deploy new model version alongside old (canary deployment), both versions served simultaneously during transition period</li>
</ul>
<p><strong>Schema change example:</strong> Adding <code>last_30_day_CTR</code> feature to feature set:</p>
<ol>
<li>Define new feature in Tecton (v2 feature set)</li>
<li>Backfill historical values for existing users (batch Spark job)</li>
<li>Update streaming pipeline to compute new feature going forward</li>
<li>Train new model version with v2 feature set</li>
<li>Deploy new model via canary (10% traffic), validate improvement</li>
<li>Promote to 100%, deprecate v1 feature set after 30-day sunset period</li>
</ol>
<h3 id="operational-considerations">Operational Considerations</h3>
<p><strong>Cost Trade-Off:</strong> Managed Tecton service costs vary based on feature volume and request rate. At 1M+ QPS scale with 100-500 features per request, typical costs are comparable to 1-2× senior engineer baseline salary (high-cost region). This eliminates:</p>
<ul>
<li>2-3 FTEs for Feast self-hosting (1-3.5× baseline depending on location)</li>
<li>Infrastructure costs for self-managed Spark cluster (EMR), Redis cluster, Kafka consumers (~0.5× baseline)</li>
<li>Operational burden of 24/7 on-call for feature store incidents (priceless)</li>
</ul>
<p>Net economics favor managed solution at this scale, especially when factoring in opportunity cost of engineering focus.</p>
<p><strong>Latency Budget Validation:</strong> Feature Store allocated 10ms in <a href="/blog/ads-platform-part-1-foundation-architecture/#latency-budget-decomposition">Part 1</a>. Measured P50=3ms, P99=8ms, P99.9=12ms (occasional spikes). Within budget with 2ms buffer at P99.</p>
<p><strong>Failure Mode: Feature Store Unavailable:</strong></p>
<ul>
<li><strong>Fallback strategy:</strong> Ad Server caches last-known feature vectors in local Caffeine cache (L1)</li>
<li><strong>TTL:</strong> 60 seconds (balance between staleness and memory consumption)</li>
<li><strong>Impact:</strong> CTR prediction accuracy degrades ~5-10% with stale features, but requests continue serving</li>
<li><strong>Recovery:</strong> Automatic once Tecton Online Store recovers, features refresh on next cache miss</li>
</ul>
<p>This architecture achieves the <a href="/blog/ads-platform-part-2-rtb-ml-pipeline/#feature-engineering-architecture">Part 2 requirement</a> of serving diverse feature types (batch/stream/real-time) with &lt;10ms P99 latency while minimizing operational complexity through managed service adoption.</p>
<hr />
<h2 id="schema-evolution-zero-downtime-data-migration-strategy">Schema Evolution: Zero-Downtime Data Migration Strategy</h2>
<h3 id="the-challenge">The Challenge</h3>
<p>From <a href="/blog/ads-platform-part-4-production/#schema-evolution-zero-downtime-data-migration">Part 4’s Schema Evolution requirements</a>: All schema changes must preserve 99.9% availability (no planned downtime) while serving 1M+ QPS.</p>
<p><strong>Scenario:</strong> After 18 months in production, product team requires adding user preference fields to profile table (4TB data, 60 CockroachDB nodes). Traditional approach (take system offline, run ALTER TABLE, restart) would violate availability SLO and consume precious error budget (43 minutes/month).</p>
<h3 id="cockroachdb-online-ddl-capabilities">CockroachDB Online DDL Capabilities</h3>
<p><strong>Simple Schema Changes (Non-Blocking):</strong></p>
<ul>
<li><strong>ADD COLUMN with default value:</strong> CockroachDB executes asynchronously using background schema change job without blocking reads/writes</li>
<li><strong>CREATE INDEX CONCURRENTLY:</strong> Index built incrementally without exclusive table locks, queries continue using existing indexes during build</li>
<li><strong>DROP COLUMN (soft delete):</strong> Column marked invisible immediately, physical deletion happens asynchronously via background garbage collection</li>
</ul>
<p><strong>Why CockroachDB vs PostgreSQL for online DDL:</strong></p>
<ul>
<li><strong>No table-level locks:</strong> PostgreSQL’s ALTER TABLE acquires ACCESS EXCLUSIVE lock (blocks all operations), CockroachDB uses schema change jobs with MVCC</li>
<li><strong>Automatic rollback safety:</strong> Schema change failures automatically rollback without manual intervention</li>
<li><strong>Multi-version support:</strong> Old and new schema versions coexist during transition (critical for rolling deployments)</li>
</ul>
<h3 id="dual-write-pattern-for-complex-migrations">Dual-Write Pattern for Complex Migrations</h3>
<p><strong>When Online DDL Insufficient:</strong> Restructuring table partitioning (e.g., sharding user_profiles by region) or changing primary key requires dual-write approach.</p>
<p><strong>Five-Phase Migration Strategy:</strong></p>
<p><strong>Phase 1: Deploy Dual-Read Code (Week 1)</strong></p>
<ul>
<li>Application code updated to read from both old_table and new_table (tries new first, falls back to old)</li>
<li>Shadow traffic validation: 1% of read traffic uses new_table, compares results with old_table for data consistency verification</li>
<li><strong>Deployment:</strong> Kubernetes rolling update with PodDisruptionBudget (max 10% pods updating simultaneously)</li>
</ul>
<p><strong>Phase 2: Enable Dual-Write (Week 2)</strong></p>
<ul>
<li>All write operations execute against BOTH old_table and new_table atomically (within transaction boundary)</li>
<li><strong>Consistency guarantee:</strong> Two-phase commit ensures both writes succeed or both rollback</li>
<li><strong>Performance impact:</strong> Write latency increases ~2-3ms due to double-write overhead (acceptable temporary trade-off)</li>
</ul>
<p><strong>Phase 3: Backfill Historical Data (Weeks 3-4)</strong></p>
<ul>
<li>Background batch job copies existing data from old_table → new_table</li>
<li><strong>Rate limiting:</strong> Throttle backfill to 10K rows/sec to avoid overwhelming database (balance: completion time vs production impact)</li>
<li><strong>Verification:</strong> Checksums validate data integrity row-by-row, mismatches trigger alerts</li>
</ul>
<p><strong>Phase 4: Cutover Reads to New Table (Week 5)</strong></p>
<ul>
<li>Gradually shift read traffic: 1% → 10% → 50% → 100% over 1 week</li>
<li>Monitor error rates, latency P99, data staleness metrics at each increment</li>
<li><strong>Rollback trigger:</strong> If error rate &gt;0.5% increase, instant rollback to old_table by reverting feature flag</li>
</ul>
<p><strong>Phase 5: Drop Old Table (Week 6-8)</strong></p>
<ul>
<li>After 2 weeks of new_table serving 100% traffic with zero issues, remove old_table</li>
<li>Keep old_table in cold storage (S3 export) for 30 days as disaster recovery safety net</li>
<li>Remove dual-write code, simplify application logic</li>
</ul>
<h3 id="shadow-traffic-validation-for-financial-systems">Shadow Traffic Validation for Financial Systems</h3>
<p><strong>Why Shadow Traffic Critical:</strong> Budget operations and billing ledger changes require higher confidence than typical schema migrations. Billing errors destroy advertiser trust.</p>
<p><strong>Implementation:</strong></p>
<ul>
<li><strong>Shadow write:</strong> Prod traffic writes to new schema (new_billing_ledger_v2) in parallel with primary schema (billing_ledger_v1)</li>
<li><strong>Non-blocking:</strong> Shadow write failures logged but don’t fail primary request</li>
<li><strong>Duration:</strong> 2-3 weeks of continuous shadow traffic (captures weekly, weekend, monthly billing patterns)</li>
<li><strong>Validation metrics:</strong>
<ul>
<li>Row count delta (should be &lt;0.01%)</li>
<li>Billing amount delta (should be &lt;$0.01 per row)</li>
<li>Query latency comparison (new schema should be ±10% of old)</li>
</ul>
</li>
<li><strong>Confidence threshold:</strong> 99.99% consistency over 3 weeks → proceed with cutover</li>
</ul>
<p><strong>Gradual Rollout for Financial Operations:</strong></p>
<ul>
<li><strong>Week 1:</strong> 1% of billing queries use new schema (low-risk test)</li>
<li><strong>Week 2-3:</strong> 10% → Monitor for weekly billing reconciliation accuracy</li>
<li><strong>Month 2-5:</strong> 50% → Validate monthly invoicing correctness across both schemas</li>
<li><strong>Month 6:</strong> 100% → Full migration complete after 5-month progressive ramp</li>
</ul>
<p><strong>Trade-Off:</strong> 5-6 month timeline (vs 1-week aggressive migration) dramatically reduces risk of catastrophic billing errors that could cost millions in advertiser disputes and platform reputation damage.</p>
<h3 id="operational-safeguards">Operational Safeguards</h3>
<p><strong>Pre-Migration Checklist:</strong></p>
<ul>
<li><input disabled="" type="checkbox"/>
Full database backup completed and verified (restore test successful)</li>
<li><input disabled="" type="checkbox"/>
Rollback plan documented and rehearsed in staging environment</li>
<li><input disabled="" type="checkbox"/>
Monitoring dashboards updated with migration-specific metrics</li>
<li><input disabled="" type="checkbox"/>
On-call rotation briefed on migration timeline and rollback procedures</li>
<li><input disabled="" type="checkbox"/>
Feature flags configured for instant traffic shifting without deployment</li>
</ul>
<p><strong>Post-Migration Cleanup:</strong></p>
<ul>
<li>Remove old table after 30-day sunset period</li>
<li>Archive schema migration documentation for future reference</li>
<li>Conduct retrospective: what went well, what would we change next time</li>
<li>Update migration runbook based on lessons learned</li>
</ul>
<p>This approach achieves <a href="/blog/ads-platform-part-4-production/#schema-evolution-zero-downtime-data-migration">Part 4’s zero-downtime requirement</a> while preserving 43 minutes/month error budget for unplanned failures, not planned schema changes.</p>
<hr />
<h2 id="final-system-architecture">Final System Architecture</h2>
<p>Architecture presented using C4 model approach: System Context → Container views. Each diagram focuses on specific architectural concern for clarity.</p>
<h3 id="level-1-system-context-diagram">Level 1: System Context Diagram</h3>
<p>Shows the ads platform and its external dependencies at highest abstraction level.</p>
<pre class="mermaid">
    
    graph TB
    CLIENT[Mobile/Web Clients<br/>1M+ users]
    ADVERTISERS[Advertisers<br/>Campaign creators<br/>Budget managers]
    PLATFORM[Real-Time Ads Platform<br/>1M QPS, 150ms P99 SLO]
    DSP[DSP Partners<br/>50+ external bidders<br/>OpenRTB 2.5/3.0]
    STORAGE[Cloud Storage<br/>S3 Data Lake<br/>7-year retention]

    CLIENT -->|Ad requests| PLATFORM
    PLATFORM -->|Ad responses| CLIENT
    ADVERTISERS -->|Create campaigns<br/>Fund budgets| PLATFORM
    PLATFORM -->|Reports, analytics| ADVERTISERS
    PLATFORM <-->|Bid requests/responses<br/>100ms timeout| DSP
    PLATFORM -->|Events, audit logs| STORAGE

    style PLATFORM fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style CLIENT fill:#fff3e0,stroke:#f57c00
    style ADVERTISERS fill:#e1bee7,stroke:#8e24aa
    style DSP fill:#f3e5f5,stroke:#7b1fa2
    style STORAGE fill:#e8f5e9,stroke:#388e3c
</pre>
<p><strong>Key External Dependencies:</strong></p>
<ul>
<li><strong>Clients</strong>: Mobile apps, web browsers requesting ads (1M+ concurrent users)</li>
<li><strong>Advertisers</strong>: Create campaigns, fund budgets, receive performance reports</li>
<li><strong>DSP Partners</strong>: External demand-side platforms bidding via OpenRTB protocol (50+ integrations)</li>
<li><strong>Cloud Storage</strong>: S3 for data lake, analytics, and compliance archival (7-year retention)</li>
</ul>
<h3 id="level-2a-core-request-flow-container-diagram">Level 2a: Core Request Flow (Container Diagram)</h3>
<p>Real-time ad serving path from client request to response. Shows critical path components achieving 150ms P99 SLO.</p>
<pre class="mermaid">
    
    graph LR
    CLIENT[Client]

    subgraph EDGE["Edge Layer (15ms)"]
        CDN[CloudFront CDN<br/>5ms]
        LB[Route53 GeoDNS<br/>Multi-region<br/>5ms]
        GW[Envoy Gateway<br/>Auth + Rate Limit<br/>5ms]
    end

    subgraph SERVICES["Core Services (115ms)"]
        AS[Ad Server<br/>Orchestrator<br/>Java 21 + ZGC]

        subgraph PARALLEL["Parallel Execution"]
            direction TB
            ML_PATH[ML Path 65ms:<br/>Profile → Features → Inference]
            RTB_PATH[RTB Path 100ms:<br/>DSP Fanout → Bids]
        end

        AUCTION[Unified Auction<br/>Budget Check<br/>Winner Selection<br/>11ms]
    end

    subgraph DATA["Data Layer"]
        CACHE[(Valkey Cache<br/>L2: 2ms)]
        DB[(CockroachDB<br/>L3: 10-15ms)]
        FEATURES[(Tecton<br/>Features: 10ms)]
    end

    CLIENT -->|Request| CDN
    CDN --> LB
    LB --> GW
    GW --> AS

    AS --> ML_PATH
    AS --> RTB_PATH

    ML_PATH --> AUCTION
    RTB_PATH --> AUCTION

    ML_PATH -.-> CACHE
    ML_PATH -.-> DB
    ML_PATH -.-> FEATURES

    RTB_PATH <-.->|Bid requests/<br/>responses| DSP[50+ DSPs]

    AUCTION -.-> CACHE
    AUCTION -.-> DB
    AUCTION --> GW
    GW --> LB
    LB --> CDN
    CDN -->|Response| CLIENT

    style AS fill:#9f9,stroke:#2e7d32,stroke-width:2px
    style PARALLEL fill:#fff3e0,stroke:#f57c00
    style AUCTION fill:#ffccbc,stroke:#d84315
</pre>
<p><strong>Critical Path</strong>: Client → Edge (15ms) → Profile+Features (20ms) → Parallel[ML 65ms | RTB 100ms] → Auction+Budget (11ms) = <strong>146ms P99</strong></p>
<p><strong>Detailed flow</strong>: See <a href="/blog/ads-platform-part-1-foundation-architecture/#latency-budget-decomposition">Part 1’s latency budget</a> for component-by-component breakdown.</p>
<h3 id="level-2b-data-compliance-layer-container-diagram">Level 2b: Data &amp; Compliance Layer (Container Diagram)</h3>
<p>Dual-ledger architecture separating operational (mutable) from compliance (immutable) data stores.</p>
<pre class="mermaid">
    
    graph TB
    subgraph OPERATIONAL["Operational Systems"]
        BUDGET[Budget Service<br/>3ms atomic ops]
        BILLING[Billing Service<br/>Charges/Refunds]
    end

    subgraph CACHE["Cache & Database"]
        L2[L2: Valkey<br/>Distributed cache<br/>2ms, atomic ops]
        L3[L3: CockroachDB<br/>Operational ledger<br/>10-15ms, mutable]
    end

    subgraph COMPLIANCE["Compliance & Audit"]
        KAFKA[Kafka<br/>Financial Events<br/>30-day buffer]
        CH[(ClickHouse<br/>Immutable Audit Log<br/>7-year retention<br/>180TB)]
        RECON[Daily Reconciliation<br/>Airflow 2AM UTC<br/>Compare ledgers]
    end

    BUDGET --> L2
    BUDGET --> L3
    BUDGET -->|Async publish| KAFKA

    BILLING --> L3
    BILLING -->|Async publish| KAFKA

    KAFKA -->|Real-time<br/>5s lag| CH

    RECON -.->|Query operational| L3
    RECON -.->|Query audit| CH

    style L3 fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style CH fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style RECON fill:#ffebee,stroke:#c62828
    style KAFKA fill:#f3e5f5,stroke:#7b1fa2
    style L2 fill:#e1f5fe,stroke:#0277bd
</pre>
<p><strong>Separation of Concerns</strong>: Operational ledger optimized for performance (mutable, 90-day retention), audit log for compliance (immutable, 7-year retention, SOX/tax). Daily reconciliation ensures data integrity. Details in <a href="/blog/ads-platform-part-3-data-revenue/#immutable-financial-audit-log-compliance-architecture">Part 3’s audit log architecture</a>.</p>
<h3 id="level-2c-ml-feature-pipeline-container-diagram">Level 2c: ML &amp; Feature Pipeline (Container Diagram)</h3>
<p>Offline training and online serving infrastructure for machine learning.</p>
<pre class="mermaid">
    
    graph TB
    subgraph EVENTS["Event Collection"]
        REQUESTS[Ad Requests<br/>Impressions<br/>Clicks<br/>1M events/sec]
        KAFKA_EVENTS[Kafka Topics<br/>Event Streams]
    end

    subgraph PROCESSING["Feature Processing"]
        FLINK[Flink<br/>Stream Processing<br/>Windowed aggregations]
        SPARK[Spark<br/>Batch Processing<br/>Historical features]
        S3[(S3 Data Lake<br/>Raw events<br/>Feature snapshots)]
    end

    subgraph FEATURE_PLATFORM["Feature Platform (Tecton)"]
        OFFLINE[Offline Store<br/>Training features<br/>S3 Parquet]
        ONLINE[Online Store<br/>Serving features<br/>Redis, sub-10ms]
    end

    subgraph TRAINING["ML Training Pipeline"]
        AIRFLOW[Airflow<br/>Orchestration<br/>Daily/weekly jobs]
        TRAIN[Training Cluster<br/>GBDT<br/>LightGBM/XGBoost]
        REGISTRY[Model Registry<br/>Versioning<br/>A/B testing]
    end

    subgraph SERVING["ML Serving"]
        ML_SERVICE[ML Inference Service<br/>40ms P99<br/>CTR prediction]
    end

    REQUESTS --> KAFKA_EVENTS
    KAFKA_EVENTS --> FLINK
    KAFKA_EVENTS --> SPARK

    FLINK --> ONLINE
    SPARK --> S3
    SPARK --> OFFLINE

    AIRFLOW --> TRAIN
    TRAIN -->|Features| OFFLINE
    TRAIN --> REGISTRY

    REGISTRY -->|Deploy models| ML_SERVICE
    ML_SERVICE -->|Query features| ONLINE

    style ONLINE fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style ML_SERVICE fill:#fff9c4,stroke:#f57f17,stroke-width:2px
    style TRAIN fill:#f3e5f5,stroke:#7b1fa2
</pre>
<p><strong>Two-Track System</strong>: Offline pipeline trains models on historical data (Spark → S3 → Training cluster), online pipeline serves predictions with real-time features (Flink → Tecton → ML Inference). Model lifecycle: Train → Registry → Canary → Production. Details in <a href="/blog/ads-platform-part-2-rtb-ml-pipeline/#ml-inference-pipeline">Part 2’s ML pipeline</a>.</p>
<h3 id="level-2d-observability-stack-container-diagram">Level 2d: Observability Stack (Container Diagram)</h3>
<p>Monitoring, tracing, and alerting infrastructure for operational visibility.</p>
<pre class="mermaid">
    
    graph TB
    subgraph SERVICES["All Services"]
        APP[Application Services<br/>Ad Server, Budget, RTB<br/>Emit metrics + traces]
    end

    subgraph COLLECTION["Collection Layer"]
        PROM[Prometheus<br/>Metrics scraping<br/>15s interval]
        OTEL[OpenTelemetry Collector<br/>Trace aggregation]
        FLUENTD[Fluentd<br/>Log aggregation]
    end

    subgraph STORAGE["Storage Layer"]
        THANOS[Thanos<br/>Long-term metrics<br/>Multi-region]
        TEMPO[Tempo<br/>Distributed traces<br/>S3-backed]
        LOKI[Loki<br/>Log storage<br/>Label-based indexing]
    end

    subgraph VISUALIZATION["Visualization & Alerting"]
        GRAFANA[Grafana Dashboards<br/>SLO tracking<br/>P99 latency<br/>Error rates]
        ALERTMANAGER[AlertManager<br/>Alert routing<br/>P1/P2 severity]
    end

    PAGERDUTY[PagerDuty<br/>On-call notifications<br/>Incident management]

    APP -->|Metrics<br/>http://localhost:9090/metrics| PROM
    APP -->|Traces<br/>OTLP gRPC| OTEL
    APP -->|Logs<br/>stdout JSON| FLUENTD

    PROM --> THANOS
    OTEL --> TEMPO
    FLUENTD --> LOKI

    THANOS --> GRAFANA
    TEMPO --> GRAFANA
    LOKI --> GRAFANA

    GRAFANA --> ALERTMANAGER
    ALERTMANAGER -->|P1/P2 alerts| PAGERDUTY

    style GRAFANA fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style APP fill:#9f9,stroke:#2e7d32
    style ALERTMANAGER fill:#ffebee,stroke:#c62828
    style PAGERDUTY fill:#fff9c4,stroke:#f57f17,stroke-width:2px
</pre>
<p><strong>Observability Pillars</strong>: Metrics (Prometheus → Thanos), Traces (OpenTelemetry → Tempo), Logs (Fluentd → Loki). Unified visualization in Grafana with SLO tracking and automated alerting via AlertManager → PagerDuty for P99 latency violations, error rate spikes, budget reconciliation failures.</p>
<h3 id="technology-selection-by-component">Technology Selection by Component</h3>
<p><strong>Edge &amp; Gateway Layer</strong>:</p>
<ul>
<li><strong>CDN</strong>: CloudFront with Lambda@Edge for geo-filtering and static assets</li>
<li><strong>Global Load Balancer</strong>: Route53 GeoDNS with health checks for multi-region routing</li>
<li><strong>API Gateway</strong>: Envoy Gateway (Kubernetes Gateway API), JWT authentication via ext_authz filter, distributed rate limiting via Redis, integrated with Linkerd service mesh, 2-4ms overhead target</li>
</ul>
<p><strong>Core Application Services</strong> (all communicate via gRPC over HTTP/2):</p>
<ul>
<li><strong>Ad Server Orchestrator</strong>: Java 21 + ZGC (sub-2ms GC pauses), Spring Boot, 300 instances @ 5K QPS each, central coordinator</li>
<li><strong>User Profile Service</strong>: Java 21 + ZGC, <strong>dual-mode architecture</strong> serving identity-based profiles when available, contextual-only signals (page, device, geo, time) when user_id unavailable (40-60% of mobile traffic). Manages L1/L2/L3 cache hierarchy, 10ms target</li>
<li><strong>Integrity Check Service</strong>: Go (lightweight, sub-ms latency), Bloom filter fraud detection, 5ms target</li>
<li><strong>Ad Selection Service</strong>: Java 21 + ZGC, queries CockroachDB for internal ad candidates, 15ms target</li>
<li><strong>ML Inference Service</strong>: GBDT (LightGBM/XGBoost) CTR prediction, 40ms target, eCPM calculation</li>
<li><strong>DSP Performance Tier Service</strong>: Java 21 + ZGC, tracks P50/P95/P99 latency per DSP hourly, provides tier filtering for egress cost optimization (detailed in <a href="/blog/ads-platform-part-2-rtb-ml-pipeline/#egress-bandwidth-cost-optimization-predictive-dsp-timeouts">Part 2</a>), 1ms lookup latency</li>
<li><strong>RTB Auction Service</strong>: Java 21 + ZGC, HTTP/2 connection pooling, fanout to 20-30 selected DSPs (filtered by DSP Performance Tier Service) via OpenRTB 2.5/3.0, 100ms target</li>
<li><strong>Budget Service</strong>: Java 21 + ZGC, Redis atomic DECRBY operations for spend tracking, 3ms target</li>
<li><strong>Auction Logic</strong>: Java 21 + ZGC, unified auction combining internal ML-scored ads + external RTB bids, first-price auction</li>
</ul>
<p><strong>Data Layer</strong>:</p>
<ul>
<li><strong>L1 Cache</strong>: Caffeine in-process JVM heap cache, 0.5ms latency, 60-70% hit rate for hot user profiles</li>
<li><strong>L2 Cache</strong>: Redis/Valkey 20-node distributed cache, 1-2ms latency, 25% hit rate, also serves budget counters and rate limiting tokens</li>
<li><strong>L3 Database</strong>: CockroachDB Serverless multi-region (fully managed), stores user profiles, campaigns, operational ledger (mutable, 90-day retention) with HLC timestamps, 10-15ms latency</li>
<li><strong>Audit Log</strong>: ClickHouse 8 nodes (3× replication), immutable financial audit log for SOX/tax compliance, consumes from Kafka, 7-year retention (~180TB), &lt;500ms audit query latency</li>
</ul>
<p><strong>Feature Platform (Tecton Managed)</strong>:</p>
<ul>
<li><strong>Tecton Online Store</strong>: Redis-backed real-time feature serving, sub-10ms P99</li>
<li><strong>Tecton Offline</strong>: Batch features via Spark, streaming features via Rift engine</li>
<li><strong>Feature Store Integration</strong>: Consumes from Flink → Kafka pipeline for real-time feature updates</li>
</ul>
<p><strong>Data Processing Pipeline</strong>:</p>
<ul>
<li><strong>Kafka</strong>: Event streams for click/impression/conversion events, 100K events/sec</li>
<li><strong>Flink</strong>: Stream processing for event preparation, deduplication, enrichment (upstream of Tecton)</li>
<li><strong>Spark</strong>: Batch processing for feature engineering and aggregations</li>
<li><strong>S3 + Athena</strong>: Data lake for cold storage, analytics queries, 500TB+ daily, 7-year retention</li>
</ul>
<p><strong>ML Training Pipeline (Offline)</strong>:</p>
<ul>
<li><strong>Airflow</strong>: Orchestration for daily/weekly training jobs</li>
<li><strong>Training Cluster</strong>: GBDT model retraining (LightGBM/XGBoost) on historical data</li>
<li><strong>Model Registry</strong>: Versioning, A/B testing, gradual rollout of new models</li>
</ul>
<p><strong>Observability</strong>:</p>
<ul>
<li><strong>Metrics</strong>: Prometheus + Thanos for multi-region aggregation</li>
<li><strong>Distributed Tracing</strong>: OpenTelemetry + Tempo (not Jaeger - lower overhead)</li>
<li><strong>Dashboards</strong>: Grafana for SLO tracking and alerting</li>
<li><strong>Logging</strong>: Fluentd + Loki for structured log aggregation</li>
</ul>
<p><strong>Infrastructure</strong>:</p>
<ul>
<li><strong>Service Mesh</strong>: Linkerd (mTLS, circuit breaking, 5-10ms overhead vs 15-25ms for Istio)</li>
<li><strong>Orchestration</strong>: Kubernetes 1.28 or later across 3 AWS regions (us-east-1, us-west-2, eu-west-1)</li>
<li><strong>Container Runtime</strong>: containerd (lightweight, OCI-compliant)</li>
</ul>
<p><strong>External Integration</strong>:</p>
<ul>
<li><strong>DSP Partners</strong>: 50+ bidders via REST/JSON over HTTP/2 (OpenRTB 2.5/3.0 protocol)</li>
</ul>
<h3 id="latency-budget-breakdown-final">Latency Budget Breakdown (Final)</h3>
<table><thead><tr><th>Component</th><th>Technology</th><th>Latency</th><th>Notes</th></tr></thead><tbody>
<tr><td><strong>Edge</strong></td><td>CloudFront</td><td>5ms</td><td>Global PoP routing</td></tr>
<tr><td><strong>Gateway</strong></td><td>Envoy Gateway</td><td>4ms</td><td>Auth (2ms) + Rate limiting (0.5ms) + Routing (1.5ms)</td></tr>
<tr><td><strong>User Profile</strong></td><td>Java 21 + L1/L2/L3 cache</td><td>10ms</td><td>L1 Caffeine (0.5ms 60% hit) → L2 Redis (2ms 25% hit) → L3 CockroachDB (10-15ms 15% miss)</td></tr>
<tr><td><strong>Integrity Check</strong></td><td>Go lightweight filter</td><td>5ms</td><td>Fraud Bloom filter, stateless</td></tr>
<tr><td><strong>Feature Store</strong></td><td>Tecton online store</td><td>10ms</td><td>Real-time feature lookup, Redis-backed</td></tr>
<tr><td><strong>Ad Selection</strong></td><td>Java 21 + CockroachDB</td><td>15ms</td><td>Internal ad candidates query</td></tr>
<tr><td><strong>ML Inference</strong></td><td>GBDT (LightGBM/XGBoost)</td><td>40ms</td><td>CTR prediction on candidates, eCPM calculation</td></tr>
<tr><td><strong>RTB Auction</strong></td><td>Java 21 + HTTP/2 fanout</td><td>100ms</td><td><strong>Critical path</strong> - DSP selection (1ms) + 20-30 selected DSPs parallel (99ms), runs parallel to ML path (65ms). See <a href="/blog/ads-platform-part-2-rtb-ml-pipeline/#egress-bandwidth-cost-optimization-predictive-dsp-timeouts">Part 2</a> for DSP tier filtering and egress cost optimization</td></tr>
<tr><td><strong>Budget Check</strong></td><td>Java 21 + Valkey</td><td>3ms</td><td>Redis DECRBY atomic op</td></tr>
<tr><td><strong>Auction Logic</strong></td><td>Java 21 + ZGC</td><td>8ms</td><td>eCPM comparison, winner selection</td></tr>
<tr><td><strong>Serialization</strong></td><td>gRPC protobuf</td><td>5ms</td><td>Response formatting</td></tr>
<tr><td><strong>Total</strong></td><td>-</td><td><strong>143ms avg</strong></td><td><strong>145ms P99</strong>, 5ms buffer to 150ms SLO</td></tr>
</tbody></table>
<p><strong>Critical path</strong>: Network (5ms) → Gateway (10ms) → User Profile (10ms) → Integrity (5ms) → RTB (100ms, parallel with ML 65ms) → Auction + Budget (11ms) → Response (5ms) = <strong>146ms P99</strong></p>
<p><strong>P99 Protection:</strong></p>
<ul>
<li><strong>ZGC</strong>: &lt;2ms pauses (vs 41-55ms with G1GC)</li>
<li><strong>RTB 120ms cutoff</strong>: Forced fallback prevents timeout (from <a href="/blog/ads-platform-part-1-foundation-architecture/#p99-tail-latency-defense-the-unacceptable-tail">Part 1’s P99 defense</a>)</li>
</ul>
<hr />
<h2 id="architecture-decision-summary">Architecture Decision Summary</h2>
<p>Complete table of all major technology decisions and rationale:</p>
<table><thead><tr><th>Decision Category</th><th>Choice</th><th>Alternatives Considered</th><th>Rationale</th></tr></thead><tbody>
<tr><td><strong>Runtime (All Services)</strong></td><td>Java 21 + ZGC + Virtual Threads</td><td>Go, Rust, Java + G1GC</td><td>Virtual threads enable 10K+ concurrent I/O operations with simple blocking code (vs callback complexity). ZGC provides &lt;2ms GC pauses at 32GB heap. Single runtime across all services reduces operational complexity (unified monitoring, debugging, deployment). Netflix validation: 95% error reduction with ZGC.</td></tr>
<tr><td><strong>Internal RPC</strong></td><td>gRPC over HTTP/2</td><td>REST/JSON, Thrift</td><td>3-10× smaller payloads, &lt;1ms serialization, type safety</td></tr>
<tr><td><strong>External API</strong></td><td>REST/JSON</td><td>gRPC</td><td>OpenRTB standard compliance, DSP compatibility</td></tr>
<tr><td><strong>Service Mesh</strong></td><td>Linkerd</td><td>Istio, Consul Connect</td><td>5-10ms overhead (vs 15-25ms Istio), gRPC-native</td></tr>
<tr><td><strong>Transactional DB</strong></td><td>CockroachDB 23.x</td><td>PostgreSQL, MySQL, Spanner</td><td>Multi-region native, HLC for audit trails, 2-3× cheaper than DynamoDB at 1M+ QPS</td></tr>
<tr><td><strong>Distributed Cache</strong></td><td>Valkey 7.x</td><td>Redis, Memcached</td><td>Atomic ops (DECRBY), sub-ms latency, permissive license (vs Redis SSPL)</td></tr>
<tr><td><strong>In-Process Cache</strong></td><td>Caffeine</td><td>Guava, Ehcache</td><td>8-12× faster than Redis L2, excellent eviction policies</td></tr>
<tr><td><strong>ML Model</strong></td><td>GBDT (LightGBM/XGBoost)</td><td>Deep Neural Nets, Factorization Machines</td><td>20ms inference, operational benefits (incremental learning, interpretability), 0.78-0.82 AUC</td></tr>
<tr><td><strong>Feature Store</strong></td><td>Tecton (managed)</td><td>Feast (self-hosted), custom Redis</td><td>Real-time (Rift) + batch (Spark), &lt;10ms P99, 5-8× cheaper than custom solution</td></tr>
<tr><td><strong>Feature Processing</strong></td><td>Flink + Kafka + Tecton</td><td>Custom pipelines</td><td>Flink for stream prep, Tecton Rift for feature computation, separation of concerns</td></tr>
<tr><td><strong>Container Orchestration</strong></td><td>Kubernetes 1.28 or later</td><td>Raw EC2, ECS</td><td>Declarative config, auto-scaling, 60% better resource efficiency</td></tr>
<tr><td><strong>Container Runtime</strong></td><td>containerd</td><td>Docker</td><td>Lightweight, OCI-compliant, Kubernetes-native</td></tr>
<tr><td><strong>Cloud Provider</strong></td><td>AWS multi-region</td><td>GCP, Azure</td><td>Broadest service coverage, mature networking (VPC peering)</td></tr>
<tr><td><strong>Regions</strong></td><td>us-east-1, us-west-2, eu-west-1</td><td>Single region</td><td>&lt;50ms inter-region, geographic distribution</td></tr>
<tr><td><strong>CDN</strong></td><td>CloudFront</td><td>Cloudflare, Fastly</td><td>AWS-native integration, Lambda@Edge for geo-filtering</td></tr>
<tr><td><strong>Metrics</strong></td><td>Prometheus + Thanos</td><td>Datadog, New Relic</td><td>Kubernetes-native, multi-region aggregation, cost-effective</td></tr>
<tr><td><strong>Tracing</strong></td><td>OpenTelemetry + Tempo</td><td>Jaeger, Zipkin</td><td>Vendor-neutral, low overhead, latency analysis</td></tr>
<tr><td><strong>Logging</strong></td><td>Fluentd + Loki</td><td>Elasticsearch</td><td>Label-based querying, cost-effective storage</td></tr>
</tbody></table>
<hr />
<h2 id="system-integration-how-it-all-works-together">System Integration: How It All Works Together</h2>
<p>Single ad request flow demonstrating how technology components achieve 150ms P99 latency, revenue optimization, and compliance.</p>
<h3 id="critical-path-request-to-response-146ms-p99">Critical Path: Request to Response (146ms P99)</h3>
<p><strong>Edge Layer (15ms):</strong> CloudFront CDN geo-routes and serves static assets (5ms). Route53 GeoDNS directs to nearest region. Envoy Gateway performs JWT validation via ext_authz filter with 60s cache (1-2ms), enforces rate limits via Valkey token bucket (0.5ms), routes request (1-1.5ms) = 4ms total. Linkerd Service Mesh adds mTLS encryption and observability (1ms), delivers to Ad Server (Java 21 + ZGC).</p>
<p><strong>User Context (15ms parallel):</strong> Ad Server fires parallel gRPC calls. User Profile Service queries L1 Caffeine (0.5ms, 60% hit) → L2 Valkey (2ms, 25% hit) → L3 CockroachDB (10-15ms, 15% miss). Integrity Check Service validates via Valkey Bloom filter (1ms). Both complete within 15ms budget.</p>
<p><strong>Parallel Revenue Paths (100ms critical):</strong> Platform runs two paths simultaneously for revenue maximization.</p>
<ul>
<li>
<p><strong>ML Path (65ms):</strong> Tecton Feature Store lookup (10ms Redis-backed Online Store) → Ad Selection Service queries CockroachDB for 20-50 candidates (15ms) → ML Inference Service runs GBDT (LightGBM) CTR prediction with 500+ features, computes eCPM (40ms).</p>
</li>
<li>
<p><strong>RTB Path (100ms):</strong> RTB Gateway maintains pre-warmed HTTP/2 pools (32 connections/DSP), selects 20-30 DSPs via performance tiers (<a href="/blog/ads-platform-part-2-rtb-ml-pipeline/#egress-bandwidth-cost-optimization-predictive-dsp-timeouts">Part 2 cost optimization</a>), fans out OpenRTB 2.5/3.0 requests with 120ms hard cutoff. Tier-1 DSPs respond in 60-80ms.</p>
</li>
</ul>
<p>Critical path is RTB’s 100ms (parallel, not additive).</p>
<p><strong>Unified Auction (11ms):</strong> Auction Service runs first-price auction comparing ML-scored internal ads vs RTB bids, selects highest eCPM (3ms). Budget Service executes atomic Valkey Lua script: <code>if balance &gt;= amount then balance -= amount</code> (3ms avg, 5ms P99), prevents double-spend without locks. Failed budget check triggers fallback to next bidder. Successful deductions append asynchronously to CockroachDB operational ledger, publish to Kafka for ClickHouse audit log.</p>
<p><strong>Response (5ms):</strong> Ad Server serializes winning ad via gRPC protobuf, returns through Linkerd → Envoy → Route53 → CloudFront. <strong>Total: 146ms P99</strong> (4ms buffer under 150ms SLO).</p>
<h3 id="background-processing-asynchronous-feedback-loop">Background Processing: Asynchronous Feedback Loop</h3>
<p><strong>Event Collection:</strong> Ad Server publishes impression/click events to Kafka post-response (ad ID, features, prediction, outcome). Zero impact on request latency.</p>
<p><strong>Real-Time Aggregation:</strong> Flink consumes Kafka events, computes windowed aggregations (fraud detection, feature updates). Tecton Rift materializes streaming features (“clicks in last hour”) to Online Store within seconds.</p>
<p><strong>Model Training:</strong> Daily Spark jobs export events to S3 Parquet (billions of examples). Airflow orchestrates GBDT retraining, new models versioned in Model Registry, undergo A/B testing, canary rollout to production. Continuous improvement without latency impact.</p>
<h3 id="key-data-flow-patterns">Key Data Flow Patterns</h3>
<p><strong>Cache Hierarchy:</strong> Three-tier achieves 78-88% hit rate (conservative range accounting for LRU vs LFU, workload variation). L1 Caffeine (0.5ms, 60% hot profiles) → L2 Valkey (2ms, 25% warm profiles) → L3 CockroachDB (10-15ms, 15% cold misses). Weighted average: 60%×0.5ms + 25%×2ms + 15%×12ms = <strong>0.6ms effective latency</strong> (20× faster than L3-only). Consistency via invalidation: L1 expires on writes, L2 uses 60s TTL, L3 source of truth.</p>
<p><strong>Atomic Budget:</strong> Pre-allocation divides daily budget into 1-minute windows ($1440/day = $1/min), smooths spend. Valkey Lua script server-side atomic check-and-deduct eliminates race conditions, 3ms latency under contention. Audit trail: async append to CockroachDB (HLC timestamps) → Kafka → ClickHouse. Hourly reconciliation compares Valkey vs CockroachDB, alerts on discrepancies &gt;$1.</p>
<p><strong>Feature Pipeline:</strong> Two-track system for latency/accuracy trade-off. <strong>Real-time:</strong> Flink processes Kafka events (1-hour click rate, 5-min conversion rate) → Tecton Rift materializes to Online Store (seconds lag), enables reactive features. <strong>Batch:</strong> Spark daily jobs compute historical features (7-day CTR, 30-day AOV) → Offline Store (training) + Online Store (serving). Tecton Online Store unifies both tracks, single API &lt;10ms P99.</p>
<hr />
<h2 id="deployment-architecture-final">Deployment Architecture (Final)</h2>
<h3 id="multi-region-active-active">Multi-Region Active-Active</h3>
<p><strong>3 AWS Regions:</strong></p>
<ul>
<li><strong>us-east-1</strong> (Primary): 40% of traffic (400K QPS)</li>
<li><strong>us-west-2</strong> (Secondary): 35% of traffic (350K QPS)</li>
<li><strong>eu-west-1</strong> (Europe): 25% of traffic (250K QPS)</li>
</ul>
<p><strong>Traffic Routing:</strong></p>
<ul>
<li><strong>GeoDNS</strong> (Route 53): Routes clients to nearest region</li>
<li><strong>Health Checks</strong>: Automatic failover if region P99 &gt; 200ms or error rate &gt; 1%</li>
<li><strong>Failover Time</strong>: 2-5 minutes (DNS TTL + health check interval)</li>
</ul>
<p><strong>Data Replication:</strong></p>
<ul>
<li><strong>CockroachDB</strong>: Multi-region survival goal (survives 1 region loss)</li>
<li><strong>Valkey</strong>: Cross-region replication with 100-200ms lag (acceptable for cache)</li>
<li><strong>DynamoDB</strong>: Global tables with &lt;1s replication lag</li>
</ul>
<p><strong>Per-Region Deployment:</strong></p>
<p><strong>Region: us-east-1</strong> (400K QPS capacity)</p>
<p><strong>Kubernetes Cluster</strong>: 75 nodes</p>
<ul>
<li>Ad Server: 120 pods (3.3K QPS per pod)</li>
<li>User Profile: 80 pods (5K QPS per pod with 60% L1/25% L2/15% L3 hit rates)</li>
<li>ML Inference: 600-800 pods (CPU GBDT, 500-700 QPS/pod)</li>
<li>RTB Gateway: 50 pods</li>
<li>Budget Service: 20 pods</li>
<li>Other services: 100 pods</li>
</ul>
<p><strong>Data Layer</strong>:</p>
<ul>
<li>CockroachDB: 20 nodes (raft replicas)</li>
<li>Valkey Cluster: 8 nodes (leader + replicas)</li>
</ul>
<p><strong>Observability</strong>: 10 nodes (Prometheus, Grafana)</p>
<h3 id="scaling-strategy">Scaling Strategy</h3>
<p><strong>Horizontal Scaling:</strong></p>
<ul>
<li><strong>Trigger</strong>: CPU &gt;70% OR QPS per pod &gt;5K for 2 minutes</li>
<li><strong>Scale-up</strong>: +50% pods (capped at 400 total)</li>
<li><strong>Scale-down</strong>: -10% pods after 5 minutes stable (min 200 pods)</li>
</ul>
<p><strong>Vertical Scaling (Database):</strong></p>
<ul>
<li><strong>CockroachDB</strong>: Add nodes when CPU &gt;60% sustained</li>
<li><strong>Valkey</strong>: Add shards when memory &gt;70% or QPS &gt;1M per shard</li>
</ul>
<p><strong>Cost Optimization:</strong></p>
<ul>
<li><strong>Reserved Instances</strong>: 70% of base capacity (200 pods)</li>
<li><strong>Spot Instances</strong>: 30% of burst capacity (100 pods)</li>
<li><strong>Auto-scaling</strong>: Handles traffic spikes 1.5× capacity</li>
</ul>
<p><strong>Hedge Request Cost Impact:</strong></p>
<p>From <a href="/blog/ads-platform-part-1-foundation-architecture/#p99-tail-latency-defense-the-unacceptable-tail">Part 1’s Defense Strategy 3</a>, hedge requests are configured for User Profile Service to protect against network jitter.</p>
<p><strong>Additional infrastructure cost:</strong></p>
<ul>
<li><strong>Baseline User Profile capacity</strong>: 240 pods across 3 regions (80 per region)</li>
<li><strong>Hedge request load</strong>: ~5% additional read traffic (hedges trigger only when primary exceeds P95 latency)</li>
<li><strong>Required capacity increase</strong>: +4 pods per region (+12 total) to maintain headroom</li>
<li><strong>Cost impact</strong>: +5% User Profile Service infrastructure</li>
</ul>
<p><strong>Total deployment cost impact:</strong></p>
<ul>
<li>User Profile represents ~19% of total compute (240 of ~1,260 total pods across 3 regions)</li>
<li>5% increase on 19% = <strong>~1% total infrastructure cost increase</strong></li>
<li><strong>Trade-off justification</strong>: This marginal cost (~1% infrastructure budget) buys 30-40% P99.9 latency reduction on critical User Profile path, preventing revenue loss from SLO violations</li>
</ul>
<p><strong>Why this is cost-effective:</strong></p>
<ul>
<li>User Profile reads are cache-heavy (60% L1 hit, 25% L2 hit) - additional load costs &lt; 1ms per hedged request</li>
<li>Client-side only implementation - requires only gRPC client configuration, no server architecture changes</li>
<li>Preventing P99.9 tail latency violations (which could push total latency &gt;200ms mobile timeout) protects revenue on high-value traffic</li>
<li>Production-validated: 30-40% P99.9 improvement at Google, Global Payments, and Grafana</li>
</ul>
<p><strong>Implementation requirements:</strong></p>
<p>gRPC native hedging configuration (from <a href="/blog/ads-platform-part-1-foundation-architecture/#p99-tail-latency-defense-the-unacceptable-tail">Part 1</a>):</p>
<ul>
<li>Service configuration specifies maximum attempts (2 = primary + one hedge)</li>
<li>Hedging delay set to P95 latency threshold (3ms for User Profile Service)</li>
<li>Service allowlist restricts hedging to read-only, idempotent methods only (UserProfileService, FeatureStoreService)</li>
</ul>
<p>Service mesh integration (Linkerd/Istio):</p>
<ul>
<li>Leverage built-in latency-aware load balancing (EWMA or least-request algorithms)</li>
<li>Service mesh automatically routes hedge requests to faster replicas</li>
<li>No custom load balancing logic required</li>
</ul>
<p><strong>Monitoring metrics required:</strong></p>
<ul>
<li><code>hedge_request_rate</code>: Percentage of requests that triggered hedge (target: 5%, alert if &gt;15%)</li>
<li><code>hedge_win_rate</code>: Percentage where hedge response arrived first (target: 5-10%, investigate if &gt;20%)</li>
<li><code>user_profile_p99_latency</code>: Track primary request latency to detect degradation</li>
<li><code>circuit_breaker_state</code>: Monitor circuit breaker status (closed/open/half-open)</li>
</ul>
<p><strong>Circuit breaker configuration:</strong></p>
<ul>
<li>Monitor hedge rate over rolling 60-second window</li>
<li>If hedge rate exceeds 15-20% for sustained period, disable hedging for 5 minutes</li>
<li>Prevents cascading failures during system degradation (when all requests exceed P95 threshold)</li>
<li>Additional safety: disable hedging during multi-region failover</li>
</ul>
<p><strong>Cache coherence trade-off:</strong></p>
<ul>
<li>Accept up to 60-second staleness from L1 in-process cache inconsistency between replicas</li>
<li>For critical updates (GDPR opt-out, account suspension), implement active invalidation via L2 cache eviction events</li>
<li>This is fundamental distributed caching challenge, not specific to hedging</li>
</ul>
<p><strong>Server-side requirements:</strong></p>
<ul>
<li>Implement cooperative cancellation handling (check cancellation token and abort work)</li>
<li>Ensures cancelled requests release resources (cache locks, DB connections, CPU)</li>
<li>Without proper cancellation handling, compute cost remains 2× instead of achieving ~1× target</li>
</ul>
<hr />
<h2 id="validating-against-part-1-requirements">Validating Against Part 1 Requirements</h2>
<p>Let’s verify the final architecture meets the requirements established in Part 1.</p>
<h3 id="requirement-1-latency-150ms-p99-slo">Requirement 1: Latency (150ms P99 SLO)</h3>
<p><strong>Target from <a href="/blog/ads-platform-part-1-foundation-architecture/#latency-budget-decomposition">Part 1</a>:</strong> ≤150ms P99 latency, mobile timeout at 200ms</p>
<p><strong>Achieved:</strong></p>
<ul>
<li><strong>Average</strong>: 143ms (5ms edge + 10ms user profile + 5ms fraud + 100ms RTB + 8ms auction + 15ms network)</li>
<li><strong>P99</strong>: 145ms (5ms buffer to SLO)</li>
<li><strong>Breakdown by component:</strong></li>
</ul>
<table><thead><tr><th>Component</th><th>Budget (Part 1)</th><th>Achieved (Part 5)</th><th>Status</th></tr></thead><tbody>
<tr><td>Edge (CDN + LB)</td><td>10ms</td><td>5ms</td><td>Under budget</td></tr>
<tr><td>Gateway (Auth + Rate Limit)</td><td>5ms</td><td>4ms</td><td>Under budget</td></tr>
<tr><td>User Profile (L1/L2/L3)</td><td>10ms</td><td>10ms</td><td>On budget</td></tr>
<tr><td>Integrity Check</td><td>5ms</td><td>5ms</td><td>On budget</td></tr>
<tr><td>Feature Store</td><td>10ms</td><td>10ms</td><td>On budget</td></tr>
<tr><td>Ad Selection</td><td>15ms</td><td>15ms</td><td>On budget</td></tr>
<tr><td>ML Inference</td><td>40ms</td><td>40ms</td><td>On budget</td></tr>
<tr><td>RTB Auction</td><td>100ms</td><td>100ms</td><td>On budget</td></tr>
<tr><td>Auction Logic + Budget</td><td>10ms</td><td>8ms</td><td>Under budget</td></tr>
<tr><td>Response Serialization</td><td>5ms</td><td>5ms</td><td>On budget</td></tr>
<tr><td><strong>Total</strong></td><td><strong>150ms</strong></td><td><strong>143ms avg, 145ms P99</strong></td><td><strong>Met</strong></td></tr>
</tbody></table>
<p><strong>Key enablers:</strong></p>
<ul>
<li>ZGC: Eliminated 41-55ms GC pauses (now &lt;2ms)</li>
<li>gRPC: Saved 2-5ms per service call vs REST/JSON</li>
<li>Linkerd: 5-10ms overhead vs Istio’s 15-25ms</li>
<li>Hedge requests: 30-40% P99.9 tail latency reduction on User Profile path (<a href="https://cacm.acm.org/research/the-tail-at-scale/">Google 40%</a>, <a href="https://aws.amazon.com/blogs/database/how-global-payments-inc-improved-their-tail-latency-using-request-hedging-with-amazon-dynamodb/">Global Payments 30%</a>), protecting against network jitter (~1% infrastructure cost with circuit breaker safety)</li>
</ul>
<h3 id="requirement-2-scale-1m-qps">Requirement 2: Scale (1M+ QPS)</h3>
<p><strong>Target from <a href="/blog/ads-platform-part-1-foundation-architecture/#horizontal-scaling-model">Part 1</a>:</strong> Handle 1 million queries per second across all regions</p>
<p><strong>Achieved:</strong></p>
<ul>
<li><strong>Ad Server</strong>: 300 instances × 5K QPS = 1.5M QPS capacity (50% headroom)</li>
<li><strong>Data Layer</strong>:
<ul>
<li>CockroachDB: 60 nodes × 20K QPS = 1.2M QPS</li>
<li>Valkey: 20 nodes × 100K QPS = 2M QPS</li>
</ul>
</li>
<li><strong>Multi-region</strong>: 3 regions (us-east-1, us-west-2, eu-west-1), each sized for 750K QPS (50% total capacity) to absorb regional failover</li>
</ul>
<p><strong>Validation:</strong></p>
<ul>
<li>Peak traffic: 1.5M QPS during Black Friday (50% over baseline)</li>
<li>Auto-scaling: HPA scales from 200 to 500 pods in 3 minutes</li>
<li>Regional failover: Route53 health checks redirect traffic in 2-5 minutes</li>
</ul>
<h3 id="requirement-3-financial-accuracy-1-budget-variance">Requirement 3: Financial Accuracy (≤1% Budget Variance)</h3>
<p><strong>Target from <a href="/blog/ads-platform-part-1-foundation-architecture/#architectural-drivers-the-three-non-negotiables">Part 1</a>:</strong> Achieve ≤1% billing accuracy for all advertiser spend</p>
<p><strong>Achieved:</strong></p>
<ul>
<li><strong>Atomic operations</strong>: Valkey Lua scripts provide lock-free budget deduction</li>
<li><strong>Audit trail</strong>: CockroachDB HLC timestamps ensure linearizable ordering</li>
<li><strong>Reconciliation</strong>: Hourly job compares Valkey counters vs CockroachDB ledger</li>
<li><strong>Measured variance</strong>: 0.3% overspend at P99 (3× better than requirement)</li>
</ul>
<p><strong>Key enablers:</strong></p>
<ul>
<li>Atomic DECRBY prevents race conditions (vs optimistic locking with retries)</li>
<li>HLC timestamps resolve event ordering across regions</li>
<li>Idempotency keys prevent duplicate charges on retries</li>
</ul>
<h3 id="requirement-4-availability-99-9-uptime">Requirement 4: Availability (99.9% Uptime)</h3>
<p><strong>Target from <a href="/blog/ads-platform-part-1-foundation-architecture/#architectural-drivers-the-three-non-negotiables">Part 1</a>:</strong> Maintain 99.9%+ availability (43 minutes downtime/month)</p>
<p><strong>Achieved:</strong></p>
<ul>
<li><strong>Measured uptime</strong>: 99.95% (22 minutes downtime/month)</li>
<li><strong>Multi-region</strong>: Active-active survives full region failure</li>
<li><strong>Zero-downtime deployments</strong>: Kubernetes rolling updates with PodDisruptionBudget</li>
<li><strong>Graceful degradation</strong>: RTB timeout triggers fallback to internal ads (40% revenue vs 100% loss)</li>
</ul>
<p><strong>Validation:</strong></p>
<ul>
<li>Chaos testing: Killed entire us-east-1 region, traffic shifted to us-west-2 in 3 minutes</li>
<li>No user-visible errors during deployment of 47 service updates in November</li>
</ul>
<h3 id="requirement-5-revenue-maximization">Requirement 5: Revenue Maximization</h3>
<p><strong>Target from <a href="/blog/ads-platform-part-1-foundation-architecture/#critical-path-and-dual-source-architecture">Part 1</a>:</strong> Dual-source architecture (internal ML + external RTB) for maximum fill rate and eCPM</p>
<p><strong>Achieved:</strong></p>
<ul>
<li><strong>30-48% revenue lift</strong> vs single-source (RTB-only or ML-only)</li>
<li><strong>100% fill rate</strong>: Graceful degradation ensures every request gets an ad (house ads as last resort)</li>
<li><strong>eCPM optimization</strong>: Unified auction compares internal ML-scored ads against external RTB bids</li>
</ul>
<p><strong>Measured results:</strong></p>
<ul>
<li>Average eCPM: $3.20 (vs $2.20 for RTB-only baseline)</li>
<li>Fill rate: 99.8% (0.2% dropped due to fraud/malformed requests)</li>
<li>Revenue per 1M impressions: $3,200 vs $2,200 (45% lift)</li>
</ul>
<p><strong>All <a href="/blog/ads-platform-part-1-foundation-architecture/">Part 1</a> requirements met or exceeded.</strong></p>
<hr />
<h2 id="conclusion-from-architecture-to-implementation">Conclusion: From Architecture to Implementation</h2>
<h3 id="the-complete-stack">The Complete Stack</h3>
<p>This series took you from abstract requirements to a concrete, production-ready system:</p>
<p><strong><a href="/blog/ads-platform-part-1-foundation-architecture/">Part 1</a></strong> asked “What makes a real-time ads platform hard?” and answered with latency budgets, P99 tail defense, and graceful degradation patterns.</p>
<p><strong><a href="/blog/ads-platform-part-2-rtb-ml-pipeline/">Part 2</a></strong> solved “How do we maximize revenue?” with the dual-source architecture - parallelizing ML (65ms) and RTB (100ms) for 30-48% revenue lift.</p>
<p><strong><a href="/blog/ads-platform-part-3-data-revenue/">Part 3</a></strong> answered “How do we serve 1M+ QPS with sub-10ms reads?” with L1/L2/L3 cache hierarchy achieving 78-88% hit rates and distributed budget pacing with ≤1% variance.</p>
<p><strong><a href="/blog/ads-platform-part-4-production/">Part 4</a></strong> addressed “How do we run this in production?” with fraud detection, multi-region active-active, zero-downtime deployments, and chaos engineering.</p>
<p><strong>Part 5 (this post)</strong> delivered “What specific technologies should we use?” with:</p>
<ul>
<li><strong>Java 21 + ZGC</strong> for &lt;2ms GC pauses (vs G1GC’s 41-55ms)</li>
<li><strong>Envoy Gateway + Linkerd</strong> for 4ms + 5-10ms overhead (vs 10ms + 15-25ms alternatives)</li>
<li><strong>CockroachDB</strong> for 2-3× cost savings vs DynamoDB at 1M+ QPS</li>
<li><strong>Valkey</strong> for atomic budget operations with 0.8ms P99 latency</li>
<li><strong>Tecton</strong> for managed feature store with &lt;10ms P99</li>
<li><strong>Kubernetes</strong> for 60% resource efficiency vs VMs</li>
</ul>
<h3 id="implementation-timeline">Implementation Timeline</h3>
<p><strong>Realistic timeline: 15-18 months from kickoff to full production.</strong></p>
<p><strong>Why 15-18 Months</strong></p>
<p>Three non-technical gates dominate the critical path:</p>
<ul>
<li>
<p><strong>DSP Legal Contracts (12-16 weeks per batch):</strong> Real-time bidding requires signed agreements with each DSP. Legal review, compliance verification, and business approval can’t be accelerated. Launch requires 10-15 DSPs.</p>
</li>
<li>
<p><strong>SOC 2 Compliance (12+ weeks):</strong> Enterprise advertisers require SOC 2 Type I certification. Control implementation, evidence collection, and third-party audit take minimum 12 weeks. Non-negotiable for Fortune 500 contracts.</p>
</li>
<li>
<p><strong>Financial System Gradual Ramp (6 months):</strong> Standard canary deployment is too risky for financial systems where billing errors destroy advertiser trust. Shadow traffic validation (2-3 weeks) followed by progressive ramp (1% → 100% over 5 months) with weekly billing reconciliation is required.</p>
</li>
</ul>
<p><strong>Critical path:</strong> DSP legal + SOC 2 + gradual ramp = 15-18 months. Technical implementation (infrastructure, ML pipeline, RTB integration) completes in 9-12 months but is gated by external dependencies. Engineering velocity doesn’t accelerate legal negotiations or financial system validation.</p>
<h3 id="key-learnings">Key Learnings</h3>
<p><strong>1. Latency dominates at scale</strong>
Every millisecond counts at 1M+ QPS. Choosing ZGC saved 40-50ms. Choosing gRPC saved 2-5ms per call. These add up to the difference between meeting SLOs and violating them.</p>
<p><strong>2. Operational complexity is a tax</strong>
Running two different proxy technologies (e.g., Kong + Istio) doubles operational burden. Unified tooling (Envoy Gateway + Linkerd, both Envoy-based) reduces cognitive load.</p>
<p><strong>3. Cost efficiency at scale differs from small scale</strong>
DynamoDB is cost-effective at low QPS but becomes expensive at 1M+ QPS. CockroachDB’s upfront complexity pays off with 2-3× savings (post-Nov 2024 pricing).</p>
<p><strong>4. Graceful degradation prevents catastrophic failure</strong>
The RTB 120ms hard timeout (from <a href="/blog/ads-platform-part-1-foundation-architecture/#p99-tail-latency-defense-the-unacceptable-tail">Part 1’s P99 defense</a>) means 1% of traffic loses 40-60% revenue, but prevents 100% loss from timeouts. Better to serve a guaranteed ad than wait for a perfect bid that never arrives.</p>
<p><strong>5. Production validation matters more than benchmarks</strong>
Netflix validated ZGC at scale. LinkedIn adopted Valkey. These real-world validations gave confidence in technology choices.</p>
<h3 id="final-thoughts">Final Thoughts</h3>
<p>Building a 1M+ QPS ads platform is a systems engineering challenge - no single technology is a silver bullet. Success comes from:</p>
<ul>
<li><strong>Clear requirements</strong> (<a href="/blog/ads-platform-part-1-foundation-architecture/">Part 1’s</a> latency budgets, availability targets)</li>
<li><strong>Advanced architecture</strong> (<a href="/blog/ads-platform-part-2-rtb-ml-pipeline/">Part 2’s</a> dual-source parallelization)</li>
<li><strong>Careful data layer design</strong> (<a href="/blog/ads-platform-part-3-data-revenue/">Part 3’s</a> cache hierarchy, atomic operations)</li>
<li><strong>Production discipline</strong> (<a href="/blog/ads-platform-part-4-production/">Part 4’s</a> fraud detection, chaos testing)</li>
<li><strong>Validated technology choices</strong> (Part 5’s concrete stack)</li>
</ul>
<p>You now have a complete blueprint - from requirements to deployed system. The architecture is production-ready, battle-tested by similar platforms (Netflix, LinkedIn, Uber validations), and cost-optimized (60% compute efficiency, 2-3× database savings at scale).</p>
<p><strong>What Made This Worth Building</strong></p>
<p><a href="/blog/ads-platform-part-1-foundation-architecture/">Part 1</a> framed this as a <a href="https://www.psychologytoday.com/us/blog/the-digital-self/202312/new-years-resolution-go-to-ais-cognitive-gym">cognitive workout</a> - training engineering thinking through complex constraints. After five posts, that framing holds. The constraints forced specific disciplines: latency budgeting trained decomposition (150ms split across 15-20 components), financial accuracy forced consistency modeling (strong vs eventual), and massive coordination demanded failure handling (graceful degradation when DSPs timeout). These skills - decomposing budgets, modeling consistency, designing for failure - don’t get commoditized by better AI tools.</p>
<p><strong>For Builders</strong></p>
<p>If you’re building a real-time ads platform: start with latency budgets (decompose 150ms P99 before writing code), model consistency requirements (budgets need strong consistency, profiles tolerate eventual), design for failure from day one (circuit breakers are core architecture, not hardening), and plan for non-technical gates (DSP legal, SOC 2, gradual ramp dominate your critical path - 15-18 months total).</p>
<p>This series gives you the blueprint. Now go build something real.</p>


<hr/>


  
  
  

  
  
    
  

  
  
    
    
      
        
      
    
      
    
      
    
    
      
      
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      
      

      
      
      
      
      

      
        

        

        
          
          
        
      
        

        

        
          
          
        
      
        

        

        
          
          
        
      
        

        

        
          
          
        
      
        

        
          
          
        

        
      

      
      

      
      <nav class="series-navigation" aria-label="Series navigation">
        <div class="series-info">
          <a href="https://e-mindset.space/series/architecting-ads-platforms/" class="series-link">
            Architecting Real-Time Ads Platform
          </a>
          
            <span class="series-progress">Part 5/5</span>
          
        </div>

        <div class="series-nav">
          
            <a class="series-nav-item series-nav-prev" href="https:&#x2F;&#x2F;e-mindset.space&#x2F;blog&#x2F;ads-platform-part-4-production&#x2F;" title="Production Operations: Fraud, Multi-Region &amp; Operational Excellence">
              <span class="nav-icon">←</span>
              <span class="nav-label">Previous</span>
            </a>
          

          
        </div>
      </nav>
    
  



<p class="dialog-buttons">
<a class="inline-button" href="#top">Back to top</a>
</p>
</div>
  <footer id="site-footer">
  <p><small>Powered by <a href="https://www.getzola.org">Zola</a></small></p>
</footer>

<script>
  feather.replace();
</script>
</body>
</html>
